const __vite__mapDeps = (
  i,
  m = __vite__mapDeps,
  d = m.f || (m.f = ['./D1rZgGeg.js', './WsTczmci.js', './DwVttesH.js', './index.C_tDZkHI.css'])
) => i.map((i) => d[i])
;(function () {
  const t = document.createElement('link').relList
  if (t && t.supports && t.supports('modulepreload')) return
  for (const l of document.querySelectorAll('link[rel="modulepreload"]')) a(l)
  new MutationObserver((l) => {
    for (const o of l)
      if (o.type === 'childList')
        for (const i of o.addedNodes) i.tagName === 'LINK' && i.rel === 'modulepreload' && a(i)
  }).observe(document, { childList: !0, subtree: !0 })
  function n(l) {
    const o = {}
    return (
      l.integrity && (o.integrity = l.integrity),
      l.referrerPolicy && (o.referrerPolicy = l.referrerPolicy),
      l.crossOrigin === 'use-credentials'
        ? (o.credentials = 'include')
        : l.crossOrigin === 'anonymous'
          ? (o.credentials = 'omit')
          : (o.credentials = 'same-origin'),
      o
    )
  }
  function a(l) {
    if (l.ep) return
    l.ep = !0
    const o = n(l)
    fetch(l.href, o)
  }
})()
/**
 * @vue/shared v3.5.22
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ function rc(e) {
  const t = Object.create(null)
  for (const n of e.split(',')) t[n] = 1
  return (n) => n in t
}
const Xe = {},
  Vl = [],
  Rn = () => {},
  Tm = () => !1,
  Xo = (e) =>
    e.charCodeAt(0) === 111 &&
    e.charCodeAt(1) === 110 &&
    (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97),
  sc = (e) => e.startsWith('onUpdate:'),
  Ct = Object.assign,
  uc = (e, t) => {
    const n = e.indexOf(t)
    n > -1 && e.splice(n, 1)
  },
  PS = Object.prototype.hasOwnProperty,
  Ue = (e, t) => PS.call(e, t),
  Te = Array.isArray,
  Il = (e) => Zo(e) === '[object Map]',
  Am = (e) => Zo(e) === '[object Set]',
  VS = (e) => Zo(e) === '[object RegExp]',
  Ee = (e) => typeof e == 'function',
  at = (e) => typeof e == 'string',
  ra = (e) => typeof e == 'symbol',
  Ze = (e) => e !== null && typeof e == 'object',
  cc = (e) => (Ze(e) || Ee(e)) && Ee(e.then) && Ee(e.catch),
  Em = Object.prototype.toString,
  Zo = (e) => Em.call(e),
  IS = (e) => Zo(e).slice(8, -1),
  Dm = (e) => Zo(e) === '[object Object]',
  dc = (e) => at(e) && e !== 'NaN' && e[0] !== '-' && '' + parseInt(e, 10) === e,
  Tl = rc(
    ',key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted'
  ),
  pr = (e) => {
    const t = Object.create(null)
    return (n) => t[n] || (t[n] = e(n))
  },
  TS = /-\w/g,
  Wt = pr((e) => e.replace(TS, (t) => t.slice(1).toUpperCase())),
  AS = /\B([A-Z])/g,
  ll = pr((e) => e.replace(AS, '-$1').toLowerCase()),
  Hn = pr((e) => e.charAt(0).toUpperCase() + e.slice(1)),
  os = pr((e) => (e ? `on${Hn(e)}` : '')),
  wa = (e, t) => !Object.is(e, t),
  Al = (e, ...t) => {
    for (let n = 0; n < e.length; n++) e[n](...t)
  },
  Rm = (e, t, n, a = !1) => {
    Object.defineProperty(e, t, { configurable: !0, enumerable: !1, writable: a, value: n })
  },
  Ns = (e) => {
    const t = parseFloat(e)
    return isNaN(t) ? e : t
  },
  Mm = (e) => {
    const t = at(e) ? Number(e) : NaN
    return isNaN(t) ? e : t
  }
let Zd
const Sr = () =>
  Zd ||
  (Zd =
    typeof globalThis < 'u'
      ? globalThis
      : typeof self < 'u'
        ? self
        : typeof window < 'u'
          ? window
          : typeof global < 'u'
            ? global
            : {})
function ce(e) {
  if (Te(e)) {
    const t = {}
    for (let n = 0; n < e.length; n++) {
      const a = e[n],
        l = at(a) ? MS(a) : ce(a)
      if (l) for (const o in l) t[o] = l[o]
    }
    return t
  } else if (at(e) || Ze(e)) return e
}
const ES = /;(?![^(]*\))/g,
  DS = /:([^]+)/,
  RS = /\/\*[^]*?\*\//g
function MS(e) {
  const t = {}
  return (
    e
      .replace(RS, '')
      .split(ES)
      .forEach((n) => {
        if (n) {
          const a = n.split(DS)
          a.length > 1 && (t[a[0].trim()] = a[1].trim())
        }
      }),
    t
  )
}
function ee(e) {
  let t = ''
  if (at(e)) t = e
  else if (Te(e))
    for (let n = 0; n < e.length; n++) {
      const a = ee(e[n])
      a && (t += a + ' ')
    }
  else if (Ze(e)) for (const n in e) e[n] && (t += n + ' ')
  return t.trim()
}
function BS(e) {
  if (!e) return null
  let { class: t, style: n } = e
  return (t && !at(t) && (e.class = ee(t)), n && (e.style = ce(n)), e)
}
const LS = 'itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly',
  OS = rc(LS)
function Bm(e) {
  return !!e || e === ''
}
const Lm = (e) => !!(e && e.__v_isRef === !0),
  Bn = (e) =>
    at(e)
      ? e
      : e == null
        ? ''
        : Te(e) || (Ze(e) && (e.toString === Em || !Ee(e.toString)))
          ? Lm(e)
            ? Bn(e.value)
            : JSON.stringify(e, Om, 2)
          : String(e),
  Om = (e, t) =>
    Lm(t)
      ? Om(e, t.value)
      : Il(t)
        ? {
            [`Map(${t.size})`]: [...t.entries()].reduce(
              (n, [a, l], o) => ((n[is(a, o) + ' =>'] = l), n),
              {}
            ),
          }
        : Am(t)
          ? { [`Set(${t.size})`]: [...t.values()].map((n) => is(n)) }
          : ra(t)
            ? is(t)
            : Ze(t) && !Te(t) && !Dm(t)
              ? String(t)
              : t,
  is = (e, t = '') => {
    var n
    return ra(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e
  }
/**
 * @vue/reactivity v3.5.22
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ let Bt
class $m {
  constructor(t = !1) {
    ;((this.detached = t),
      (this._active = !0),
      (this._on = 0),
      (this.effects = []),
      (this.cleanups = []),
      (this._isPaused = !1),
      (this.parent = Bt),
      !t && Bt && (this.index = (Bt.scopes || (Bt.scopes = [])).push(this) - 1))
  }
  get active() {
    return this._active
  }
  pause() {
    if (this._active) {
      this._isPaused = !0
      let t, n
      if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++) this.scopes[t].pause()
      for (t = 0, n = this.effects.length; t < n; t++) this.effects[t].pause()
    }
  }
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1
      let t, n
      if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++) this.scopes[t].resume()
      for (t = 0, n = this.effects.length; t < n; t++) this.effects[t].resume()
    }
  }
  run(t) {
    if (this._active) {
      const n = Bt
      try {
        return ((Bt = this), t())
      } finally {
        Bt = n
      }
    }
  }
  on() {
    ++this._on === 1 && ((this.prevScope = Bt), (Bt = this))
  }
  off() {
    this._on > 0 && --this._on === 0 && ((Bt = this.prevScope), (this.prevScope = void 0))
  }
  stop(t) {
    if (this._active) {
      this._active = !1
      let n, a
      for (n = 0, a = this.effects.length; n < a; n++) this.effects[n].stop()
      for (this.effects.length = 0, n = 0, a = this.cleanups.length; n < a; n++) this.cleanups[n]()
      if (((this.cleanups.length = 0), this.scopes)) {
        for (n = 0, a = this.scopes.length; n < a; n++) this.scopes[n].stop(!0)
        this.scopes.length = 0
      }
      if (!this.detached && this.parent && !t) {
        const l = this.parent.scopes.pop()
        l && l !== this && ((this.parent.scopes[this.index] = l), (l.index = this.index))
      }
      this.parent = void 0
    }
  }
}
function Ya(e) {
  return new $m(e)
}
function fc() {
  return Bt
}
function bt(e, t = !1) {
  Bt && Bt.cleanups.push(e)
}
let et
const rs = new WeakSet()
class Fm {
  constructor(t) {
    ;((this.fn = t),
      (this.deps = void 0),
      (this.depsTail = void 0),
      (this.flags = 5),
      (this.next = void 0),
      (this.cleanup = void 0),
      (this.scheduler = void 0),
      Bt && Bt.active && Bt.effects.push(this))
  }
  pause() {
    this.flags |= 64
  }
  resume() {
    this.flags & 64 && ((this.flags &= -65), rs.has(this) && (rs.delete(this), this.trigger()))
  }
  notify() {
    ;(this.flags & 2 && !(this.flags & 32)) || this.flags & 8 || Hm(this)
  }
  run() {
    if (!(this.flags & 1)) return this.fn()
    ;((this.flags |= 2), Jd(this), jm(this))
    const t = et,
      n = wn
    ;((et = this), (wn = !0))
    try {
      return this.fn()
    } finally {
      ;(zm(this), (et = t), (wn = n), (this.flags &= -3))
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let t = this.deps; t; t = t.nextDep) hc(t)
      ;((this.deps = this.depsTail = void 0),
        Jd(this),
        this.onStop && this.onStop(),
        (this.flags &= -2))
    }
  }
  trigger() {
    this.flags & 64 ? rs.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty()
  }
  runIfDirty() {
    Hs(this) && this.run()
  }
  get dirty() {
    return Hs(this)
  }
}
let Nm = 0,
  yo,
  bo
function Hm(e, t = !1) {
  if (((e.flags |= 8), t)) {
    ;((e.next = bo), (bo = e))
    return
  }
  ;((e.next = yo), (yo = e))
}
function vc() {
  Nm++
}
function mc() {
  if (--Nm > 0) return
  if (bo) {
    let t = bo
    for (bo = void 0; t; ) {
      const n = t.next
      ;((t.next = void 0), (t.flags &= -9), (t = n))
    }
  }
  let e
  for (; yo; ) {
    let t = yo
    for (yo = void 0; t; ) {
      const n = t.next
      if (((t.next = void 0), (t.flags &= -9), t.flags & 1))
        try {
          t.trigger()
        } catch (a) {
          e || (e = a)
        }
      t = n
    }
  }
  if (e) throw e
}
function jm(e) {
  for (let t = e.deps; t; t = t.nextDep)
    ((t.version = -1), (t.prevActiveLink = t.dep.activeLink), (t.dep.activeLink = t))
}
function zm(e) {
  let t,
    n = e.depsTail,
    a = n
  for (; a; ) {
    const l = a.prevDep
    ;(a.version === -1 ? (a === n && (n = l), hc(a), $S(a)) : (t = a),
      (a.dep.activeLink = a.prevActiveLink),
      (a.prevActiveLink = void 0),
      (a = l))
  }
  ;((e.deps = t), (e.depsTail = n))
}
function Hs(e) {
  for (let t = e.deps; t; t = t.nextDep)
    if (
      t.dep.version !== t.version ||
      (t.dep.computed && (Wm(t.dep.computed) || t.dep.version !== t.version))
    )
      return !0
  return !!e._dirty
}
function Wm(e) {
  if (
    (e.flags & 4 && !(e.flags & 16)) ||
    ((e.flags &= -17), e.globalVersion === _o) ||
    ((e.globalVersion = _o), !e.isSSR && e.flags & 128 && ((!e.deps && !e._dirty) || !Hs(e)))
  )
    return
  e.flags |= 2
  const t = e.dep,
    n = et,
    a = wn
  ;((et = e), (wn = !0))
  try {
    jm(e)
    const l = e.fn(e._value)
    ;(t.version === 0 || wa(l, e._value)) && ((e.flags |= 128), (e._value = l), t.version++)
  } catch (l) {
    throw (t.version++, l)
  } finally {
    ;((et = n), (wn = a), zm(e), (e.flags &= -3))
  }
}
function hc(e, t = !1) {
  const { dep: n, prevSub: a, nextSub: l } = e
  if (
    (a && ((a.nextSub = l), (e.prevSub = void 0)),
    l && ((l.prevSub = a), (e.nextSub = void 0)),
    n.subs === e && ((n.subs = a), !a && n.computed))
  ) {
    n.computed.flags &= -5
    for (let o = n.computed.deps; o; o = o.nextDep) hc(o, !0)
  }
  !t && !--n.sc && n.map && n.map.delete(n.key)
}
function $S(e) {
  const { prevDep: t, nextDep: n } = e
  ;(t && ((t.nextDep = n), (e.prevDep = void 0)), n && ((n.prevDep = t), (e.nextDep = void 0)))
}
let wn = !0
const Um = []
function ta() {
  ;(Um.push(wn), (wn = !1))
}
function na() {
  const e = Um.pop()
  wn = e === void 0 ? !0 : e
}
function Jd(e) {
  const { cleanup: t } = e
  if (((e.cleanup = void 0), t)) {
    const n = et
    et = void 0
    try {
      t()
    } finally {
      et = n
    }
  }
}
let _o = 0
class FS {
  constructor(t, n) {
    ;((this.sub = t),
      (this.dep = n),
      (this.version = n.version),
      (this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0))
  }
}
class gc {
  constructor(t) {
    ;((this.computed = t),
      (this.version = 0),
      (this.activeLink = void 0),
      (this.subs = void 0),
      (this.map = void 0),
      (this.key = void 0),
      (this.sc = 0),
      (this.__v_skip = !0))
  }
  track(t) {
    if (!et || !wn || et === this.computed) return
    let n = this.activeLink
    if (n === void 0 || n.sub !== et)
      ((n = this.activeLink = new FS(et, this)),
        et.deps
          ? ((n.prevDep = et.depsTail), (et.depsTail.nextDep = n), (et.depsTail = n))
          : (et.deps = et.depsTail = n),
        Km(n))
    else if (n.version === -1 && ((n.version = this.version), n.nextDep)) {
      const a = n.nextDep
      ;((a.prevDep = n.prevDep),
        n.prevDep && (n.prevDep.nextDep = a),
        (n.prevDep = et.depsTail),
        (n.nextDep = void 0),
        (et.depsTail.nextDep = n),
        (et.depsTail = n),
        et.deps === n && (et.deps = a))
    }
    return n
  }
  trigger(t) {
    ;(this.version++, _o++, this.notify(t))
  }
  notify(t) {
    vc()
    try {
      for (let n = this.subs; n; n = n.prevSub) n.sub.notify() && n.sub.dep.notify()
    } finally {
      mc()
    }
  }
}
function Km(e) {
  if ((e.dep.sc++, e.sub.flags & 4)) {
    const t = e.dep.computed
    if (t && !e.dep.subs) {
      t.flags |= 20
      for (let a = t.deps; a; a = a.nextDep) Km(a)
    }
    const n = e.dep.subs
    ;(n !== e && ((e.prevSub = n), n && (n.nextSub = e)), (e.dep.subs = e))
  }
}
const ji = new WeakMap(),
  Na = Symbol(''),
  js = Symbol(''),
  Po = Symbol('')
function Lt(e, t, n) {
  if (wn && et) {
    let a = ji.get(e)
    a || ji.set(e, (a = new Map()))
    let l = a.get(n)
    ;(l || (a.set(n, (l = new gc())), (l.map = a), (l.key = n)), l.track())
  }
}
function Jn(e, t, n, a, l, o) {
  const i = ji.get(e)
  if (!i) {
    _o++
    return
  }
  const r = (s) => {
    s && s.trigger()
  }
  if ((vc(), t === 'clear')) i.forEach(r)
  else {
    const s = Te(e),
      c = s && dc(n)
    if (s && n === 'length') {
      const u = Number(a)
      i.forEach((d, f) => {
        ;(f === 'length' || f === Po || (!ra(f) && f >= u)) && r(d)
      })
    } else
      switch (((n !== void 0 || i.has(void 0)) && r(i.get(n)), c && r(i.get(Po)), t)) {
        case 'add':
          s ? c && r(i.get('length')) : (r(i.get(Na)), Il(e) && r(i.get(js)))
          break
        case 'delete':
          s || (r(i.get(Na)), Il(e) && r(i.get(js)))
          break
        case 'set':
          Il(e) && r(i.get(Na))
          break
      }
  }
  mc()
}
function NS(e, t) {
  const n = ji.get(e)
  return n && n.get(t)
}
function hl(e) {
  const t = _e(e)
  return t === e ? t : (Lt(t, 'iterate', Po), mn(e) ? t : t.map(It))
}
function wr(e) {
  return (Lt((e = _e(e)), 'iterate', Po), e)
}
const HS = {
  __proto__: null,
  [Symbol.iterator]() {
    return ss(this, Symbol.iterator, It)
  },
  concat(...e) {
    return hl(this).concat(...e.map((t) => (Te(t) ? hl(t) : t)))
  },
  entries() {
    return ss(this, 'entries', (e) => ((e[1] = It(e[1])), e))
  },
  every(e, t) {
    return Kn(this, 'every', e, t, void 0, arguments)
  },
  filter(e, t) {
    return Kn(this, 'filter', e, t, (n) => n.map(It), arguments)
  },
  find(e, t) {
    return Kn(this, 'find', e, t, It, arguments)
  },
  findIndex(e, t) {
    return Kn(this, 'findIndex', e, t, void 0, arguments)
  },
  findLast(e, t) {
    return Kn(this, 'findLast', e, t, It, arguments)
  },
  findLastIndex(e, t) {
    return Kn(this, 'findLastIndex', e, t, void 0, arguments)
  },
  forEach(e, t) {
    return Kn(this, 'forEach', e, t, void 0, arguments)
  },
  includes(...e) {
    return us(this, 'includes', e)
  },
  indexOf(...e) {
    return us(this, 'indexOf', e)
  },
  join(e) {
    return hl(this).join(e)
  },
  lastIndexOf(...e) {
    return us(this, 'lastIndexOf', e)
  },
  map(e, t) {
    return Kn(this, 'map', e, t, void 0, arguments)
  },
  pop() {
    return ro(this, 'pop')
  },
  push(...e) {
    return ro(this, 'push', e)
  },
  reduce(e, ...t) {
    return Qd(this, 'reduce', e, t)
  },
  reduceRight(e, ...t) {
    return Qd(this, 'reduceRight', e, t)
  },
  shift() {
    return ro(this, 'shift')
  },
  some(e, t) {
    return Kn(this, 'some', e, t, void 0, arguments)
  },
  splice(...e) {
    return ro(this, 'splice', e)
  },
  toReversed() {
    return hl(this).toReversed()
  },
  toSorted(e) {
    return hl(this).toSorted(e)
  },
  toSpliced(...e) {
    return hl(this).toSpliced(...e)
  },
  unshift(...e) {
    return ro(this, 'unshift', e)
  },
  values() {
    return ss(this, 'values', It)
  },
}
function ss(e, t, n) {
  const a = wr(e),
    l = a[t]()
  return (
    a !== e &&
      !mn(e) &&
      ((l._next = l.next),
      (l.next = () => {
        const o = l._next()
        return (o.done || (o.value = n(o.value)), o)
      })),
    l
  )
}
const jS = Array.prototype
function Kn(e, t, n, a, l, o) {
  const i = wr(e),
    r = i !== e && !mn(e),
    s = i[t]
  if (s !== jS[t]) {
    const d = s.apply(e, o)
    return r ? It(d) : d
  }
  let c = n
  i !== e &&
    (r
      ? (c = function (d, f) {
          return n.call(this, It(d), f, e)
        })
      : n.length > 2 &&
        (c = function (d, f) {
          return n.call(this, d, f, e)
        }))
  const u = s.call(i, c, a)
  return r && l ? l(u) : u
}
function Qd(e, t, n, a) {
  const l = wr(e)
  let o = n
  return (
    l !== e &&
      (mn(e)
        ? n.length > 3 &&
          (o = function (i, r, s) {
            return n.call(this, i, r, s, e)
          })
        : (o = function (i, r, s) {
            return n.call(this, i, It(r), s, e)
          })),
    l[t](o, ...a)
  )
}
function us(e, t, n) {
  const a = _e(e)
  Lt(a, 'iterate', Po)
  const l = a[t](...n)
  return (l === -1 || l === !1) && pc(n[0]) ? ((n[0] = _e(n[0])), a[t](...n)) : l
}
function ro(e, t, n = []) {
  ;(ta(), vc())
  const a = _e(e)[t].apply(e, n)
  return (mc(), na(), a)
}
const zS = rc('__proto__,__v_isRef,__isVue'),
  Gm = new Set(
    Object.getOwnPropertyNames(Symbol)
      .filter((e) => e !== 'arguments' && e !== 'caller')
      .map((e) => Symbol[e])
      .filter(ra)
  )
function WS(e) {
  ra(e) || (e = String(e))
  const t = _e(this)
  return (Lt(t, 'has', e), t.hasOwnProperty(e))
}
class Ym {
  constructor(t = !1, n = !1) {
    ;((this._isReadonly = t), (this._isShallow = n))
  }
  get(t, n, a) {
    if (n === '__v_skip') return t.__v_skip
    const l = this._isReadonly,
      o = this._isShallow
    if (n === '__v_isReactive') return !l
    if (n === '__v_isReadonly') return l
    if (n === '__v_isShallow') return o
    if (n === '__v_raw')
      return a === (l ? (o ? ew : Jm) : o ? Zm : Xm).get(t) ||
        Object.getPrototypeOf(t) === Object.getPrototypeOf(a)
        ? t
        : void 0
    const i = Te(t)
    if (!l) {
      let s
      if (i && (s = HS[n])) return s
      if (n === 'hasOwnProperty') return WS
    }
    const r = Reflect.get(t, n, ct(t) ? t : a)
    if ((ra(n) ? Gm.has(n) : zS(n)) || (l || Lt(t, 'get', n), o)) return r
    if (ct(r)) {
      const s = i && dc(n) ? r : r.value
      return l && Ze(s) ? qa(s) : s
    }
    return Ze(r) ? (l ? qa(r) : it(r)) : r
  }
}
class qm extends Ym {
  constructor(t = !1) {
    super(!1, t)
  }
  set(t, n, a, l) {
    let o = t[n]
    if (!this._isShallow) {
      const s = aa(o)
      if ((!mn(a) && !aa(a) && ((o = _e(o)), (a = _e(a))), !Te(t) && ct(o) && !ct(a)))
        return (s || (o.value = a), !0)
    }
    const i = Te(t) && dc(n) ? Number(n) < t.length : Ue(t, n),
      r = Reflect.set(t, n, a, ct(t) ? t : l)
    return (t === _e(l) && (i ? wa(a, o) && Jn(t, 'set', n, a) : Jn(t, 'add', n, a)), r)
  }
  deleteProperty(t, n) {
    const a = Ue(t, n)
    t[n]
    const l = Reflect.deleteProperty(t, n)
    return (l && a && Jn(t, 'delete', n, void 0), l)
  }
  has(t, n) {
    const a = Reflect.has(t, n)
    return ((!ra(n) || !Gm.has(n)) && Lt(t, 'has', n), a)
  }
  ownKeys(t) {
    return (Lt(t, 'iterate', Te(t) ? 'length' : Na), Reflect.ownKeys(t))
  }
}
class US extends Ym {
  constructor(t = !1) {
    super(!0, t)
  }
  set(t, n) {
    return !0
  }
  deleteProperty(t, n) {
    return !0
  }
}
const KS = new qm(),
  GS = new US(),
  YS = new qm(!0)
const zs = (e) => e,
  mi = (e) => Reflect.getPrototypeOf(e)
function qS(e, t, n) {
  return function (...a) {
    const l = this.__v_raw,
      o = _e(l),
      i = Il(o),
      r = e === 'entries' || (e === Symbol.iterator && i),
      s = e === 'keys' && i,
      c = l[e](...a),
      u = n ? zs : t ? zi : It
    return (
      !t && Lt(o, 'iterate', s ? js : Na),
      {
        next() {
          const { value: d, done: f } = c.next()
          return f ? { value: d, done: f } : { value: r ? [u(d[0]), u(d[1])] : u(d), done: f }
        },
        [Symbol.iterator]() {
          return this
        },
      }
    )
  }
}
function hi(e) {
  return function (...t) {
    return e === 'delete' ? !1 : e === 'clear' ? void 0 : this
  }
}
function XS(e, t) {
  const n = {
    get(l) {
      const o = this.__v_raw,
        i = _e(o),
        r = _e(l)
      e || (wa(l, r) && Lt(i, 'get', l), Lt(i, 'get', r))
      const { has: s } = mi(i),
        c = t ? zs : e ? zi : It
      if (s.call(i, l)) return c(o.get(l))
      if (s.call(i, r)) return c(o.get(r))
      o !== i && o.get(l)
    },
    get size() {
      const l = this.__v_raw
      return (!e && Lt(_e(l), 'iterate', Na), l.size)
    },
    has(l) {
      const o = this.__v_raw,
        i = _e(o),
        r = _e(l)
      return (
        e || (wa(l, r) && Lt(i, 'has', l), Lt(i, 'has', r)),
        l === r ? o.has(l) : o.has(l) || o.has(r)
      )
    },
    forEach(l, o) {
      const i = this,
        r = i.__v_raw,
        s = _e(r),
        c = t ? zs : e ? zi : It
      return (!e && Lt(s, 'iterate', Na), r.forEach((u, d) => l.call(o, c(u), c(d), i)))
    },
  }
  return (
    Ct(
      n,
      e
        ? { add: hi('add'), set: hi('set'), delete: hi('delete'), clear: hi('clear') }
        : {
            add(l) {
              !t && !mn(l) && !aa(l) && (l = _e(l))
              const o = _e(this)
              return (mi(o).has.call(o, l) || (o.add(l), Jn(o, 'add', l, l)), this)
            },
            set(l, o) {
              !t && !mn(o) && !aa(o) && (o = _e(o))
              const i = _e(this),
                { has: r, get: s } = mi(i)
              let c = r.call(i, l)
              c || ((l = _e(l)), (c = r.call(i, l)))
              const u = s.call(i, l)
              return (i.set(l, o), c ? wa(o, u) && Jn(i, 'set', l, o) : Jn(i, 'add', l, o), this)
            },
            delete(l) {
              const o = _e(this),
                { has: i, get: r } = mi(o)
              let s = i.call(o, l)
              ;(s || ((l = _e(l)), (s = i.call(o, l))), r && r.call(o, l))
              const c = o.delete(l)
              return (s && Jn(o, 'delete', l, void 0), c)
            },
            clear() {
              const l = _e(this),
                o = l.size !== 0,
                i = l.clear()
              return (o && Jn(l, 'clear', void 0, void 0), i)
            },
          }
    ),
    ['keys', 'values', 'entries', Symbol.iterator].forEach((l) => {
      n[l] = qS(l, e, t)
    }),
    n
  )
}
function yc(e, t) {
  const n = XS(e, t)
  return (a, l, o) =>
    l === '__v_isReactive'
      ? !e
      : l === '__v_isReadonly'
        ? e
        : l === '__v_raw'
          ? a
          : Reflect.get(Ue(n, l) && l in a ? n : a, l, o)
}
const ZS = { get: yc(!1, !1) },
  JS = { get: yc(!1, !0) },
  QS = { get: yc(!0, !1) }
const Xm = new WeakMap(),
  Zm = new WeakMap(),
  Jm = new WeakMap(),
  ew = new WeakMap()
function tw(e) {
  switch (e) {
    case 'Object':
    case 'Array':
      return 1
    case 'Map':
    case 'Set':
    case 'WeakMap':
    case 'WeakSet':
      return 2
    default:
      return 0
  }
}
function nw(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : tw(IS(e))
}
function it(e) {
  return aa(e) ? e : bc(e, !1, KS, ZS, Xm)
}
function ea(e) {
  return bc(e, !1, YS, JS, Zm)
}
function qa(e) {
  return bc(e, !0, GS, QS, Jm)
}
function bc(e, t, n, a, l) {
  if (!Ze(e) || (e.__v_raw && !(t && e.__v_isReactive))) return e
  const o = nw(e)
  if (o === 0) return e
  const i = l.get(e)
  if (i) return i
  const r = new Proxy(e, o === 2 ? a : n)
  return (l.set(e, r), r)
}
function Ha(e) {
  return aa(e) ? Ha(e.__v_raw) : !!(e && e.__v_isReactive)
}
function aa(e) {
  return !!(e && e.__v_isReadonly)
}
function mn(e) {
  return !!(e && e.__v_isShallow)
}
function pc(e) {
  return e ? !!e.__v_raw : !1
}
function _e(e) {
  const t = e && e.__v_raw
  return t ? _e(t) : e
}
function Qm(e) {
  return (!Ue(e, '__v_skip') && Object.isExtensible(e) && Rm(e, '__v_skip', !0), e)
}
const It = (e) => (Ze(e) ? it(e) : e),
  zi = (e) => (Ze(e) ? qa(e) : e)
function ct(e) {
  return e ? e.__v_isRef === !0 : !1
}
function ae(e) {
  return eh(e, !1)
}
function oe(e) {
  return eh(e, !0)
}
function eh(e, t) {
  return ct(e) ? e : new aw(e, t)
}
class aw {
  constructor(t, n) {
    ;((this.dep = new gc()),
      (this.__v_isRef = !0),
      (this.__v_isShallow = !1),
      (this._rawValue = n ? t : _e(t)),
      (this._value = n ? t : It(t)),
      (this.__v_isShallow = n))
  }
  get value() {
    return (this.dep.track(), this._value)
  }
  set value(t) {
    const n = this._rawValue,
      a = this.__v_isShallow || mn(t) || aa(t)
    ;((t = a ? t : _e(t)),
      wa(t, n) && ((this._rawValue = t), (this._value = a ? t : It(t)), this.dep.trigger()))
  }
}
function Ke(e) {
  return ct(e) ? e.value : e
}
function Ft(e) {
  return Ee(e) ? e() : Ke(e)
}
const lw = {
  get: (e, t, n) => (t === '__v_raw' ? e : Ke(Reflect.get(e, t, n))),
  set: (e, t, n, a) => {
    const l = e[t]
    return ct(l) && !ct(n) ? ((l.value = n), !0) : Reflect.set(e, t, n, a)
  },
}
function th(e) {
  return Ha(e) ? e : new Proxy(e, lw)
}
function Yl(e) {
  const t = Te(e) ? new Array(e.length) : {}
  for (const n in e) t[n] = nh(e, n)
  return t
}
class ow {
  constructor(t, n, a) {
    ;((this._object = t),
      (this._key = n),
      (this._defaultValue = a),
      (this.__v_isRef = !0),
      (this._value = void 0))
  }
  get value() {
    const t = this._object[this._key]
    return (this._value = t === void 0 ? this._defaultValue : t)
  }
  set value(t) {
    this._object[this._key] = t
  }
  get dep() {
    return NS(_e(this._object), this._key)
  }
}
class iw {
  constructor(t) {
    ;((this._getter = t), (this.__v_isRef = !0), (this.__v_isReadonly = !0), (this._value = void 0))
  }
  get value() {
    return (this._value = this._getter())
  }
}
function B(e, t, n) {
  return ct(e) ? e : Ee(e) ? new iw(e) : Ze(e) && arguments.length > 1 ? nh(e, t, n) : ae(e)
}
function nh(e, t, n) {
  const a = e[t]
  return ct(a) ? a : new ow(e, t, n)
}
class rw {
  constructor(t, n, a) {
    ;((this.fn = t),
      (this.setter = n),
      (this._value = void 0),
      (this.dep = new gc(this)),
      (this.__v_isRef = !0),
      (this.deps = void 0),
      (this.depsTail = void 0),
      (this.flags = 16),
      (this.globalVersion = _o - 1),
      (this.next = void 0),
      (this.effect = this),
      (this.__v_isReadonly = !n),
      (this.isSSR = a))
  }
  notify() {
    if (((this.flags |= 16), !(this.flags & 8) && et !== this)) return (Hm(this, !0), !0)
  }
  get value() {
    const t = this.dep.track()
    return (Wm(this), t && (t.version = this.dep.version), this._value)
  }
  set value(t) {
    this.setter && this.setter(t)
  }
}
function sw(e, t, n = !1) {
  let a, l
  return (Ee(e) ? (a = e) : ((a = e.get), (l = e.set)), new rw(a, l, n))
}
const gi = {},
  Wi = new WeakMap()
let La
function uw(e, t = !1, n = La) {
  if (n) {
    let a = Wi.get(n)
    ;(a || Wi.set(n, (a = [])), a.push(e))
  }
}
function cw(e, t, n = Xe) {
  const { immediate: a, deep: l, once: o, scheduler: i, augmentJob: r, call: s } = n,
    c = (S) => (l ? S : mn(S) || l === !1 || l === 0 ? Qn(S, 1) : Qn(S))
  let u,
    d,
    f,
    v,
    g = !1,
    h = !1
  if (
    (ct(e)
      ? ((d = () => e.value), (g = mn(e)))
      : Ha(e)
        ? ((d = () => c(e)), (g = !0))
        : Te(e)
          ? ((h = !0),
            (g = e.some((S) => Ha(S) || mn(S))),
            (d = () =>
              e.map((S) => {
                if (ct(S)) return S.value
                if (Ha(S)) return c(S)
                if (Ee(S)) return s ? s(S, 2) : S()
              })))
          : Ee(e)
            ? t
              ? (d = s ? () => s(e, 2) : e)
              : (d = () => {
                  if (f) {
                    ta()
                    try {
                      f()
                    } finally {
                      na()
                    }
                  }
                  const S = La
                  La = u
                  try {
                    return s ? s(e, 3, [v]) : e(v)
                  } finally {
                    La = S
                  }
                })
            : (d = Rn),
    t && l)
  ) {
    const S = d,
      k = l === !0 ? 1 / 0 : l
    d = () => Qn(S(), k)
  }
  const m = fc(),
    b = () => {
      ;(u.stop(), m && m.active && uc(m.effects, u))
    }
  if (o && t) {
    const S = t
    t = (...k) => {
      ;(S(...k), b())
    }
  }
  let y = h ? new Array(e.length).fill(gi) : gi
  const p = (S) => {
    if (!(!(u.flags & 1) || (!u.dirty && !S)))
      if (t) {
        const k = u.run()
        if (l || g || (h ? k.some((_, P) => wa(_, y[P])) : wa(k, y))) {
          f && f()
          const _ = La
          La = u
          try {
            const P = [k, y === gi ? void 0 : h && y[0] === gi ? [] : y, v]
            ;((y = k), s ? s(t, 3, P) : t(...P))
          } finally {
            La = _
          }
        }
      } else u.run()
  }
  return (
    r && r(p),
    (u = new Fm(d)),
    (u.scheduler = i ? () => i(p, !1) : p),
    (v = (S) => uw(S, !1, u)),
    (f = u.onStop =
      () => {
        const S = Wi.get(u)
        if (S) {
          if (s) s(S, 4)
          else for (const k of S) k()
          Wi.delete(u)
        }
      }),
    t ? (a ? p(!0) : (y = u.run())) : i ? i(p.bind(null, !0), !0) : u.run(),
    (b.pause = u.pause.bind(u)),
    (b.resume = u.resume.bind(u)),
    (b.stop = b),
    b
  )
}
function Qn(e, t = 1 / 0, n) {
  if (t <= 0 || !Ze(e) || e.__v_skip || ((n = n || new Map()), (n.get(e) || 0) >= t)) return e
  if ((n.set(e, t), t--, ct(e))) Qn(e.value, t, n)
  else if (Te(e)) for (let a = 0; a < e.length; a++) Qn(e[a], t, n)
  else if (Am(e) || Il(e))
    e.forEach((a) => {
      Qn(a, t, n)
    })
  else if (Dm(e)) {
    for (const a in e) Qn(e[a], t, n)
    for (const a of Object.getOwnPropertySymbols(e))
      Object.prototype.propertyIsEnumerable.call(e, a) && Qn(e[a], t, n)
  }
  return e
}
/**
 * @vue/runtime-core v3.5.22
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ function Jo(e, t, n, a) {
  try {
    return a ? e(...a) : e()
  } catch (l) {
    ql(l, t, n)
  }
}
function kn(e, t, n, a) {
  if (Ee(e)) {
    const l = Jo(e, t, n, a)
    return (
      l &&
        cc(l) &&
        l.catch((o) => {
          ql(o, t, n)
        }),
      l
    )
  }
  if (Te(e)) {
    const l = []
    for (let o = 0; o < e.length; o++) l.push(kn(e[o], t, n, a))
    return l
  }
}
function ql(e, t, n, a = !0) {
  const l = t ? t.vnode : null,
    { errorHandler: o, throwUnhandledErrorInProduction: i } = (t && t.appContext.config) || Xe
  if (t) {
    let r = t.parent
    const s = t.proxy,
      c = `https://vuejs.org/error-reference/#runtime-${n}`
    for (; r; ) {
      const u = r.ec
      if (u) {
        for (let d = 0; d < u.length; d++) if (u[d](e, s, c) === !1) return
      }
      r = r.parent
    }
    if (o) {
      ;(ta(), Jo(o, null, 10, [e, s, c]), na())
      return
    }
  }
  dw(e, n, l, a, i)
}
function dw(e, t, n, a = !0, l = !1) {
  if (l) throw e
  console.error(e)
}
const zt = []
let An = -1
const El = []
let ba = null,
  wl = 0
const ah = Promise.resolve()
let Ui = null
function Re(e) {
  const t = Ui || ah
  return e ? t.then(this ? e.bind(this) : e) : t
}
function fw(e) {
  let t = An + 1,
    n = zt.length
  for (; t < n; ) {
    const a = (t + n) >>> 1,
      l = zt[a],
      o = Vo(l)
    o < e || (o === e && l.flags & 2) ? (t = a + 1) : (n = a)
  }
  return t
}
function Sc(e) {
  if (!(e.flags & 1)) {
    const t = Vo(e),
      n = zt[zt.length - 1]
    ;(!n || (!(e.flags & 2) && t >= Vo(n)) ? zt.push(e) : zt.splice(fw(t), 0, e),
      (e.flags |= 1),
      lh())
  }
}
function lh() {
  Ui || (Ui = ah.then(oh))
}
function Ws(e) {
  ;(Te(e)
    ? El.push(...e)
    : ba && e.id === -1
      ? ba.splice(wl + 1, 0, e)
      : e.flags & 1 || (El.push(e), (e.flags |= 1)),
    lh())
}
function ef(e, t, n = An + 1) {
  for (; n < zt.length; n++) {
    const a = zt[n]
    if (a && a.flags & 2) {
      if (e && a.id !== e.uid) continue
      ;(zt.splice(n, 1), n--, a.flags & 4 && (a.flags &= -2), a(), a.flags & 4 || (a.flags &= -2))
    }
  }
}
function Ki(e) {
  if (El.length) {
    const t = [...new Set(El)].sort((n, a) => Vo(n) - Vo(a))
    if (((El.length = 0), ba)) {
      ba.push(...t)
      return
    }
    for (ba = t, wl = 0; wl < ba.length; wl++) {
      const n = ba[wl]
      ;(n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), (n.flags &= -2))
    }
    ;((ba = null), (wl = 0))
  }
}
const Vo = (e) => (e.id == null ? (e.flags & 2 ? -1 : 1 / 0) : e.id)
function oh(e) {
  try {
    for (An = 0; An < zt.length; An++) {
      const t = zt[An]
      t &&
        !(t.flags & 8) &&
        (t.flags & 4 && (t.flags &= -2), Jo(t, t.i, t.i ? 15 : 14), t.flags & 4 || (t.flags &= -2))
    }
  } finally {
    for (; An < zt.length; An++) {
      const t = zt[An]
      t && (t.flags &= -2)
    }
    ;((An = -1), (zt.length = 0), Ki(), (Ui = null), (zt.length || El.length) && oh())
  }
}
let At = null,
  ih = null
function Gi(e) {
  const t = At
  return ((At = e), (ih = (e && e.type.__scopeId) || null), t)
}
function tn(e, t = At, n) {
  if (!t || e._n) return e
  const a = (...l) => {
    a._d && Ji(-1)
    const o = Gi(t)
    let i
    try {
      i = e(...l)
    } finally {
      ;(Gi(o), a._d && Ji(1))
    }
    return i
  }
  return ((a._n = !0), (a._c = !0), (a._d = !0), a)
}
function tt(e, t) {
  if (At === null) return e
  const n = Ir(At),
    a = e.dirs || (e.dirs = [])
  for (let l = 0; l < t.length; l++) {
    let [o, i, r, s = Xe] = t[l]
    o &&
      (Ee(o) && (o = { mounted: o, updated: o }),
      o.deep && Qn(i),
      a.push({ dir: o, instance: n, value: i, oldValue: void 0, arg: r, modifiers: s }))
  }
  return e
}
function En(e, t, n, a) {
  const l = e.dirs,
    o = t && t.dirs
  for (let i = 0; i < l.length; i++) {
    const r = l[i]
    o && (r.oldValue = o[i].value)
    let s = r.dir[a]
    s && (ta(), kn(s, n, 8, [e.el, r, e, t]), na())
  }
}
const rh = Symbol('_vte'),
  sh = (e) => e.__isTeleport,
  po = (e) => e && (e.disabled || e.disabled === ''),
  tf = (e) => e && (e.defer || e.defer === ''),
  nf = (e) => typeof SVGElement < 'u' && e instanceof SVGElement,
  af = (e) => typeof MathMLElement == 'function' && e instanceof MathMLElement,
  Us = (e, t) => {
    const n = e && e.to
    return at(n) ? (t ? t(n) : null) : n
  },
  uh = {
    name: 'Teleport',
    __isTeleport: !0,
    process(e, t, n, a, l, o, i, r, s, c) {
      const {
          mc: u,
          pc: d,
          pbc: f,
          o: { insert: v, querySelector: g, createText: h, createComment: m },
        } = c,
        b = po(t.props)
      let { shapeFlag: y, children: p, dynamicChildren: S } = t
      if (e == null) {
        const k = (t.el = h('')),
          _ = (t.anchor = h(''))
        ;(v(k, n, a), v(_, n, a))
        const P = (D, E) => {
            y & 16 && u(p, D, E, l, o, i, r, s)
          },
          A = () => {
            const D = (t.target = Us(t.props, g)),
              E = ch(D, t, h, v)
            D &&
              (i !== 'svg' && nf(D) ? (i = 'svg') : i !== 'mathml' && af(D) && (i = 'mathml'),
              l && l.isCE && (l.ce._teleportTargets || (l.ce._teleportTargets = new Set())).add(D),
              b || (P(D, E), Mi(t, !1)))
          }
        ;(b && (P(n, _), Mi(t, !0)),
          tf(t.props)
            ? ((t.el.__isMounted = !1),
              wt(() => {
                ;(A(), delete t.el.__isMounted)
              }, o))
            : A())
      } else {
        if (tf(t.props) && e.el.__isMounted === !1) {
          wt(() => {
            uh.process(e, t, n, a, l, o, i, r, s, c)
          }, o)
          return
        }
        ;((t.el = e.el), (t.targetStart = e.targetStart))
        const k = (t.anchor = e.anchor),
          _ = (t.target = e.target),
          P = (t.targetAnchor = e.targetAnchor),
          A = po(e.props),
          D = A ? n : _,
          E = A ? k : P
        if (
          (i === 'svg' || nf(_) ? (i = 'svg') : (i === 'mathml' || af(_)) && (i = 'mathml'),
          S
            ? (f(e.dynamicChildren, S, D, l, o, i, r), Vc(e, t, !0))
            : s || d(e, t, D, E, l, o, i, r, !1),
          b)
        )
          A
            ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to)
            : yi(t, n, k, c, 1)
        else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
          const R = (t.target = Us(t.props, g))
          R && yi(t, R, null, c, 0)
        } else A && yi(t, _, P, c, 1)
        Mi(t, b)
      }
    },
    remove(e, t, n, { um: a, o: { remove: l } }, o) {
      const {
        shapeFlag: i,
        children: r,
        anchor: s,
        targetStart: c,
        targetAnchor: u,
        target: d,
        props: f,
      } = e
      if ((d && (l(c), l(u)), o && l(s), i & 16)) {
        const v = o || !po(f)
        for (let g = 0; g < r.length; g++) {
          const h = r[g]
          a(h, t, n, v, !!h.dynamicChildren)
        }
      }
    },
    move: yi,
    hydrate: vw,
  }
function yi(e, t, n, { o: { insert: a }, m: l }, o = 2) {
  o === 0 && a(e.targetAnchor, t, n)
  const { el: i, anchor: r, shapeFlag: s, children: c, props: u } = e,
    d = o === 2
  if ((d && a(i, t, n), (!d || po(u)) && s & 16))
    for (let f = 0; f < c.length; f++) l(c[f], t, n, 2)
  d && a(r, t, n)
}
function vw(
  e,
  t,
  n,
  a,
  l,
  o,
  { o: { nextSibling: i, parentNode: r, querySelector: s, insert: c, createText: u } },
  d
) {
  function f(h, m, b, y) {
    ;((m.anchor = d(i(h), m, r(h), n, a, l, o)), (m.targetStart = b), (m.targetAnchor = y))
  }
  const v = (t.target = Us(t.props, s)),
    g = po(t.props)
  if (v) {
    const h = v._lpa || v.firstChild
    if (t.shapeFlag & 16)
      if (g) f(e, t, h, h && i(h))
      else {
        t.anchor = i(e)
        let m = h
        for (; m; ) {
          if (m && m.nodeType === 8) {
            if (m.data === 'teleport start anchor') t.targetStart = m
            else if (m.data === 'teleport anchor') {
              ;((t.targetAnchor = m), (v._lpa = t.targetAnchor && i(t.targetAnchor)))
              break
            }
          }
          m = i(m)
        }
        ;(t.targetAnchor || ch(v, t, u, c), d(h && i(h), t, v, n, a, l, o))
      }
    Mi(t, g)
  } else g && t.shapeFlag & 16 && f(e, t, e, i(e))
  return t.anchor && i(t.anchor)
}
const mw = uh
function Mi(e, t) {
  const n = e.ctx
  if (n && n.ut) {
    let a, l
    for (
      t ? ((a = e.el), (l = e.anchor)) : ((a = e.targetStart), (l = e.targetAnchor));
      a && a !== l;

    )
      (a.nodeType === 1 && a.setAttribute('data-v-owner', n.uid), (a = a.nextSibling))
    n.ut()
  }
}
function ch(e, t, n, a) {
  const l = (t.targetStart = n('')),
    o = (t.targetAnchor = n(''))
  return ((l[rh] = o), e && (a(l, e), a(o, e)), o)
}
const Xn = Symbol('_leaveCb'),
  bi = Symbol('_enterCb')
function dh() {
  const e = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map() }
  return (
    pt(() => {
      e.isMounted = !0
    }),
    dt(() => {
      e.isUnmounting = !0
    }),
    e
  )
}
const dn = [Function, Array],
  fh = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: dn,
    onEnter: dn,
    onAfterEnter: dn,
    onEnterCancelled: dn,
    onBeforeLeave: dn,
    onLeave: dn,
    onAfterLeave: dn,
    onLeaveCancelled: dn,
    onBeforeAppear: dn,
    onAppear: dn,
    onAfterAppear: dn,
    onAppearCancelled: dn,
  },
  vh = (e) => {
    const t = e.subTree
    return t.component ? vh(t.component) : t
  },
  hw = {
    name: 'BaseTransition',
    props: fh,
    setup(e, { slots: t }) {
      const n = jn(),
        a = dh()
      return () => {
        const l = t.default && wc(t.default(), !0)
        if (!l || !l.length) return
        const o = mh(l),
          i = _e(e),
          { mode: r } = i
        if (a.isLeaving) return cs(o)
        const s = lf(o)
        if (!s) return cs(o)
        let c = Io(s, i, a, n, (d) => (c = d))
        s.type !== mt && xa(s, c)
        let u = n.subTree && lf(n.subTree)
        if (u && u.type !== mt && !pn(u, s) && vh(n).type !== mt) {
          let d = Io(u, i, a, n)
          if ((xa(u, d), r === 'out-in' && s.type !== mt))
            return (
              (a.isLeaving = !0),
              (d.afterLeave = () => {
                ;((a.isLeaving = !1),
                  n.job.flags & 8 || n.update(),
                  delete d.afterLeave,
                  (u = void 0))
              }),
              cs(o)
            )
          r === 'in-out' && s.type !== mt
            ? (d.delayLeave = (f, v, g) => {
                const h = hh(a, u)
                ;((h[String(u.key)] = u),
                  (f[Xn] = () => {
                    ;(v(), (f[Xn] = void 0), delete c.delayedLeave, (u = void 0))
                  }),
                  (c.delayedLeave = () => {
                    ;(g(), delete c.delayedLeave, (u = void 0))
                  }))
              })
            : (u = void 0)
        } else u && (u = void 0)
        return o
      }
    },
  }
function mh(e) {
  let t = e[0]
  if (e.length > 1) {
    for (const n of e)
      if (n.type !== mt) {
        t = n
        break
      }
  }
  return t
}
const gw = hw
function hh(e, t) {
  const { leavingVNodes: n } = e
  let a = n.get(t.type)
  return (a || ((a = Object.create(null)), n.set(t.type, a)), a)
}
function Io(e, t, n, a, l) {
  const {
      appear: o,
      mode: i,
      persisted: r = !1,
      onBeforeEnter: s,
      onEnter: c,
      onAfterEnter: u,
      onEnterCancelled: d,
      onBeforeLeave: f,
      onLeave: v,
      onAfterLeave: g,
      onLeaveCancelled: h,
      onBeforeAppear: m,
      onAppear: b,
      onAfterAppear: y,
      onAppearCancelled: p,
    } = t,
    S = String(e.key),
    k = hh(n, e),
    _ = (D, E) => {
      D && kn(D, a, 9, E)
    },
    P = (D, E) => {
      const R = E[1]
      ;(_(D, E), Te(D) ? D.every((V) => V.length <= 1) && R() : D.length <= 1 && R())
    },
    A = {
      mode: i,
      persisted: r,
      beforeEnter(D) {
        let E = s
        if (!n.isMounted)
          if (o) E = m || s
          else return
        D[Xn] && D[Xn](!0)
        const R = k[S]
        ;(R && pn(e, R) && R.el[Xn] && R.el[Xn](), _(E, [D]))
      },
      enter(D) {
        let E = c,
          R = u,
          V = d
        if (!n.isMounted)
          if (o) ((E = b || c), (R = y || u), (V = p || d))
          else return
        let M = !1
        const F = (D[bi] = (G) => {
          M ||
            ((M = !0),
            G ? _(V, [D]) : _(R, [D]),
            A.delayedLeave && A.delayedLeave(),
            (D[bi] = void 0))
        })
        E ? P(E, [D, F]) : F()
      },
      leave(D, E) {
        const R = String(e.key)
        if ((D[bi] && D[bi](!0), n.isUnmounting)) return E()
        _(f, [D])
        let V = !1
        const M = (D[Xn] = (F) => {
          V ||
            ((V = !0), E(), F ? _(h, [D]) : _(g, [D]), (D[Xn] = void 0), k[R] === e && delete k[R])
        })
        ;((k[R] = e), v ? P(v, [D, M]) : M())
      },
      clone(D) {
        const E = Io(D, t, n, a, l)
        return (l && l(E), E)
      },
    }
  return A
}
function cs(e) {
  if (Qo(e)) return ((e = Ln(e)), (e.children = null), e)
}
function lf(e) {
  if (!Qo(e)) return sh(e.type) && e.children ? mh(e.children) : e
  if (e.component) return e.component.subTree
  const { shapeFlag: t, children: n } = e
  if (n) {
    if (t & 16) return n[0]
    if (t & 32 && Ee(n.default)) return n.default()
  }
}
function xa(e, t) {
  e.shapeFlag & 6 && e.component
    ? ((e.transition = t), xa(e.component.subTree, t))
    : e.shapeFlag & 128
      ? ((e.ssContent.transition = t.clone(e.ssContent)),
        (e.ssFallback.transition = t.clone(e.ssFallback)))
      : (e.transition = t)
}
function wc(e, t = !1, n) {
  let a = [],
    l = 0
  for (let o = 0; o < e.length; o++) {
    let i = e[o]
    const r = n == null ? i.key : String(n) + String(i.key != null ? i.key : o)
    i.type === he
      ? (i.patchFlag & 128 && l++, (a = a.concat(wc(i.children, t, r))))
      : (t || i.type !== mt) && a.push(r != null ? Ln(i, { key: r }) : i)
  }
  if (l > 1) for (let o = 0; o < a.length; o++) a[o].patchFlag = -2
  return a
}
function sa(e, t) {
  return Ee(e) ? Ct({ name: e.name }, t, { setup: e }) : e
}
function Rt() {
  const e = jn()
  return e ? (e.appContext.config.idPrefix || 'v') + '-' + e.ids[0] + e.ids[1]++ : ''
}
function kc(e) {
  e.ids = [e.ids[0] + e.ids[2]++ + '-', 0, 0]
}
const Yi = new WeakMap()
function Dl(e, t, n, a, l = !1) {
  if (Te(e)) {
    e.forEach((g, h) => Dl(g, t && (Te(t) ? t[h] : t), n, a, l))
    return
  }
  if (ka(a) && !l) {
    a.shapeFlag & 512 &&
      a.type.__asyncResolved &&
      a.component.subTree.component &&
      Dl(e, t, n, a.component.subTree)
    return
  }
  const o = a.shapeFlag & 4 ? Ir(a.component) : a.el,
    i = l ? null : o,
    { i: r, r: s } = e,
    c = t && t.r,
    u = r.refs === Xe ? (r.refs = {}) : r.refs,
    d = r.setupState,
    f = _e(d),
    v = d === Xe ? Tm : (g) => Ue(f, g)
  if (c != null && c !== s) {
    if ((of(t), at(c))) ((u[c] = null), v(c) && (d[c] = null))
    else if (ct(c)) {
      c.value = null
      const g = t
      g.k && (u[g.k] = null)
    }
  }
  if (Ee(s)) Jo(s, r, 12, [i, u])
  else {
    const g = at(s),
      h = ct(s)
    if (g || h) {
      const m = () => {
        if (e.f) {
          const b = g ? (v(s) ? d[s] : u[s]) : s.value
          if (l) Te(b) && uc(b, o)
          else if (Te(b)) b.includes(o) || b.push(o)
          else if (g) ((u[s] = [o]), v(s) && (d[s] = u[s]))
          else {
            const y = [o]
            ;((s.value = y), e.k && (u[e.k] = y))
          }
        } else g ? ((u[s] = i), v(s) && (d[s] = i)) : h && ((s.value = i), e.k && (u[e.k] = i))
      }
      if (i) {
        const b = () => {
          ;(m(), Yi.delete(e))
        }
        ;((b.id = -1), Yi.set(e, b), wt(b, n))
      } else (of(e), m())
    }
  }
}
function of(e) {
  const t = Yi.get(e)
  t && ((t.flags |= 8), Yi.delete(e))
}
let rf = !1
const gl = () => {
    rf || (console.error('Hydration completed but contains mismatches.'), (rf = !0))
  },
  yw = (e) => e.namespaceURI.includes('svg') && e.tagName !== 'foreignObject',
  bw = (e) => e.namespaceURI.includes('MathML'),
  pi = (e) => {
    if (e.nodeType === 1) {
      if (yw(e)) return 'svg'
      if (bw(e)) return 'mathml'
    }
  },
  xl = (e) => e.nodeType === 8
function pw(e) {
  const {
      mt: t,
      p: n,
      o: {
        patchProp: a,
        createText: l,
        nextSibling: o,
        parentNode: i,
        remove: r,
        insert: s,
        createComment: c,
      },
    } = e,
    u = (p, S) => {
      if (!S.hasChildNodes()) {
        ;(n(null, p, S), Ki(), (S._vnode = p))
        return
      }
      ;(d(S.firstChild, p, null, null, null), Ki(), (S._vnode = p))
    },
    d = (p, S, k, _, P, A = !1) => {
      A = A || !!S.dynamicChildren
      const D = xl(p) && p.data === '[',
        E = () => h(p, S, k, _, P, D),
        { type: R, ref: V, shapeFlag: M, patchFlag: F } = S
      let G = p.nodeType
      ;((S.el = p), F === -2 && ((A = !1), (S.dynamicChildren = null)))
      let W = null
      switch (R) {
        case Ca:
          G !== 3
            ? S.children === ''
              ? (s((S.el = l('')), i(p), p), (W = p))
              : (W = E())
            : (p.data !== S.children && (gl(), (p.data = S.children)), (W = o(p)))
          break
        case mt:
          y(p)
            ? ((W = o(p)), b((S.el = p.content.firstChild), p, k))
            : G !== 8 || D
              ? (W = E())
              : (W = o(p))
          break
        case Bi:
          if ((D && ((p = o(p)), (G = p.nodeType)), G === 1 || G === 3)) {
            W = p
            const te = !S.children.length
            for (let H = 0; H < S.staticCount; H++)
              (te && (S.children += W.nodeType === 1 ? W.outerHTML : W.data),
                H === S.staticCount - 1 && (S.anchor = W),
                (W = o(W)))
            return D ? o(W) : W
          } else E()
          break
        case he:
          D ? (W = g(p, S, k, _, P, A)) : (W = E())
          break
        default:
          if (M & 1)
            (G !== 1 || S.type.toLowerCase() !== p.tagName.toLowerCase()) && !y(p)
              ? (W = E())
              : (W = f(p, S, k, _, P, A))
          else if (M & 6) {
            S.slotScopeIds = P
            const te = i(p)
            if (
              (D
                ? (W = m(p))
                : xl(p) && p.data === 'teleport start'
                  ? (W = m(p, p.data, 'teleport end'))
                  : (W = o(p)),
              t(S, te, null, k, _, pi(te), A),
              ka(S) && !S.type.__asyncResolved)
            ) {
              let H
              ;(D
                ? ((H = w(he)), (H.anchor = W ? W.previousSibling : te.lastChild))
                : (H = p.nodeType === 3 ? qt('') : w('div')),
                (H.el = p),
                (S.component.subTree = H))
            }
          } else
            M & 64
              ? G !== 8
                ? (W = E())
                : (W = S.type.hydrate(p, S, k, _, P, A, e, v))
              : M & 128 && (W = S.type.hydrate(p, S, k, _, pi(i(p)), P, A, e, d))
      }
      return (V != null && Dl(V, null, _, S), W)
    },
    f = (p, S, k, _, P, A) => {
      A = A || !!S.dynamicChildren
      const { type: D, props: E, patchFlag: R, shapeFlag: V, dirs: M, transition: F } = S,
        G = D === 'input' || D === 'option'
      if (G || R !== -1) {
        M && En(S, null, k, 'created')
        let W = !1
        if (y(p)) {
          W = Lh(null, F) && k && k.vnode.props && k.vnode.props.appear
          const H = p.content.firstChild
          if (W) {
            const O = H.getAttribute('class')
            ;(O && (H.$cls = O), F.beforeEnter(H))
          }
          ;(b(H, p, k), (S.el = p = H))
        }
        if (V & 16 && !(E && (E.innerHTML || E.textContent))) {
          let H = v(p.firstChild, S, p, k, _, P, A)
          for (; H; ) {
            Si(p, 1) || gl()
            const O = H
            ;((H = H.nextSibling), r(O))
          }
        } else if (V & 8) {
          let H = S.children
          ;(H[0] ===
            `
` &&
            (p.tagName === 'PRE' || p.tagName === 'TEXTAREA') &&
            (H = H.slice(1)),
            p.textContent !== H && (Si(p, 0) || gl(), (p.textContent = S.children)))
        }
        if (E) {
          if (G || !A || R & 48) {
            const H = p.tagName.includes('-')
            for (const O in E)
              ((G && (O.endsWith('value') || O === 'indeterminate')) ||
                (Xo(O) && !Tl(O)) ||
                O[0] === '.' ||
                H) &&
                a(p, O, null, E[O], void 0, k)
          } else if (E.onClick) a(p, 'onClick', null, E.onClick, void 0, k)
          else if (R & 4 && Ha(E.style)) for (const H in E.style) E.style[H]
        }
        let te
        ;((te = E && E.onVnodeBeforeMount) && Gt(te, k, S),
          M && En(S, null, k, 'beforeMount'),
          ((te = E && E.onVnodeMounted) || M || W) &&
            jh(() => {
              ;(te && Gt(te, k, S), W && F.enter(p), M && En(S, null, k, 'mounted'))
            }, _))
      }
      return p.nextSibling
    },
    v = (p, S, k, _, P, A, D) => {
      D = D || !!S.dynamicChildren
      const E = S.children,
        R = E.length
      for (let V = 0; V < R; V++) {
        const M = D ? E[V] : (E[V] = nn(E[V])),
          F = M.type === Ca
        p
          ? (F &&
              !D &&
              V + 1 < R &&
              nn(E[V + 1]).type === Ca &&
              (s(l(p.data.slice(M.children.length)), k, o(p)), (p.data = M.children)),
            (p = d(p, M, _, P, A, D)))
          : F && !M.children
            ? s((M.el = l('')), k)
            : (Si(k, 1) || gl(), n(null, M, k, null, _, P, pi(k), A))
      }
      return p
    },
    g = (p, S, k, _, P, A) => {
      const { slotScopeIds: D } = S
      D && (P = P ? P.concat(D) : D)
      const E = i(p),
        R = v(o(p), S, E, k, _, P, A)
      return R && xl(R) && R.data === ']'
        ? o((S.anchor = R))
        : (gl(), s((S.anchor = c(']')), E, R), R)
    },
    h = (p, S, k, _, P, A) => {
      if ((Si(p.parentElement, 1) || gl(), (S.el = null), A)) {
        const R = m(p)
        for (;;) {
          const V = o(p)
          if (V && V !== R) r(V)
          else break
        }
      }
      const D = o(p),
        E = i(p)
      return (r(p), n(null, S, E, D, k, _, pi(E), P), k && ((k.vnode.el = S.el), Vr(k, S.el)), D)
    },
    m = (p, S = '[', k = ']') => {
      let _ = 0
      for (; p; )
        if (((p = o(p)), p && xl(p) && (p.data === S && _++, p.data === k))) {
          if (_ === 0) return o(p)
          _--
        }
      return p
    },
    b = (p, S, k) => {
      const _ = S.parentNode
      _ && _.replaceChild(p, S)
      let P = k
      for (; P; ) (P.vnode.el === S && (P.vnode.el = P.subTree.el = p), (P = P.parent))
    },
    y = (p) => p.nodeType === 1 && p.tagName === 'TEMPLATE'
  return [u, d]
}
const sf = 'data-allow-mismatch',
  Sw = { 0: 'text', 1: 'children', 2: 'class', 3: 'style', 4: 'attribute' }
function Si(e, t) {
  if (t === 0 || t === 1) for (; e && !e.hasAttribute(sf); ) e = e.parentElement
  const n = e && e.getAttribute(sf)
  if (n == null) return !1
  if (n === '') return !0
  {
    const a = n.split(',')
    return t === 0 && a.includes('children') ? !0 : a.includes(Sw[t])
  }
}
Sr().requestIdleCallback
Sr().cancelIdleCallback
function ww(e, t) {
  if (xl(e) && e.data === '[') {
    let n = 1,
      a = e.nextSibling
    for (; a; ) {
      if (a.nodeType === 1) {
        if (t(a) === !1) break
      } else if (xl(a))
        if (a.data === ']') {
          if (--n === 0) break
        } else a.data === '[' && n++
      a = a.nextSibling
    }
  } else t(e)
}
const ka = (e) => !!e.type.__asyncLoader
function kw(e) {
  Ee(e) && (e = { loader: e })
  const {
    loader: t,
    loadingComponent: n,
    errorComponent: a,
    delay: l = 200,
    hydrate: o,
    timeout: i,
    suspensible: r = !0,
    onError: s,
  } = e
  let c = null,
    u,
    d = 0
  const f = () => (d++, (c = null), v()),
    v = () => {
      let g
      return (
        c ||
        (g = c =
          t()
            .catch((h) => {
              if (((h = h instanceof Error ? h : new Error(String(h))), s))
                return new Promise((m, b) => {
                  s(
                    h,
                    () => m(f()),
                    () => b(h),
                    d + 1
                  )
                })
              throw h
            })
            .then((h) =>
              g !== c && c
                ? c
                : (h && (h.__esModule || h[Symbol.toStringTag] === 'Module') && (h = h.default),
                  (u = h),
                  h)
            ))
      )
    }
  return sa({
    name: 'AsyncComponentWrapper',
    __asyncLoader: v,
    __asyncHydrate(g, h, m) {
      let b = !1
      ;(h.bu || (h.bu = [])).push(() => (b = !0))
      const y = () => {
          b || m()
        },
        p = o
          ? () => {
              const S = o(y, (k) => ww(g, k))
              S && (h.bum || (h.bum = [])).push(S)
            }
          : y
      u ? p() : v().then(() => !h.isUnmounted && p())
    },
    get __asyncResolved() {
      return u
    },
    setup() {
      const g = Tt
      if ((kc(g), u)) return () => ds(u, g)
      const h = (p) => {
        ;((c = null), ql(p, g, 13, !a))
      }
      if ((r && g.suspense) || Ll)
        return v()
          .then((p) => () => ds(p, g))
          .catch((p) => (h(p), () => (a ? w(a, { error: p }) : null)))
      const m = ae(!1),
        b = ae(),
        y = ae(!!l)
      return (
        l &&
          setTimeout(() => {
            y.value = !1
          }, l),
        i != null &&
          setTimeout(() => {
            if (!m.value && !b.value) {
              const p = new Error(`Async component timed out after ${i}ms.`)
              ;(h(p), (b.value = p))
            }
          }, i),
        v()
          .then(() => {
            ;((m.value = !0), g.parent && Qo(g.parent.vnode) && g.parent.update())
          })
          .catch((p) => {
            ;(h(p), (b.value = p))
          }),
        () => {
          if (m.value && u) return ds(u, g)
          if (b.value && a) return w(a, { error: b.value })
          if (n && !y.value) return w(n)
        }
      )
    },
  })
}
function ds(e, t) {
  const { ref: n, props: a, children: l, ce: o } = t.vnode,
    i = w(e, a, l)
  return ((i.ref = n), (i.ce = o), delete t.vnode.ce, i)
}
const Qo = (e) => e.type.__isKeepAlive,
  Cw = {
    name: 'KeepAlive',
    __isKeepAlive: !0,
    props: {
      include: [String, RegExp, Array],
      exclude: [String, RegExp, Array],
      max: [String, Number],
    },
    setup(e, { slots: t }) {
      const n = jn(),
        a = n.ctx
      if (!a.renderer)
        return () => {
          const y = t.default && t.default()
          return y && y.length === 1 ? y[0] : y
        }
      const l = new Map(),
        o = new Set()
      let i = null
      const r = n.suspense,
        {
          renderer: {
            p: s,
            m: c,
            um: u,
            o: { createElement: d },
          },
        } = a,
        f = d('div')
      ;((a.activate = (y, p, S, k, _) => {
        const P = y.component
        ;(c(y, p, S, 0, r),
          s(P.vnode, y, p, S, P, r, k, y.slotScopeIds, _),
          wt(() => {
            ;((P.isDeactivated = !1), P.a && Al(P.a))
            const A = y.props && y.props.onVnodeMounted
            A && Gt(A, P.parent, y)
          }, r))
      }),
        (a.deactivate = (y) => {
          const p = y.component
          ;(Xi(p.m),
            Xi(p.a),
            c(y, f, null, 1, r),
            wt(() => {
              p.da && Al(p.da)
              const S = y.props && y.props.onVnodeUnmounted
              ;(S && Gt(S, p.parent, y), (p.isDeactivated = !0))
            }, r))
        }))
      function v(y) {
        ;(fs(y), u(y, n, r, !0))
      }
      function g(y) {
        l.forEach((p, S) => {
          const k = tu(p.type)
          k && !y(k) && h(S)
        })
      }
      function h(y) {
        const p = l.get(y)
        ;(p && (!i || !pn(p, i)) ? v(p) : i && fs(i), l.delete(y), o.delete(y))
      }
      ue(
        () => [e.include, e.exclude],
        ([y, p]) => {
          ;(y && g((S) => mo(y, S)), p && g((S) => !mo(p, S)))
        },
        { flush: 'post', deep: !0 }
      )
      let m = null
      const b = () => {
        m != null &&
          (Zi(n.subTree.type)
            ? wt(() => {
                l.set(m, wi(n.subTree))
              }, n.subTree.suspense)
            : l.set(m, wi(n.subTree)))
      }
      return (
        pt(b),
        xr(b),
        dt(() => {
          l.forEach((y) => {
            const { subTree: p, suspense: S } = n,
              k = wi(p)
            if (y.type === k.type && y.key === k.key) {
              fs(k)
              const _ = k.component.da
              _ && wt(_, S)
              return
            }
            v(y)
          })
        }),
        () => {
          if (((m = null), !t.default)) return (i = null)
          const y = t.default(),
            p = y[0]
          if (y.length > 1) return ((i = null), y)
          if (!_a(p) || (!(p.shapeFlag & 4) && !(p.shapeFlag & 128))) return ((i = null), p)
          let S = wi(p)
          if (S.type === mt) return ((i = null), S)
          const k = S.type,
            _ = tu(ka(S) ? S.type.__asyncResolved || {} : k),
            { include: P, exclude: A, max: D } = e
          if ((P && (!_ || !mo(P, _))) || (A && _ && mo(A, _)))
            return ((S.shapeFlag &= -257), (i = S), p)
          const E = S.key == null ? k : S.key,
            R = l.get(E)
          return (
            S.el && ((S = Ln(S)), p.shapeFlag & 128 && (p.ssContent = S)),
            (m = E),
            R
              ? ((S.el = R.el),
                (S.component = R.component),
                S.transition && xa(S, S.transition),
                (S.shapeFlag |= 512),
                o.delete(E),
                o.add(E))
              : (o.add(E), D && o.size > parseInt(D, 10) && h(o.values().next().value)),
            (S.shapeFlag |= 256),
            (i = S),
            Zi(p.type) ? p : S
          )
        }
      )
    },
  },
  xw = Cw
function mo(e, t) {
  return Te(e)
    ? e.some((n) => mo(n, t))
    : at(e)
      ? e.split(',').includes(t)
      : VS(e)
        ? ((e.lastIndex = 0), e.test(t))
        : !1
}
function Cc(e, t) {
  gh(e, 'a', t)
}
function kr(e, t) {
  gh(e, 'da', t)
}
function gh(e, t, n = Tt) {
  const a =
    e.__wdc ||
    (e.__wdc = () => {
      let l = n
      for (; l; ) {
        if (l.isDeactivated) return
        l = l.parent
      }
      return e()
    })
  if ((Cr(t, a, n), n)) {
    let l = n.parent
    for (; l && l.parent; ) (Qo(l.parent.vnode) && _w(a, t, n, l), (l = l.parent))
  }
}
function _w(e, t, n, a) {
  const l = Cr(t, e, a, !0)
  xc(() => {
    uc(a[t], l)
  }, n)
}
function fs(e) {
  ;((e.shapeFlag &= -257), (e.shapeFlag &= -513))
}
function wi(e) {
  return e.shapeFlag & 128 ? e.ssContent : e
}
function Cr(e, t, n = Tt, a = !1) {
  if (n) {
    const l = n[e] || (n[e] = []),
      o =
        t.__weh ||
        (t.__weh = (...i) => {
          ta()
          const r = Xa(n),
            s = kn(t, n, e, i)
          return (r(), na(), s)
        })
    return (a ? l.unshift(o) : l.push(o), o)
  }
}
const ua =
    (e) =>
    (t, n = Tt) => {
      ;(!Ll || e === 'sp') && Cr(e, (...a) => t(...a), n)
    },
  Xl = ua('bm'),
  pt = ua('m'),
  yh = ua('bu'),
  xr = ua('u'),
  dt = ua('bum'),
  xc = ua('um'),
  Pw = ua('sp'),
  Vw = ua('rtg'),
  Iw = ua('rtc')
function bh(e, t = Tt) {
  Cr('ec', e, t)
}
const ph = 'components'
function Ks(e, t) {
  return kh(ph, e, !0, t) || e
}
const Sh = Symbol.for('v-ndc')
function wh(e) {
  return at(e) ? kh(ph, e, !1) || e : e || Sh
}
function kh(e, t, n = !0, a = !1) {
  const l = At || Tt
  if (l) {
    const o = l.type
    {
      const r = tu(o, !1)
      if (r && (r === t || r === Wt(t) || r === Hn(Wt(t)))) return o
    }
    const i = uf(l[e] || o[e], t) || uf(l.appContext[e], t)
    return !i && a ? o : i
  }
}
function uf(e, t) {
  return e && (e[t] || e[Wt(t)] || e[Hn(Wt(t))])
}
function yM(e, t, n, a) {
  let l
  const o = n,
    i = Te(e)
  if (i || at(e)) {
    const r = i && Ha(e)
    let s = !1,
      c = !1
    ;(r && ((s = !mn(e)), (c = aa(e)), (e = wr(e))), (l = new Array(e.length)))
    for (let u = 0, d = e.length; u < d; u++)
      l[u] = t(s ? (c ? zi(It(e[u])) : It(e[u])) : e[u], u, void 0, o)
  } else if (typeof e == 'number') {
    l = new Array(e)
    for (let r = 0; r < e; r++) l[r] = t(r + 1, r, void 0, o)
  } else if (Ze(e))
    if (e[Symbol.iterator]) l = Array.from(e, (r, s) => t(r, s, void 0, o))
    else {
      const r = Object.keys(e)
      l = new Array(r.length)
      for (let s = 0, c = r.length; s < c; s++) {
        const u = r[s]
        l[s] = t(e[u], u, s, o)
      }
    }
  else l = []
  return l
}
function bM(e, t, n = {}, a, l) {
  if (At.ce || (At.parent && ka(At.parent) && At.parent.ce)) {
    const c = Object.keys(n).length > 0
    return (vn(), Dn(he, null, [w('slot', n, a)], c ? -2 : 64))
  }
  let o = e[t]
  ;(o && o._c && (o._d = !1), vn())
  const i = o && Ch(o(n)),
    r = n.key || (i && i.key),
    s = Dn(
      he,
      { key: (r && !ra(r) ? r : `_${t}`) + (!i && a ? '_fb' : '') },
      i || [],
      i && e._ === 1 ? 64 : -2
    )
  return (s.scopeId && (s.slotScopeIds = [s.scopeId + '-s']), o && o._c && (o._d = !0), s)
}
function Ch(e) {
  return e.some((t) => (_a(t) ? !(t.type === mt || (t.type === he && !Ch(t.children))) : !0))
    ? e
    : null
}
const Gs = (e) => (e ? (Gh(e) ? Ir(e) : Gs(e.parent)) : null),
  So = Ct(Object.create(null), {
    $: (e) => e,
    $el: (e) => e.vnode.el,
    $data: (e) => e.data,
    $props: (e) => e.props,
    $attrs: (e) => e.attrs,
    $slots: (e) => e.slots,
    $refs: (e) => e.refs,
    $parent: (e) => Gs(e.parent),
    $root: (e) => Gs(e.root),
    $host: (e) => e.ce,
    $emit: (e) => e.emit,
    $options: (e) => _h(e),
    $forceUpdate: (e) =>
      e.f ||
      (e.f = () => {
        Sc(e.update)
      }),
    $nextTick: (e) => e.n || (e.n = Re.bind(e.proxy)),
    $watch: (e) => Yw.bind(e),
  }),
  vs = (e, t) => e !== Xe && !e.__isScriptSetup && Ue(e, t),
  Tw = {
    get({ _: e }, t) {
      if (t === '__v_skip') return !0
      const { ctx: n, setupState: a, data: l, props: o, accessCache: i, type: r, appContext: s } = e
      let c
      if (t[0] !== '$') {
        const v = i[t]
        if (v !== void 0)
          switch (v) {
            case 1:
              return a[t]
            case 2:
              return l[t]
            case 4:
              return n[t]
            case 3:
              return o[t]
          }
        else {
          if (vs(a, t)) return ((i[t] = 1), a[t])
          if (l !== Xe && Ue(l, t)) return ((i[t] = 2), l[t])
          if ((c = e.propsOptions[0]) && Ue(c, t)) return ((i[t] = 3), o[t])
          if (n !== Xe && Ue(n, t)) return ((i[t] = 4), n[t])
          Ys && (i[t] = 0)
        }
      }
      const u = So[t]
      let d, f
      if (u) return (t === '$attrs' && Lt(e.attrs, 'get', ''), u(e))
      if ((d = r.__cssModules) && (d = d[t])) return d
      if (n !== Xe && Ue(n, t)) return ((i[t] = 4), n[t])
      if (((f = s.config.globalProperties), Ue(f, t))) return f[t]
    },
    set({ _: e }, t, n) {
      const { data: a, setupState: l, ctx: o } = e
      return vs(l, t)
        ? ((l[t] = n), !0)
        : a !== Xe && Ue(a, t)
          ? ((a[t] = n), !0)
          : Ue(e.props, t) || (t[0] === '$' && t.slice(1) in e)
            ? !1
            : ((o[t] = n), !0)
    },
    has(
      {
        _: {
          data: e,
          setupState: t,
          accessCache: n,
          ctx: a,
          appContext: l,
          propsOptions: o,
          type: i,
        },
      },
      r
    ) {
      let s, c
      return !!(
        n[r] ||
        (e !== Xe && r[0] !== '$' && Ue(e, r)) ||
        vs(t, r) ||
        ((s = o[0]) && Ue(s, r)) ||
        Ue(a, r) ||
        Ue(So, r) ||
        Ue(l.config.globalProperties, r) ||
        ((c = i.__cssModules) && c[r])
      )
    },
    defineProperty(e, t, n) {
      return (
        n.get != null ? (e._.accessCache[t] = 0) : Ue(n, 'value') && this.set(e, t, n.value, null),
        Reflect.defineProperty(e, t, n)
      )
    },
  }
function cf(e) {
  return Te(e) ? e.reduce((t, n) => ((t[n] = null), t), {}) : e
}
function pM(e) {
  const t = jn()
  let n = e()
  return (
    Qs(),
    cc(n) &&
      (n = n.catch((a) => {
        throw (Xa(t), a)
      })),
    [n, () => Xa(t)]
  )
}
let Ys = !0
function Aw(e) {
  const t = _h(e),
    n = e.proxy,
    a = e.ctx
  ;((Ys = !1), t.beforeCreate && df(t.beforeCreate, e, 'bc'))
  const {
    data: l,
    computed: o,
    methods: i,
    watch: r,
    provide: s,
    inject: c,
    created: u,
    beforeMount: d,
    mounted: f,
    beforeUpdate: v,
    updated: g,
    activated: h,
    deactivated: m,
    beforeDestroy: b,
    beforeUnmount: y,
    destroyed: p,
    unmounted: S,
    render: k,
    renderTracked: _,
    renderTriggered: P,
    errorCaptured: A,
    serverPrefetch: D,
    expose: E,
    inheritAttrs: R,
    components: V,
    directives: M,
    filters: F,
  } = t
  if ((c && Ew(c, a, null), i))
    for (const te in i) {
      const H = i[te]
      Ee(H) && (a[te] = H.bind(n))
    }
  if (l) {
    const te = l.call(n, n)
    Ze(te) && (e.data = it(te))
  }
  if (((Ys = !0), o))
    for (const te in o) {
      const H = o[te],
        O = Ee(H) ? H.bind(n, n) : Ee(H.get) ? H.get.bind(n, n) : Rn,
        j = !Ee(H) && Ee(H.set) ? H.set.bind(n) : Rn,
        U = C({ get: O, set: j })
      Object.defineProperty(a, te, {
        enumerable: !0,
        configurable: !0,
        get: () => U.value,
        set: (Y) => (U.value = Y),
      })
    }
  if (r) for (const te in r) xh(r[te], a, n, te)
  if (s) {
    const te = Ee(s) ? s.call(n) : s
    Reflect.ownKeys(te).forEach((H) => {
      Fe(H, te[H])
    })
  }
  u && df(u, e, 'c')
  function W(te, H) {
    Te(H) ? H.forEach((O) => te(O.bind(n))) : H && te(H.bind(n))
  }
  if (
    (W(Xl, d),
    W(pt, f),
    W(yh, v),
    W(xr, g),
    W(Cc, h),
    W(kr, m),
    W(bh, A),
    W(Iw, _),
    W(Vw, P),
    W(dt, y),
    W(xc, S),
    W(Pw, D),
    Te(E))
  )
    if (E.length) {
      const te = e.exposed || (e.exposed = {})
      E.forEach((H) => {
        Object.defineProperty(te, H, { get: () => n[H], set: (O) => (n[H] = O), enumerable: !0 })
      })
    } else e.exposed || (e.exposed = {})
  ;(k && e.render === Rn && (e.render = k),
    R != null && (e.inheritAttrs = R),
    V && (e.components = V),
    M && (e.directives = M),
    D && kc(e))
}
function Ew(e, t, n = Rn) {
  Te(e) && (e = qs(e))
  for (const a in e) {
    const l = e[a]
    let o
    ;(Ze(l)
      ? 'default' in l
        ? (o = Ve(l.from || a, l.default, !0))
        : (o = Ve(l.from || a))
      : (o = Ve(l)),
      ct(o)
        ? Object.defineProperty(t, a, {
            enumerable: !0,
            configurable: !0,
            get: () => o.value,
            set: (i) => (o.value = i),
          })
        : (t[a] = o))
  }
}
function df(e, t, n) {
  kn(Te(e) ? e.map((a) => a.bind(t.proxy)) : e.bind(t.proxy), t, n)
}
function xh(e, t, n, a) {
  let l = a.includes('.') ? $h(n, a) : () => n[a]
  if (at(e)) {
    const o = t[e]
    Ee(o) && ue(l, o)
  } else if (Ee(e)) ue(l, e.bind(n))
  else if (Ze(e))
    if (Te(e)) e.forEach((o) => xh(o, t, n, a))
    else {
      const o = Ee(e.handler) ? e.handler.bind(n) : t[e.handler]
      Ee(o) && ue(l, o, e)
    }
}
function _h(e) {
  const t = e.type,
    { mixins: n, extends: a } = t,
    {
      mixins: l,
      optionsCache: o,
      config: { optionMergeStrategies: i },
    } = e.appContext,
    r = o.get(t)
  let s
  return (
    r
      ? (s = r)
      : !l.length && !n && !a
        ? (s = t)
        : ((s = {}), l.length && l.forEach((c) => qi(s, c, i, !0)), qi(s, t, i)),
    Ze(t) && o.set(t, s),
    s
  )
}
function qi(e, t, n, a = !1) {
  const { mixins: l, extends: o } = t
  ;(o && qi(e, o, n, !0), l && l.forEach((i) => qi(e, i, n, !0)))
  for (const i in t)
    if (!(a && i === 'expose')) {
      const r = Dw[i] || (n && n[i])
      e[i] = r ? r(e[i], t[i]) : t[i]
    }
  return e
}
const Dw = {
  data: ff,
  props: vf,
  emits: vf,
  methods: ho,
  computed: ho,
  beforeCreate: jt,
  created: jt,
  beforeMount: jt,
  mounted: jt,
  beforeUpdate: jt,
  updated: jt,
  beforeDestroy: jt,
  beforeUnmount: jt,
  destroyed: jt,
  unmounted: jt,
  activated: jt,
  deactivated: jt,
  errorCaptured: jt,
  serverPrefetch: jt,
  components: ho,
  directives: ho,
  watch: Mw,
  provide: ff,
  inject: Rw,
}
function ff(e, t) {
  return t
    ? e
      ? function () {
          return Ct(Ee(e) ? e.call(this, this) : e, Ee(t) ? t.call(this, this) : t)
        }
      : t
    : e
}
function Rw(e, t) {
  return ho(qs(e), qs(t))
}
function qs(e) {
  if (Te(e)) {
    const t = {}
    for (let n = 0; n < e.length; n++) t[e[n]] = e[n]
    return t
  }
  return e
}
function jt(e, t) {
  return e ? [...new Set([].concat(e, t))] : t
}
function ho(e, t) {
  return e ? Ct(Object.create(null), e, t) : t
}
function vf(e, t) {
  return e
    ? Te(e) && Te(t)
      ? [...new Set([...e, ...t])]
      : Ct(Object.create(null), cf(e), cf(t ?? {}))
    : t
}
function Mw(e, t) {
  if (!e) return t
  if (!t) return e
  const n = Ct(Object.create(null), e)
  for (const a in t) n[a] = jt(e[a], t[a])
  return n
}
function Ph() {
  return {
    app: null,
    config: {
      isNativeTag: Tm,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {},
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap(),
    propsCache: new WeakMap(),
    emitsCache: new WeakMap(),
  }
}
let Bw = 0
function Lw(e, t) {
  return function (a, l = null) {
    ;(Ee(a) || (a = Ct({}, a)), l != null && !Ze(l) && (l = null))
    const o = Ph(),
      i = new WeakSet(),
      r = []
    let s = !1
    const c = (o.app = {
      _uid: Bw++,
      _component: a,
      _props: l,
      _container: null,
      _context: o,
      _instance: null,
      version: b0,
      get config() {
        return o.config
      },
      set config(u) {},
      use(u, ...d) {
        return (
          i.has(u) ||
            (u && Ee(u.install) ? (i.add(u), u.install(c, ...d)) : Ee(u) && (i.add(u), u(c, ...d))),
          c
        )
      },
      mixin(u) {
        return (o.mixins.includes(u) || o.mixins.push(u), c)
      },
      component(u, d) {
        return d ? ((o.components[u] = d), c) : o.components[u]
      },
      directive(u, d) {
        return d ? ((o.directives[u] = d), c) : o.directives[u]
      },
      mount(u, d, f) {
        if (!s) {
          const v = c._ceVNode || w(a, l)
          return (
            (v.appContext = o),
            f === !0 ? (f = 'svg') : f === !1 && (f = void 0),
            d && t ? t(v, u) : e(v, u, f),
            (s = !0),
            (c._container = u),
            (u.__vue_app__ = c),
            Ir(v.component)
          )
        }
      },
      onUnmount(u) {
        r.push(u)
      },
      unmount() {
        s && (kn(r, c._instance, 16), e(null, c._container), delete c._container.__vue_app__)
      },
      provide(u, d) {
        return ((o.provides[u] = d), c)
      },
      runWithContext(u) {
        const d = ja
        ja = c
        try {
          return u()
        } finally {
          ja = d
        }
      },
    })
    return c
  }
}
let ja = null
function Fe(e, t) {
  if (Tt) {
    let n = Tt.provides
    const a = Tt.parent && Tt.parent.provides
    ;(a === n && (n = Tt.provides = Object.create(a)), (n[e] = t))
  }
}
function Ve(e, t, n = !1) {
  const a = jn()
  if (a || ja) {
    let l = ja
      ? ja._context.provides
      : a
        ? a.parent == null || a.ce
          ? a.vnode.appContext && a.vnode.appContext.provides
          : a.parent.provides
        : void 0
    if (l && e in l) return l[e]
    if (arguments.length > 1) return n && Ee(t) ? t.call(a && a.proxy) : t
  }
}
function _r() {
  return !!(jn() || ja)
}
const Vh = {},
  Ih = () => Object.create(Vh),
  Th = (e) => Object.getPrototypeOf(e) === Vh
function Ow(e, t, n, a = !1) {
  const l = {},
    o = Ih()
  ;((e.propsDefaults = Object.create(null)), Ah(e, t, l, o))
  for (const i in e.propsOptions[0]) i in l || (l[i] = void 0)
  ;(n ? (e.props = a ? l : ea(l)) : e.type.props ? (e.props = l) : (e.props = o), (e.attrs = o))
}
function $w(e, t, n, a) {
  const {
      props: l,
      attrs: o,
      vnode: { patchFlag: i },
    } = e,
    r = _e(l),
    [s] = e.propsOptions
  let c = !1
  if ((a || i > 0) && !(i & 16)) {
    if (i & 8) {
      const u = e.vnode.dynamicProps
      for (let d = 0; d < u.length; d++) {
        let f = u[d]
        if (Pr(e.emitsOptions, f)) continue
        const v = t[f]
        if (s)
          if (Ue(o, f)) v !== o[f] && ((o[f] = v), (c = !0))
          else {
            const g = Wt(f)
            l[g] = Xs(s, r, g, v, e, !1)
          }
        else v !== o[f] && ((o[f] = v), (c = !0))
      }
    }
  } else {
    Ah(e, t, l, o) && (c = !0)
    let u
    for (const d in r)
      (!t || (!Ue(t, d) && ((u = ll(d)) === d || !Ue(t, u)))) &&
        (s
          ? n && (n[d] !== void 0 || n[u] !== void 0) && (l[d] = Xs(s, r, d, void 0, e, !0))
          : delete l[d])
    if (o !== r) for (const d in o) (!t || !Ue(t, d)) && (delete o[d], (c = !0))
  }
  c && Jn(e.attrs, 'set', '')
}
function Ah(e, t, n, a) {
  const [l, o] = e.propsOptions
  let i = !1,
    r
  if (t)
    for (let s in t) {
      if (Tl(s)) continue
      const c = t[s]
      let u
      l && Ue(l, (u = Wt(s)))
        ? !o || !o.includes(u)
          ? (n[u] = c)
          : ((r || (r = {}))[u] = c)
        : Pr(e.emitsOptions, s) || ((!(s in a) || c !== a[s]) && ((a[s] = c), (i = !0)))
    }
  if (o) {
    const s = _e(n),
      c = r || Xe
    for (let u = 0; u < o.length; u++) {
      const d = o[u]
      n[d] = Xs(l, s, d, c[d], e, !Ue(c, d))
    }
  }
  return i
}
function Xs(e, t, n, a, l, o) {
  const i = e[n]
  if (i != null) {
    const r = Ue(i, 'default')
    if (r && a === void 0) {
      const s = i.default
      if (i.type !== Function && !i.skipFactory && Ee(s)) {
        const { propsDefaults: c } = l
        if (n in c) a = c[n]
        else {
          const u = Xa(l)
          ;((a = c[n] = s.call(null, t)), u())
        }
      } else a = s
      l.ce && l.ce._setProp(n, a)
    }
    i[0] && (o && !r ? (a = !1) : i[1] && (a === '' || a === ll(n)) && (a = !0))
  }
  return a
}
const Fw = new WeakMap()
function Eh(e, t, n = !1) {
  const a = n ? Fw : t.propsCache,
    l = a.get(e)
  if (l) return l
  const o = e.props,
    i = {},
    r = []
  let s = !1
  if (!Ee(e)) {
    const u = (d) => {
      s = !0
      const [f, v] = Eh(d, t, !0)
      ;(Ct(i, f), v && r.push(...v))
    }
    ;(!n && t.mixins.length && t.mixins.forEach(u),
      e.extends && u(e.extends),
      e.mixins && e.mixins.forEach(u))
  }
  if (!o && !s) return (Ze(e) && a.set(e, Vl), Vl)
  if (Te(o))
    for (let u = 0; u < o.length; u++) {
      const d = Wt(o[u])
      mf(d) && (i[d] = Xe)
    }
  else if (o)
    for (const u in o) {
      const d = Wt(u)
      if (mf(d)) {
        const f = o[u],
          v = (i[d] = Te(f) || Ee(f) ? { type: f } : Ct({}, f)),
          g = v.type
        let h = !1,
          m = !0
        if (Te(g))
          for (let b = 0; b < g.length; ++b) {
            const y = g[b],
              p = Ee(y) && y.name
            if (p === 'Boolean') {
              h = !0
              break
            } else p === 'String' && (m = !1)
          }
        else h = Ee(g) && g.name === 'Boolean'
        ;((v[0] = h), (v[1] = m), (h || Ue(v, 'default')) && r.push(d))
      }
    }
  const c = [i, r]
  return (Ze(e) && a.set(e, c), c)
}
function mf(e) {
  return e[0] !== '$' && !Tl(e)
}
const _c = (e) => e === '_' || e === '_ctx' || e === '$stable',
  Pc = (e) => (Te(e) ? e.map(nn) : [nn(e)]),
  Nw = (e, t, n) => {
    if (t._n) return t
    const a = tn((...l) => Pc(t(...l)), n)
    return ((a._c = !1), a)
  },
  Dh = (e, t, n) => {
    const a = e._ctx
    for (const l in e) {
      if (_c(l)) continue
      const o = e[l]
      if (Ee(o)) t[l] = Nw(l, o, a)
      else if (o != null) {
        const i = Pc(o)
        t[l] = () => i
      }
    }
  },
  Rh = (e, t) => {
    const n = Pc(t)
    e.slots.default = () => n
  },
  Mh = (e, t, n) => {
    for (const a in t) (n || !_c(a)) && (e[a] = t[a])
  },
  Hw = (e, t, n) => {
    const a = (e.slots = Ih())
    if (e.vnode.shapeFlag & 32) {
      const l = t._
      l ? (Mh(a, t, n), n && Rm(a, '_', l, !0)) : Dh(t, a)
    } else t && Rh(e, t)
  },
  jw = (e, t, n) => {
    const { vnode: a, slots: l } = e
    let o = !0,
      i = Xe
    if (a.shapeFlag & 32) {
      const r = t._
      ;(r ? (n && r === 1 ? (o = !1) : Mh(l, t, n)) : ((o = !t.$stable), Dh(t, l)), (i = t))
    } else t && (Rh(e, t), (i = { default: 1 }))
    if (o) for (const r in l) !_c(r) && i[r] == null && delete l[r]
  },
  wt = jh
function zw(e) {
  return Bh(e)
}
function Ww(e) {
  return Bh(e, pw)
}
function Bh(e, t) {
  const n = Sr()
  n.__VUE__ = !0
  const {
      insert: a,
      remove: l,
      patchProp: o,
      createElement: i,
      createText: r,
      createComment: s,
      setText: c,
      setElementText: u,
      parentNode: d,
      nextSibling: f,
      setScopeId: v = Rn,
      insertStaticContent: g,
    } = e,
    h = (
      I,
      T,
      z,
      X = null,
      N = null,
      Q = null,
      ve = void 0,
      ge = null,
      me = !!T.dynamicChildren
    ) => {
      if (I === T) return
      ;(I && !pn(I, T) && ((X = L(I)), Y(I, N, Q, !0), (I = null)),
        T.patchFlag === -2 && ((me = !1), (T.dynamicChildren = null)))
      const { type: re, ref: xe, shapeFlag: ke } = T
      switch (re) {
        case Ca:
          m(I, T, z, X)
          break
        case mt:
          b(I, T, z, X)
          break
        case Bi:
          I == null && y(T, z, X, ve)
          break
        case he:
          V(I, T, z, X, N, Q, ve, ge, me)
          break
        default:
          ke & 1
            ? k(I, T, z, X, N, Q, ve, ge, me)
            : ke & 6
              ? M(I, T, z, X, N, Q, ve, ge, me)
              : (ke & 64 || ke & 128) && re.process(I, T, z, X, N, Q, ve, ge, me, ie)
      }
      xe != null && N
        ? Dl(xe, I && I.ref, Q, T || I, !T)
        : xe == null && I && I.ref != null && Dl(I.ref, null, Q, I, !0)
    },
    m = (I, T, z, X) => {
      if (I == null) a((T.el = r(T.children)), z, X)
      else {
        const N = (T.el = I.el)
        T.children !== I.children && c(N, T.children)
      }
    },
    b = (I, T, z, X) => {
      I == null ? a((T.el = s(T.children || '')), z, X) : (T.el = I.el)
    },
    y = (I, T, z, X) => {
      ;[I.el, I.anchor] = g(I.children, T, z, X, I.el, I.anchor)
    },
    p = ({ el: I, anchor: T }, z, X) => {
      let N
      for (; I && I !== T; ) ((N = f(I)), a(I, z, X), (I = N))
      a(T, z, X)
    },
    S = ({ el: I, anchor: T }) => {
      let z
      for (; I && I !== T; ) ((z = f(I)), l(I), (I = z))
      l(T)
    },
    k = (I, T, z, X, N, Q, ve, ge, me) => {
      ;(T.type === 'svg' ? (ve = 'svg') : T.type === 'math' && (ve = 'mathml'),
        I == null ? _(T, z, X, N, Q, ve, ge, me) : D(I, T, N, Q, ve, ge, me))
    },
    _ = (I, T, z, X, N, Q, ve, ge) => {
      let me, re
      const { props: xe, shapeFlag: ke, transition: Pe, dirs: De } = I
      if (
        ((me = I.el = i(I.type, Q, xe && xe.is, xe)),
        ke & 8 ? u(me, I.children) : ke & 16 && A(I.children, me, null, X, N, ms(I, Q), ve, ge),
        De && En(I, null, X, 'created'),
        P(me, I, I.scopeId, ve, X),
        xe)
      ) {
        for (const Qe in xe) Qe !== 'value' && !Tl(Qe) && o(me, Qe, null, xe[Qe], Q, X)
        ;('value' in xe && o(me, 'value', null, xe.value, Q),
          (re = xe.onVnodeBeforeMount) && Gt(re, X, I))
      }
      De && En(I, null, X, 'beforeMount')
      const Oe = Lh(N, Pe)
      ;(Oe && Pe.beforeEnter(me),
        a(me, T, z),
        ((re = xe && xe.onVnodeMounted) || Oe || De) &&
          wt(() => {
            ;(re && Gt(re, X, I), Oe && Pe.enter(me), De && En(I, null, X, 'mounted'))
          }, N))
    },
    P = (I, T, z, X, N) => {
      if ((z && v(I, z), X)) for (let Q = 0; Q < X.length; Q++) v(I, X[Q])
      if (N) {
        let Q = N.subTree
        if (T === Q || (Zi(Q.type) && (Q.ssContent === T || Q.ssFallback === T))) {
          const ve = N.vnode
          P(I, ve, ve.scopeId, ve.slotScopeIds, N.parent)
        }
      }
    },
    A = (I, T, z, X, N, Q, ve, ge, me = 0) => {
      for (let re = me; re < I.length; re++) {
        const xe = (I[re] = ge ? pa(I[re]) : nn(I[re]))
        h(null, xe, T, z, X, N, Q, ve, ge)
      }
    },
    D = (I, T, z, X, N, Q, ve) => {
      const ge = (T.el = I.el)
      let { patchFlag: me, dynamicChildren: re, dirs: xe } = T
      me |= I.patchFlag & 16
      const ke = I.props || Xe,
        Pe = T.props || Xe
      let De
      if (
        (z && Ea(z, !1),
        (De = Pe.onVnodeBeforeUpdate) && Gt(De, z, T, I),
        xe && En(T, I, z, 'beforeUpdate'),
        z && Ea(z, !0),
        ((ke.innerHTML && Pe.innerHTML == null) || (ke.textContent && Pe.textContent == null)) &&
          u(ge, ''),
        re
          ? E(I.dynamicChildren, re, ge, z, X, ms(T, N), Q)
          : ve || H(I, T, ge, null, z, X, ms(T, N), Q, !1),
        me > 0)
      ) {
        if (me & 16) R(ge, ke, Pe, z, N)
        else if (
          (me & 2 && ke.class !== Pe.class && o(ge, 'class', null, Pe.class, N),
          me & 4 && o(ge, 'style', ke.style, Pe.style, N),
          me & 8)
        ) {
          const Oe = T.dynamicProps
          for (let Qe = 0; Qe < Oe.length; Qe++) {
            const Ye = Oe[Qe],
              Kt = ke[Ye],
              Mt = Pe[Ye]
            ;(Mt !== Kt || Ye === 'value') && o(ge, Ye, Kt, Mt, N, z)
          }
        }
        me & 1 && I.children !== T.children && u(ge, T.children)
      } else !ve && re == null && R(ge, ke, Pe, z, N)
      ;((De = Pe.onVnodeUpdated) || xe) &&
        wt(() => {
          ;(De && Gt(De, z, T, I), xe && En(T, I, z, 'updated'))
        }, X)
    },
    E = (I, T, z, X, N, Q, ve) => {
      for (let ge = 0; ge < T.length; ge++) {
        const me = I[ge],
          re = T[ge],
          xe = me.el && (me.type === he || !pn(me, re) || me.shapeFlag & 198) ? d(me.el) : z
        h(me, re, xe, null, X, N, Q, ve, !0)
      }
    },
    R = (I, T, z, X, N) => {
      if (T !== z) {
        if (T !== Xe) for (const Q in T) !Tl(Q) && !(Q in z) && o(I, Q, T[Q], null, N, X)
        for (const Q in z) {
          if (Tl(Q)) continue
          const ve = z[Q],
            ge = T[Q]
          ve !== ge && Q !== 'value' && o(I, Q, ge, ve, N, X)
        }
        'value' in z && o(I, 'value', T.value, z.value, N)
      }
    },
    V = (I, T, z, X, N, Q, ve, ge, me) => {
      const re = (T.el = I ? I.el : r('')),
        xe = (T.anchor = I ? I.anchor : r(''))
      let { patchFlag: ke, dynamicChildren: Pe, slotScopeIds: De } = T
      ;(De && (ge = ge ? ge.concat(De) : De),
        I == null
          ? (a(re, z, X), a(xe, z, X), A(T.children || [], z, xe, N, Q, ve, ge, me))
          : ke > 0 && ke & 64 && Pe && I.dynamicChildren
            ? (E(I.dynamicChildren, Pe, z, N, Q, ve, ge),
              (T.key != null || (N && T === N.subTree)) && Vc(I, T, !0))
            : H(I, T, z, xe, N, Q, ve, ge, me))
    },
    M = (I, T, z, X, N, Q, ve, ge, me) => {
      ;((T.slotScopeIds = ge),
        I == null
          ? T.shapeFlag & 512
            ? N.ctx.activate(T, z, X, ve, me)
            : F(T, z, X, N, Q, ve, me)
          : G(I, T, me))
    },
    F = (I, T, z, X, N, Q, ve) => {
      const ge = (I.component = f0(I, X, N))
      if ((Qo(I) && (ge.ctx.renderer = ie), v0(ge, !1, ve), ge.asyncDep)) {
        if ((N && N.registerDep(ge, W, ve), !I.el)) {
          const me = (ge.subTree = w(mt))
          ;(b(null, me, T, z), (I.placeholder = me.el))
        }
      } else W(ge, I, T, z, N, Q, ve)
    },
    G = (I, T, z) => {
      const X = (T.component = I.component)
      if (t0(I, T, z))
        if (X.asyncDep && !X.asyncResolved) {
          te(X, T, z)
          return
        } else ((X.next = T), X.update())
      else ((T.el = I.el), (X.vnode = T))
    },
    W = (I, T, z, X, N, Q, ve) => {
      const ge = () => {
        if (I.isMounted) {
          let { next: ke, bu: Pe, u: De, parent: Oe, vnode: Qe } = I
          {
            const Qt = Oh(I)
            if (Qt) {
              ;(ke && ((ke.el = Qe.el), te(I, ke, ve)),
                Qt.asyncDep.then(() => {
                  I.isUnmounted || ge()
                }))
              return
            }
          }
          let Ye = ke,
            Kt
          ;(Ea(I, !1),
            ke ? ((ke.el = Qe.el), te(I, ke, ve)) : (ke = Qe),
            Pe && Al(Pe),
            (Kt = ke.props && ke.props.onVnodeBeforeUpdate) && Gt(Kt, Oe, ke, Qe),
            Ea(I, !0))
          const Mt = hs(I),
            bn = I.subTree
          ;((I.subTree = Mt),
            h(bn, Mt, d(bn.el), L(bn), I, N, Q),
            (ke.el = Mt.el),
            Ye === null && Vr(I, Mt.el),
            De && wt(De, N),
            (Kt = ke.props && ke.props.onVnodeUpdated) && wt(() => Gt(Kt, Oe, ke, Qe), N))
        } else {
          let ke
          const { el: Pe, props: De } = T,
            { bm: Oe, m: Qe, parent: Ye, root: Kt, type: Mt } = I,
            bn = ka(T)
          if (
            (Ea(I, !1),
            Oe && Al(Oe),
            !bn && (ke = De && De.onVnodeBeforeMount) && Gt(ke, Ye, T),
            Ea(I, !0),
            Pe && pe)
          ) {
            const Qt = () => {
              ;((I.subTree = hs(I)), pe(Pe, I.subTree, I, N, null))
            }
            bn && Mt.__asyncHydrate ? Mt.__asyncHydrate(Pe, I, Qt) : Qt()
          } else {
            Kt.ce && Kt.ce._def.shadowRoot !== !1 && Kt.ce._injectChildStyle(Mt)
            const Qt = (I.subTree = hs(I))
            ;(h(null, Qt, z, X, I, N, Q), (T.el = Qt.el))
          }
          if ((Qe && wt(Qe, N), !bn && (ke = De && De.onVnodeMounted))) {
            const Qt = T
            wt(() => Gt(ke, Ye, Qt), N)
          }
          ;((T.shapeFlag & 256 || (Ye && ka(Ye.vnode) && Ye.vnode.shapeFlag & 256)) &&
            I.a &&
            wt(I.a, N),
            (I.isMounted = !0),
            (T = z = X = null))
        }
      }
      I.scope.on()
      const me = (I.effect = new Fm(ge))
      I.scope.off()
      const re = (I.update = me.run.bind(me)),
        xe = (I.job = me.runIfDirty.bind(me))
      ;((xe.i = I), (xe.id = I.uid), (me.scheduler = () => Sc(xe)), Ea(I, !0), re())
    },
    te = (I, T, z) => {
      T.component = I
      const X = I.vnode.props
      ;((I.vnode = T),
        (I.next = null),
        $w(I, T.props, X, z),
        jw(I, T.children, z),
        ta(),
        ef(I),
        na())
    },
    H = (I, T, z, X, N, Q, ve, ge, me = !1) => {
      const re = I && I.children,
        xe = I ? I.shapeFlag : 0,
        ke = T.children,
        { patchFlag: Pe, shapeFlag: De } = T
      if (Pe > 0) {
        if (Pe & 128) {
          j(re, ke, z, X, N, Q, ve, ge, me)
          return
        } else if (Pe & 256) {
          O(re, ke, z, X, N, Q, ve, ge, me)
          return
        }
      }
      De & 8
        ? (xe & 16 && ye(re, N, Q), ke !== re && u(z, ke))
        : xe & 16
          ? De & 16
            ? j(re, ke, z, X, N, Q, ve, ge, me)
            : ye(re, N, Q, !0)
          : (xe & 8 && u(z, ''), De & 16 && A(ke, z, X, N, Q, ve, ge, me))
    },
    O = (I, T, z, X, N, Q, ve, ge, me) => {
      ;((I = I || Vl), (T = T || Vl))
      const re = I.length,
        xe = T.length,
        ke = Math.min(re, xe)
      let Pe
      for (Pe = 0; Pe < ke; Pe++) {
        const De = (T[Pe] = me ? pa(T[Pe]) : nn(T[Pe]))
        h(I[Pe], De, z, null, N, Q, ve, ge, me)
      }
      re > xe ? ye(I, N, Q, !0, !1, ke) : A(T, z, X, N, Q, ve, ge, me, ke)
    },
    j = (I, T, z, X, N, Q, ve, ge, me) => {
      let re = 0
      const xe = T.length
      let ke = I.length - 1,
        Pe = xe - 1
      for (; re <= ke && re <= Pe; ) {
        const De = I[re],
          Oe = (T[re] = me ? pa(T[re]) : nn(T[re]))
        if (pn(De, Oe)) h(De, Oe, z, null, N, Q, ve, ge, me)
        else break
        re++
      }
      for (; re <= ke && re <= Pe; ) {
        const De = I[ke],
          Oe = (T[Pe] = me ? pa(T[Pe]) : nn(T[Pe]))
        if (pn(De, Oe)) h(De, Oe, z, null, N, Q, ve, ge, me)
        else break
        ;(ke--, Pe--)
      }
      if (re > ke) {
        if (re <= Pe) {
          const De = Pe + 1,
            Oe = De < xe ? T[De].el : X
          for (; re <= Pe; )
            (h(null, (T[re] = me ? pa(T[re]) : nn(T[re])), z, Oe, N, Q, ve, ge, me), re++)
        }
      } else if (re > Pe) for (; re <= ke; ) (Y(I[re], N, Q, !0), re++)
      else {
        const De = re,
          Oe = re,
          Qe = new Map()
        for (re = Oe; re <= Pe; re++) {
          const en = (T[re] = me ? pa(T[re]) : nn(T[re]))
          en.key != null && Qe.set(en.key, re)
        }
        let Ye,
          Kt = 0
        const Mt = Pe - Oe + 1
        let bn = !1,
          Qt = 0
        const io = new Array(Mt)
        for (re = 0; re < Mt; re++) io[re] = 0
        for (re = De; re <= ke; re++) {
          const en = I[re]
          if (Kt >= Mt) {
            Y(en, N, Q, !0)
            continue
          }
          let In
          if (en.key != null) In = Qe.get(en.key)
          else
            for (Ye = Oe; Ye <= Pe; Ye++)
              if (io[Ye - Oe] === 0 && pn(en, T[Ye])) {
                In = Ye
                break
              }
          In === void 0
            ? Y(en, N, Q, !0)
            : ((io[In - Oe] = re + 1),
              In >= Qt ? (Qt = In) : (bn = !0),
              h(en, T[In], z, null, N, Q, ve, ge, me),
              Kt++)
        }
        const Yd = bn ? Uw(io) : Vl
        for (Ye = Yd.length - 1, re = Mt - 1; re >= 0; re--) {
          const en = Oe + re,
            In = T[en],
            qd = T[en + 1],
            Xd = en + 1 < xe ? qd.el || qd.placeholder : X
          io[re] === 0
            ? h(null, In, z, Xd, N, Q, ve, ge, me)
            : bn && (Ye < 0 || re !== Yd[Ye] ? U(In, z, Xd, 2) : Ye--)
        }
      }
    },
    U = (I, T, z, X, N = null) => {
      const { el: Q, type: ve, transition: ge, children: me, shapeFlag: re } = I
      if (re & 6) {
        U(I.component.subTree, T, z, X)
        return
      }
      if (re & 128) {
        I.suspense.move(T, z, X)
        return
      }
      if (re & 64) {
        ve.move(I, T, z, ie)
        return
      }
      if (ve === he) {
        a(Q, T, z)
        for (let ke = 0; ke < me.length; ke++) U(me[ke], T, z, X)
        a(I.anchor, T, z)
        return
      }
      if (ve === Bi) {
        p(I, T, z)
        return
      }
      if (X !== 2 && re & 1 && ge)
        if (X === 0) (ge.beforeEnter(Q), a(Q, T, z), wt(() => ge.enter(Q), N))
        else {
          const { leave: ke, delayLeave: Pe, afterLeave: De } = ge,
            Oe = () => {
              I.ctx.isUnmounted ? l(Q) : a(Q, T, z)
            },
            Qe = () => {
              ;(Q._isLeaving && Q[Xn](!0),
                ke(Q, () => {
                  ;(Oe(), De && De())
                }))
            }
          Pe ? Pe(Q, Oe, Qe) : Qe()
        }
      else a(Q, T, z)
    },
    Y = (I, T, z, X = !1, N = !1) => {
      const {
        type: Q,
        props: ve,
        ref: ge,
        children: me,
        dynamicChildren: re,
        shapeFlag: xe,
        patchFlag: ke,
        dirs: Pe,
        cacheIndex: De,
      } = I
      if (
        (ke === -2 && (N = !1),
        ge != null && (ta(), Dl(ge, null, z, I, !0), na()),
        De != null && (T.renderCache[De] = void 0),
        xe & 256)
      ) {
        T.ctx.deactivate(I)
        return
      }
      const Oe = xe & 1 && Pe,
        Qe = !ka(I)
      let Ye
      if ((Qe && (Ye = ve && ve.onVnodeBeforeUnmount) && Gt(Ye, T, I), xe & 6))
        de(I.component, z, X)
      else {
        if (xe & 128) {
          I.suspense.unmount(z, X)
          return
        }
        ;(Oe && En(I, null, T, 'beforeUnmount'),
          xe & 64
            ? I.type.remove(I, T, z, ie, X)
            : re && !re.hasOnce && (Q !== he || (ke > 0 && ke & 64))
              ? ye(re, T, z, !1, !0)
              : ((Q === he && ke & 384) || (!N && xe & 16)) && ye(me, T, z),
          X && K(I))
      }
      ;((Qe && (Ye = ve && ve.onVnodeUnmounted)) || Oe) &&
        wt(() => {
          ;(Ye && Gt(Ye, T, I), Oe && En(I, null, T, 'unmounted'))
        }, z)
    },
    K = (I) => {
      const { type: T, el: z, anchor: X, transition: N } = I
      if (T === he) {
        se(z, X)
        return
      }
      if (T === Bi) {
        S(I)
        return
      }
      const Q = () => {
        ;(l(z), N && !N.persisted && N.afterLeave && N.afterLeave())
      }
      if (I.shapeFlag & 1 && N && !N.persisted) {
        const { leave: ve, delayLeave: ge } = N,
          me = () => ve(z, Q)
        ge ? ge(I.el, Q, me) : me()
      } else Q()
    },
    se = (I, T) => {
      let z
      for (; I !== T; ) ((z = f(I)), l(I), (I = z))
      l(T)
    },
    de = (I, T, z) => {
      const { bum: X, scope: N, job: Q, subTree: ve, um: ge, m: me, a: re } = I
      ;(Xi(me),
        Xi(re),
        X && Al(X),
        N.stop(),
        Q && ((Q.flags |= 8), Y(ve, I, T, z)),
        ge && wt(ge, T),
        wt(() => {
          I.isUnmounted = !0
        }, T))
    },
    ye = (I, T, z, X = !1, N = !1, Q = 0) => {
      for (let ve = Q; ve < I.length; ve++) Y(I[ve], T, z, X, N)
    },
    L = (I) => {
      if (I.shapeFlag & 6) return L(I.component.subTree)
      if (I.shapeFlag & 128) return I.suspense.next()
      const T = f(I.anchor || I.el),
        z = T && T[rh]
      return z ? f(z) : T
    }
  let q = !1
  const le = (I, T, z) => {
      ;(I == null
        ? T._vnode && Y(T._vnode, null, null, !0)
        : h(T._vnode || null, I, T, null, null, null, z),
        (T._vnode = I),
        q || ((q = !0), ef(), Ki(), (q = !1)))
    },
    ie = { p: h, um: Y, m: U, r: K, mt: F, mc: A, pc: H, pbc: E, n: L, o: e }
  let Ce, pe
  return (t && ([Ce, pe] = t(ie)), { render: le, hydrate: Ce, createApp: Lw(le, Ce) })
}
function ms({ type: e, props: t }, n) {
  return (n === 'svg' && e === 'foreignObject') ||
    (n === 'mathml' && e === 'annotation-xml' && t && t.encoding && t.encoding.includes('html'))
    ? void 0
    : n
}
function Ea({ effect: e, job: t }, n) {
  n ? ((e.flags |= 32), (t.flags |= 4)) : ((e.flags &= -33), (t.flags &= -5))
}
function Lh(e, t) {
  return (!e || (e && !e.pendingBranch)) && t && !t.persisted
}
function Vc(e, t, n = !1) {
  const a = e.children,
    l = t.children
  if (Te(a) && Te(l))
    for (let o = 0; o < a.length; o++) {
      const i = a[o]
      let r = l[o]
      ;(r.shapeFlag & 1 &&
        !r.dynamicChildren &&
        ((r.patchFlag <= 0 || r.patchFlag === 32) && ((r = l[o] = pa(l[o])), (r.el = i.el)),
        !n && r.patchFlag !== -2 && Vc(i, r)),
        r.type === Ca && r.patchFlag !== -1 && (r.el = i.el),
        r.type === mt && !r.el && (r.el = i.el))
    }
}
function Uw(e) {
  const t = e.slice(),
    n = [0]
  let a, l, o, i, r
  const s = e.length
  for (a = 0; a < s; a++) {
    const c = e[a]
    if (c !== 0) {
      if (((l = n[n.length - 1]), e[l] < c)) {
        ;((t[a] = l), n.push(a))
        continue
      }
      for (o = 0, i = n.length - 1; o < i; )
        ((r = (o + i) >> 1), e[n[r]] < c ? (o = r + 1) : (i = r))
      c < e[n[o]] && (o > 0 && (t[a] = n[o - 1]), (n[o] = a))
    }
  }
  for (o = n.length, i = n[o - 1]; o-- > 0; ) ((n[o] = i), (i = t[i]))
  return n
}
function Oh(e) {
  const t = e.subTree.component
  if (t) return t.asyncDep && !t.asyncResolved ? t : Oh(t)
}
function Xi(e) {
  if (e) for (let t = 0; t < e.length; t++) e[t].flags |= 8
}
const Kw = Symbol.for('v-scx'),
  Gw = () => Ve(Kw)
function qe(e, t) {
  return Ic(e, null, t)
}
function ue(e, t, n) {
  return Ic(e, t, n)
}
function Ic(e, t, n = Xe) {
  const { immediate: a, deep: l, flush: o, once: i } = n,
    r = Ct({}, n),
    s = (t && a) || (!t && o !== 'post')
  let c
  if (Ll) {
    if (o === 'sync') {
      const v = Gw()
      c = v.__watcherHandles || (v.__watcherHandles = [])
    } else if (!s) {
      const v = () => {}
      return ((v.stop = Rn), (v.resume = Rn), (v.pause = Rn), v)
    }
  }
  const u = Tt
  r.call = (v, g, h) => kn(v, u, g, h)
  let d = !1
  ;(o === 'post'
    ? (r.scheduler = (v) => {
        wt(v, u && u.suspense)
      })
    : o !== 'sync' &&
      ((d = !0),
      (r.scheduler = (v, g) => {
        g ? v() : Sc(v)
      })),
    (r.augmentJob = (v) => {
      ;(t && (v.flags |= 4), d && ((v.flags |= 2), u && ((v.id = u.uid), (v.i = u))))
    }))
  const f = cw(e, t, r)
  return (Ll && (c ? c.push(f) : s && f()), f)
}
function Yw(e, t, n) {
  const a = this.proxy,
    l = at(e) ? (e.includes('.') ? $h(a, e) : () => a[e]) : e.bind(a, a)
  let o
  Ee(t) ? (o = t) : ((o = t.handler), (n = t))
  const i = Xa(this),
    r = Ic(l, o.bind(a), n)
  return (i(), r)
}
function $h(e, t) {
  const n = t.split('.')
  return () => {
    let a = e
    for (let l = 0; l < n.length && a; l++) a = a[n[l]]
    return a
  }
}
const qw = (e, t) =>
  t === 'modelValue' || t === 'model-value'
    ? e.modelModifiers
    : e[`${t}Modifiers`] || e[`${Wt(t)}Modifiers`] || e[`${ll(t)}Modifiers`]
function Xw(e, t, ...n) {
  if (e.isUnmounted) return
  const a = e.vnode.props || Xe
  let l = n
  const o = t.startsWith('update:'),
    i = o && qw(a, t.slice(7))
  i && (i.trim && (l = n.map((u) => (at(u) ? u.trim() : u))), i.number && (l = n.map(Ns)))
  let r,
    s = a[(r = os(t))] || a[(r = os(Wt(t)))]
  ;(!s && o && (s = a[(r = os(ll(t)))]), s && kn(s, e, 6, l))
  const c = a[r + 'Once']
  if (c) {
    if (!e.emitted) e.emitted = {}
    else if (e.emitted[r]) return
    ;((e.emitted[r] = !0), kn(c, e, 6, l))
  }
}
const Zw = new WeakMap()
function Fh(e, t, n = !1) {
  const a = n ? Zw : t.emitsCache,
    l = a.get(e)
  if (l !== void 0) return l
  const o = e.emits
  let i = {},
    r = !1
  if (!Ee(e)) {
    const s = (c) => {
      const u = Fh(c, t, !0)
      u && ((r = !0), Ct(i, u))
    }
    ;(!n && t.mixins.length && t.mixins.forEach(s),
      e.extends && s(e.extends),
      e.mixins && e.mixins.forEach(s))
  }
  return !o && !r
    ? (Ze(e) && a.set(e, null), null)
    : (Te(o) ? o.forEach((s) => (i[s] = null)) : Ct(i, o), Ze(e) && a.set(e, i), i)
}
function Pr(e, t) {
  return !e || !Xo(t)
    ? !1
    : ((t = t.slice(2).replace(/Once$/, '')),
      Ue(e, t[0].toLowerCase() + t.slice(1)) || Ue(e, ll(t)) || Ue(e, t))
}
function hs(e) {
  const {
      type: t,
      vnode: n,
      proxy: a,
      withProxy: l,
      propsOptions: [o],
      slots: i,
      attrs: r,
      emit: s,
      render: c,
      renderCache: u,
      props: d,
      data: f,
      setupState: v,
      ctx: g,
      inheritAttrs: h,
    } = e,
    m = Gi(e)
  let b, y
  try {
    if (n.shapeFlag & 4) {
      const S = l || a,
        k = S
      ;((b = nn(c.call(k, S, u, d, v, f, g))), (y = r))
    } else {
      const S = t
      ;((b = nn(S.length > 1 ? S(d, { attrs: r, slots: i, emit: s }) : S(d, null))),
        (y = t.props ? r : Qw(r)))
    }
  } catch (S) {
    ;((wo.length = 0), ql(S, e, 1), (b = w(mt)))
  }
  let p = b
  if (y && h !== !1) {
    const S = Object.keys(y),
      { shapeFlag: k } = p
    S.length && k & 7 && (o && S.some(sc) && (y = e0(y, o)), (p = Ln(p, y, !1, !0)))
  }
  return (
    n.dirs && ((p = Ln(p, null, !1, !0)), (p.dirs = p.dirs ? p.dirs.concat(n.dirs) : n.dirs)),
    n.transition && xa(p, n.transition),
    (b = p),
    Gi(m),
    b
  )
}
function Jw(e, t = !0) {
  let n
  for (let a = 0; a < e.length; a++) {
    const l = e[a]
    if (_a(l)) {
      if (l.type !== mt || l.children === 'v-if') {
        if (n) return
        n = l
      }
    } else return
  }
  return n
}
const Qw = (e) => {
    let t
    for (const n in e) (n === 'class' || n === 'style' || Xo(n)) && ((t || (t = {}))[n] = e[n])
    return t
  },
  e0 = (e, t) => {
    const n = {}
    for (const a in e) (!sc(a) || !(a.slice(9) in t)) && (n[a] = e[a])
    return n
  }
function t0(e, t, n) {
  const { props: a, children: l, component: o } = e,
    { props: i, children: r, patchFlag: s } = t,
    c = o.emitsOptions
  if (t.dirs || t.transition) return !0
  if (n && s >= 0) {
    if (s & 1024) return !0
    if (s & 16) return a ? hf(a, i, c) : !!i
    if (s & 8) {
      const u = t.dynamicProps
      for (let d = 0; d < u.length; d++) {
        const f = u[d]
        if (i[f] !== a[f] && !Pr(c, f)) return !0
      }
    }
  } else
    return (l || r) && (!r || !r.$stable) ? !0 : a === i ? !1 : a ? (i ? hf(a, i, c) : !0) : !!i
  return !1
}
function hf(e, t, n) {
  const a = Object.keys(t)
  if (a.length !== Object.keys(e).length) return !0
  for (let l = 0; l < a.length; l++) {
    const o = a[l]
    if (t[o] !== e[o] && !Pr(n, o)) return !0
  }
  return !1
}
function Vr({ vnode: e, parent: t }, n) {
  for (; t; ) {
    const a = t.subTree
    if ((a.suspense && a.suspense.activeBranch === e && (a.el = e.el), a === e))
      (((e = t.vnode).el = n), (t = t.parent))
    else break
  }
}
const Zi = (e) => e.__isSuspense
let Zs = 0
const n0 = {
    name: 'Suspense',
    __isSuspense: !0,
    process(e, t, n, a, l, o, i, r, s, c) {
      if (e == null) a0(t, n, a, l, o, i, r, s, c)
      else {
        if (o && o.deps > 0 && !e.suspense.isInFallback) {
          ;((t.suspense = e.suspense), (t.suspense.vnode = t), (t.el = e.el))
          return
        }
        l0(e, t, n, a, l, i, r, s, c)
      }
    },
    hydrate: o0,
    normalize: i0,
  },
  Nh = n0
function To(e, t) {
  const n = e.props && e.props[t]
  Ee(n) && n()
}
function a0(e, t, n, a, l, o, i, r, s) {
  const {
      p: c,
      o: { createElement: u },
    } = s,
    d = u('div'),
    f = (e.suspense = Hh(e, l, a, t, d, n, o, i, r, s))
  ;(c(null, (f.pendingBranch = e.ssContent), d, null, a, f, o, i),
    f.deps > 0
      ? (To(e, 'onPending'),
        To(e, 'onFallback'),
        c(null, e.ssFallback, t, n, a, null, o, i),
        Rl(f, e.ssFallback))
      : f.resolve(!1, !0))
}
function l0(e, t, n, a, l, o, i, r, { p: s, um: c, o: { createElement: u } }) {
  const d = (t.suspense = e.suspense)
  ;((d.vnode = t), (t.el = e.el))
  const f = t.ssContent,
    v = t.ssFallback,
    { activeBranch: g, pendingBranch: h, isInFallback: m, isHydrating: b } = d
  if (h)
    ((d.pendingBranch = f),
      pn(h, f)
        ? (s(h, f, d.hiddenContainer, null, l, d, o, i, r),
          d.deps <= 0 ? d.resolve() : m && (b || (s(g, v, n, a, l, null, o, i, r), Rl(d, v))))
        : ((d.pendingId = Zs++),
          b ? ((d.isHydrating = !1), (d.activeBranch = h)) : c(h, l, d),
          (d.deps = 0),
          (d.effects.length = 0),
          (d.hiddenContainer = u('div')),
          m
            ? (s(null, f, d.hiddenContainer, null, l, d, o, i, r),
              d.deps <= 0 ? d.resolve() : (s(g, v, n, a, l, null, o, i, r), Rl(d, v)))
            : g && pn(g, f)
              ? (s(g, f, n, a, l, d, o, i, r), d.resolve(!0))
              : (s(null, f, d.hiddenContainer, null, l, d, o, i, r), d.deps <= 0 && d.resolve())))
  else if (g && pn(g, f)) (s(g, f, n, a, l, d, o, i, r), Rl(d, f))
  else if (
    (To(t, 'onPending'),
    (d.pendingBranch = f),
    f.shapeFlag & 512 ? (d.pendingId = f.component.suspenseId) : (d.pendingId = Zs++),
    s(null, f, d.hiddenContainer, null, l, d, o, i, r),
    d.deps <= 0)
  )
    d.resolve()
  else {
    const { timeout: y, pendingId: p } = d
    y > 0
      ? setTimeout(() => {
          d.pendingId === p && d.fallback(v)
        }, y)
      : y === 0 && d.fallback(v)
  }
}
function Hh(e, t, n, a, l, o, i, r, s, c, u = !1) {
  const {
    p: d,
    m: f,
    um: v,
    n: g,
    o: { parentNode: h, remove: m },
  } = c
  let b
  const y = r0(e)
  y && t && t.pendingBranch && ((b = t.pendingId), t.deps++)
  const p = e.props ? Mm(e.props.timeout) : void 0,
    S = o,
    k = {
      vnode: e,
      parent: t,
      parentComponent: n,
      namespace: i,
      container: a,
      hiddenContainer: l,
      deps: 0,
      pendingId: Zs++,
      timeout: typeof p == 'number' ? p : -1,
      activeBranch: null,
      pendingBranch: null,
      isInFallback: !u,
      isHydrating: u,
      isUnmounted: !1,
      effects: [],
      resolve(_ = !1, P = !1) {
        const {
          vnode: A,
          activeBranch: D,
          pendingBranch: E,
          pendingId: R,
          effects: V,
          parentComponent: M,
          container: F,
        } = k
        let G = !1
        ;(k.isHydrating
          ? (k.isHydrating = !1)
          : _ ||
            ((G = D && E.transition && E.transition.mode === 'out-in'),
            G &&
              (D.transition.afterLeave = () => {
                R === k.pendingId && (f(E, F, o === S ? g(D) : o, 0), Ws(V))
              }),
            D && (h(D.el) === F && (o = g(D)), v(D, M, k, !0)),
            G || f(E, F, o, 0)),
          Rl(k, E),
          (k.pendingBranch = null),
          (k.isInFallback = !1))
        let W = k.parent,
          te = !1
        for (; W; ) {
          if (W.pendingBranch) {
            ;(W.effects.push(...V), (te = !0))
            break
          }
          W = W.parent
        }
        ;(!te && !G && Ws(V),
          (k.effects = []),
          y &&
            t &&
            t.pendingBranch &&
            b === t.pendingId &&
            (t.deps--, t.deps === 0 && !P && t.resolve()),
          To(A, 'onResolve'))
      },
      fallback(_) {
        if (!k.pendingBranch) return
        const { vnode: P, activeBranch: A, parentComponent: D, container: E, namespace: R } = k
        To(P, 'onFallback')
        const V = g(A),
          M = () => {
            k.isInFallback && (d(null, _, E, V, D, null, R, r, s), Rl(k, _))
          },
          F = _.transition && _.transition.mode === 'out-in'
        ;(F && (A.transition.afterLeave = M), (k.isInFallback = !0), v(A, D, null, !0), F || M())
      },
      move(_, P, A) {
        ;(k.activeBranch && f(k.activeBranch, _, P, A), (k.container = _))
      },
      next() {
        return k.activeBranch && g(k.activeBranch)
      },
      registerDep(_, P, A) {
        const D = !!k.pendingBranch
        D && k.deps++
        const E = _.vnode.el
        _.asyncDep
          .catch((R) => {
            ql(R, _, 0)
          })
          .then((R) => {
            if (_.isUnmounted || k.isUnmounted || k.pendingId !== _.suspenseId) return
            _.asyncResolved = !0
            const { vnode: V } = _
            ;(eu(_, R), E && (V.el = E))
            const M = !E && _.subTree.el
            ;(P(_, V, h(E || _.subTree.el), E ? null : g(_.subTree), k, i, A),
              M && m(M),
              Vr(_, V.el),
              D && --k.deps === 0 && k.resolve())
          })
      },
      unmount(_, P) {
        ;((k.isUnmounted = !0),
          k.activeBranch && v(k.activeBranch, n, _, P),
          k.pendingBranch && v(k.pendingBranch, n, _, P))
      },
    }
  return k
}
function o0(e, t, n, a, l, o, i, r, s) {
  const c = (t.suspense = Hh(
      t,
      a,
      n,
      e.parentNode,
      document.createElement('div'),
      null,
      l,
      o,
      i,
      r,
      !0
    )),
    u = s(e, (c.pendingBranch = t.ssContent), n, c, o, i)
  return (c.deps === 0 && c.resolve(!1, !0), u)
}
function i0(e) {
  const { shapeFlag: t, children: n } = e,
    a = t & 32
  ;((e.ssContent = gf(a ? n.default : n)), (e.ssFallback = a ? gf(n.fallback) : w(mt)))
}
function gf(e) {
  let t
  if (Ee(e)) {
    const n = Bl && e._c
    ;(n && ((e._d = !1), vn()), (e = e()), n && ((e._d = !0), (t = Yt), zh()))
  }
  return (
    Te(e) && (e = Jw(e)),
    (e = nn(e)),
    t && !e.dynamicChildren && (e.dynamicChildren = t.filter((n) => n !== e)),
    e
  )
}
function jh(e, t) {
  t && t.pendingBranch ? (Te(e) ? t.effects.push(...e) : t.effects.push(e)) : Ws(e)
}
function Rl(e, t) {
  e.activeBranch = t
  const { vnode: n, parentComponent: a } = e
  let l = t.el
  for (; !l && t.component; ) ((t = t.component.subTree), (l = t.el))
  ;((n.el = l), a && a.subTree === n && ((a.vnode.el = l), Vr(a, l)))
}
function r0(e) {
  const t = e.props && e.props.suspensible
  return t != null && t !== !1
}
const he = Symbol.for('v-fgt'),
  Ca = Symbol.for('v-txt'),
  mt = Symbol.for('v-cmt'),
  Bi = Symbol.for('v-stc'),
  wo = []
let Yt = null
function vn(e = !1) {
  wo.push((Yt = e ? null : []))
}
function zh() {
  ;(wo.pop(), (Yt = wo[wo.length - 1] || null))
}
let Bl = 1
function Ji(e, t = !1) {
  ;((Bl += e), e < 0 && Yt && t && (Yt.hasOnce = !0))
}
function Wh(e) {
  return ((e.dynamicChildren = Bl > 0 ? Yt || Vl : null), zh(), Bl > 0 && Yt && Yt.push(e), e)
}
function s0(e, t, n, a, l, o) {
  return Wh(x(e, t, n, a, l, o, !0))
}
function Dn(e, t, n, a, l) {
  return Wh(w(e, t, n, a, l, !0))
}
function _a(e) {
  return e ? e.__v_isVNode === !0 : !1
}
function pn(e, t) {
  return e.type === t.type && e.key === t.key
}
const Uh = ({ key: e }) => e ?? null,
  Li = ({ ref: e, ref_key: t, ref_for: n }) => (
    typeof e == 'number' && (e = '' + e),
    e != null ? (at(e) || ct(e) || Ee(e) ? { i: At, r: e, k: t, f: !!n } : e) : null
  )
function x(e, t = null, n = null, a = 0, l = null, o = e === he ? 0 : 1, i = !1, r = !1) {
  const s = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && Uh(t),
    ref: t && Li(t),
    scopeId: ih,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: o,
    patchFlag: a,
    dynamicProps: l,
    dynamicChildren: null,
    appContext: null,
    ctx: At,
  }
  return (
    r ? (Tc(s, n), o & 128 && e.normalize(s)) : n && (s.shapeFlag |= at(n) ? 8 : 16),
    Bl > 0 && !i && Yt && (s.patchFlag > 0 || o & 6) && s.patchFlag !== 32 && Yt.push(s),
    s
  )
}
const w = u0
function u0(e, t = null, n = null, a = 0, l = null, o = !1) {
  if (((!e || e === Sh) && (e = mt), _a(e))) {
    const r = Ln(e, t, !0)
    return (
      n && Tc(r, n),
      Bl > 0 && !o && Yt && (r.shapeFlag & 6 ? (Yt[Yt.indexOf(e)] = r) : Yt.push(r)),
      (r.patchFlag = -2),
      r
    )
  }
  if ((y0(e) && (e = e.__vccOpts), t)) {
    t = Kh(t)
    let { class: r, style: s } = t
    ;(r && !at(r) && (t.class = ee(r)),
      Ze(s) && (pc(s) && !Te(s) && (s = Ct({}, s)), (t.style = ce(s))))
  }
  const i = at(e) ? 1 : Zi(e) ? 128 : sh(e) ? 64 : Ze(e) ? 4 : Ee(e) ? 2 : 0
  return x(e, t, n, a, l, i, o, !0)
}
function Kh(e) {
  return e ? (pc(e) || Th(e) ? Ct({}, e) : e) : null
}
function Ln(e, t, n = !1, a = !1) {
  const { props: l, ref: o, patchFlag: i, children: r, transition: s } = e,
    c = t ? Z(l || {}, t) : l,
    u = {
      __v_isVNode: !0,
      __v_skip: !0,
      type: e.type,
      props: c,
      key: c && Uh(c),
      ref: t && t.ref ? (n && o ? (Te(o) ? o.concat(Li(t)) : [o, Li(t)]) : Li(t)) : o,
      scopeId: e.scopeId,
      slotScopeIds: e.slotScopeIds,
      children: r,
      target: e.target,
      targetStart: e.targetStart,
      targetAnchor: e.targetAnchor,
      staticCount: e.staticCount,
      shapeFlag: e.shapeFlag,
      patchFlag: t && e.type !== he ? (i === -1 ? 16 : i | 16) : i,
      dynamicProps: e.dynamicProps,
      dynamicChildren: e.dynamicChildren,
      appContext: e.appContext,
      dirs: e.dirs,
      transition: s,
      component: e.component,
      suspense: e.suspense,
      ssContent: e.ssContent && Ln(e.ssContent),
      ssFallback: e.ssFallback && Ln(e.ssFallback),
      placeholder: e.placeholder,
      el: e.el,
      anchor: e.anchor,
      ctx: e.ctx,
      ce: e.ce,
    }
  return (s && a && xa(u, s.clone(u)), u)
}
function qt(e = ' ', t = 0) {
  return w(Ca, null, e, t)
}
function SM(e = '', t = !1) {
  return t ? (vn(), Dn(mt, null, e)) : w(mt, null, e)
}
function nn(e) {
  return e == null || typeof e == 'boolean'
    ? w(mt)
    : Te(e)
      ? w(he, null, e.slice())
      : _a(e)
        ? pa(e)
        : w(Ca, null, String(e))
}
function pa(e) {
  return (e.el === null && e.patchFlag !== -1) || e.memo ? e : Ln(e)
}
function Tc(e, t) {
  let n = 0
  const { shapeFlag: a } = e
  if (t == null) t = null
  else if (Te(t)) n = 16
  else if (typeof t == 'object')
    if (a & 65) {
      const l = t.default
      l && (l._c && (l._d = !1), Tc(e, l()), l._c && (l._d = !0))
      return
    } else {
      n = 32
      const l = t._
      !l && !Th(t)
        ? (t._ctx = At)
        : l === 3 && At && (At.slots._ === 1 ? (t._ = 1) : ((t._ = 2), (e.patchFlag |= 1024)))
    }
  else
    Ee(t)
      ? ((t = { default: t, _ctx: At }), (n = 32))
      : ((t = String(t)), a & 64 ? ((n = 16), (t = [qt(t)])) : (n = 8))
  ;((e.children = t), (e.shapeFlag |= n))
}
function Z(...e) {
  const t = {}
  for (let n = 0; n < e.length; n++) {
    const a = e[n]
    for (const l in a)
      if (l === 'class') t.class !== a.class && (t.class = ee([t.class, a.class]))
      else if (l === 'style') t.style = ce([t.style, a.style])
      else if (Xo(l)) {
        const o = t[l],
          i = a[l]
        i && o !== i && !(Te(o) && o.includes(i)) && (t[l] = o ? [].concat(o, i) : i)
      } else l !== '' && (t[l] = a[l])
  }
  return t
}
function Gt(e, t, n, a = null) {
  kn(e, t, 7, [n, a])
}
const c0 = Ph()
let d0 = 0
function f0(e, t, n) {
  const a = e.type,
    l = (t ? t.appContext : e.appContext) || c0,
    o = {
      uid: d0++,
      vnode: e,
      type: a,
      parent: t,
      appContext: l,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      job: null,
      scope: new $m(!0),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: t ? t.provides : Object.create(l.provides),
      ids: t ? t.ids : ['', 0, 0],
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: Eh(a, l),
      emitsOptions: Fh(a, l),
      emit: null,
      emitted: null,
      propsDefaults: Xe,
      inheritAttrs: a.inheritAttrs,
      ctx: Xe,
      data: Xe,
      props: Xe,
      attrs: Xe,
      slots: Xe,
      refs: Xe,
      setupState: Xe,
      setupContext: null,
      suspense: n,
      suspenseId: n ? n.pendingId : 0,
      asyncDep: null,
      asyncResolved: !1,
      isMounted: !1,
      isUnmounted: !1,
      isDeactivated: !1,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null,
    }
  return (
    (o.ctx = { _: o }),
    (o.root = t ? t.root : o),
    (o.emit = Xw.bind(null, o)),
    e.ce && e.ce(o),
    o
  )
}
let Tt = null
const jn = () => Tt || At
let Qi, Js
{
  const e = Sr(),
    t = (n, a) => {
      let l
      return (
        (l = e[n]) || (l = e[n] = []),
        l.push(a),
        (o) => {
          l.length > 1 ? l.forEach((i) => i(o)) : l[0](o)
        }
      )
    }
  ;((Qi = t('__VUE_INSTANCE_SETTERS__', (n) => (Tt = n))),
    (Js = t('__VUE_SSR_SETTERS__', (n) => (Ll = n))))
}
const Xa = (e) => {
    const t = Tt
    return (
      Qi(e),
      e.scope.on(),
      () => {
        ;(e.scope.off(), Qi(t))
      }
    )
  },
  Qs = () => {
    ;(Tt && Tt.scope.off(), Qi(null))
  }
function Gh(e) {
  return e.vnode.shapeFlag & 4
}
let Ll = !1
function v0(e, t = !1, n = !1) {
  t && Js(t)
  const { props: a, children: l } = e.vnode,
    o = Gh(e)
  ;(Ow(e, a, o, t), Hw(e, l, n || t))
  const i = o ? m0(e, t) : void 0
  return (t && Js(!1), i)
}
function m0(e, t) {
  const n = e.type
  ;((e.accessCache = Object.create(null)), (e.proxy = new Proxy(e.ctx, Tw)))
  const { setup: a } = n
  if (a) {
    ta()
    const l = (e.setupContext = a.length > 1 ? g0(e) : null),
      o = Xa(e),
      i = Jo(a, e, 0, [e.props, l]),
      r = cc(i)
    if ((na(), o(), (r || e.sp) && !ka(e) && kc(e), r)) {
      if ((i.then(Qs, Qs), t))
        return i
          .then((s) => {
            eu(e, s)
          })
          .catch((s) => {
            ql(s, e, 0)
          })
      e.asyncDep = i
    } else eu(e, i)
  } else Yh(e)
}
function eu(e, t, n) {
  ;(Ee(t)
    ? e.type.__ssrInlineRender
      ? (e.ssrRender = t)
      : (e.render = t)
    : Ze(t) && (e.setupState = th(t)),
    Yh(e))
}
function Yh(e, t, n) {
  const a = e.type
  e.render || (e.render = a.render || Rn)
  {
    const l = Xa(e)
    ta()
    try {
      Aw(e)
    } finally {
      ;(na(), l())
    }
  }
}
const h0 = {
  get(e, t) {
    return (Lt(e, 'get', ''), e[t])
  },
}
function g0(e) {
  const t = (n) => {
    e.exposed = n || {}
  }
  return { attrs: new Proxy(e.attrs, h0), slots: e.slots, emit: e.emit, expose: t }
}
function Ir(e) {
  return e.exposed
    ? e.exposeProxy ||
        (e.exposeProxy = new Proxy(th(Qm(e.exposed)), {
          get(t, n) {
            if (n in t) return t[n]
            if (n in So) return So[n](e)
          },
          has(t, n) {
            return n in t || n in So
          },
        }))
    : e.proxy
}
function tu(e, t = !0) {
  return Ee(e) ? e.displayName || e.name : e.name || (t && e.__name)
}
function y0(e) {
  return Ee(e) && '__vccOpts' in e
}
const C = (e, t) => sw(e, t, Ll)
function ut(e, t, n) {
  try {
    Ji(-1)
    const a = arguments.length
    return a === 2
      ? Ze(t) && !Te(t)
        ? _a(t)
          ? w(e, null, [t])
          : w(e, t)
        : w(e, null, t)
      : (a > 3 ? (n = Array.prototype.slice.call(arguments, 2)) : a === 3 && _a(n) && (n = [n]),
        w(e, t, n))
  } finally {
    Ji(1)
  }
}
const b0 = '3.5.22'
/**
 * @vue/runtime-dom v3.5.22
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ let nu
const yf = typeof window < 'u' && window.trustedTypes
if (yf)
  try {
    nu = yf.createPolicy('vue', { createHTML: (e) => e })
  } catch {}
const qh = nu ? (e) => nu.createHTML(e) : (e) => e,
  p0 = 'http://www.w3.org/2000/svg',
  S0 = 'http://www.w3.org/1998/Math/MathML',
  qn = typeof document < 'u' ? document : null,
  bf = qn && qn.createElement('template'),
  w0 = {
    insert: (e, t, n) => {
      t.insertBefore(e, n || null)
    },
    remove: (e) => {
      const t = e.parentNode
      t && t.removeChild(e)
    },
    createElement: (e, t, n, a) => {
      const l =
        t === 'svg'
          ? qn.createElementNS(p0, e)
          : t === 'mathml'
            ? qn.createElementNS(S0, e)
            : n
              ? qn.createElement(e, { is: n })
              : qn.createElement(e)
      return (
        e === 'select' && a && a.multiple != null && l.setAttribute('multiple', a.multiple),
        l
      )
    },
    createText: (e) => qn.createTextNode(e),
    createComment: (e) => qn.createComment(e),
    setText: (e, t) => {
      e.nodeValue = t
    },
    setElementText: (e, t) => {
      e.textContent = t
    },
    parentNode: (e) => e.parentNode,
    nextSibling: (e) => e.nextSibling,
    querySelector: (e) => qn.querySelector(e),
    setScopeId(e, t) {
      e.setAttribute(t, '')
    },
    insertStaticContent(e, t, n, a, l, o) {
      const i = n ? n.previousSibling : t.lastChild
      if (l && (l === o || l.nextSibling))
        for (; t.insertBefore(l.cloneNode(!0), n), !(l === o || !(l = l.nextSibling)); );
      else {
        bf.innerHTML = qh(
          a === 'svg' ? `<svg>${e}</svg>` : a === 'mathml' ? `<math>${e}</math>` : e
        )
        const r = bf.content
        if (a === 'svg' || a === 'mathml') {
          const s = r.firstChild
          for (; s.firstChild; ) r.appendChild(s.firstChild)
          r.removeChild(s)
        }
        t.insertBefore(r, n)
      }
      return [i ? i.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
    },
  },
  ha = 'transition',
  so = 'animation',
  Ol = Symbol('_vtc'),
  Xh = {
    name: String,
    type: String,
    css: { type: Boolean, default: !0 },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String,
  },
  Zh = Ct({}, fh, Xh),
  k0 = (e) => ((e.displayName = 'Transition'), (e.props = Zh), e),
  la = k0((e, { slots: t }) => ut(gw, Jh(e), t)),
  Da = (e, t = []) => {
    Te(e) ? e.forEach((n) => n(...t)) : e && e(...t)
  },
  pf = (e) => (e ? (Te(e) ? e.some((t) => t.length > 1) : e.length > 1) : !1)
function Jh(e) {
  const t = {}
  for (const V in e) V in Xh || (t[V] = e[V])
  if (e.css === !1) return t
  const {
      name: n = 'v',
      type: a,
      duration: l,
      enterFromClass: o = `${n}-enter-from`,
      enterActiveClass: i = `${n}-enter-active`,
      enterToClass: r = `${n}-enter-to`,
      appearFromClass: s = o,
      appearActiveClass: c = i,
      appearToClass: u = r,
      leaveFromClass: d = `${n}-leave-from`,
      leaveActiveClass: f = `${n}-leave-active`,
      leaveToClass: v = `${n}-leave-to`,
    } = e,
    g = C0(l),
    h = g && g[0],
    m = g && g[1],
    {
      onBeforeEnter: b,
      onEnter: y,
      onEnterCancelled: p,
      onLeave: S,
      onLeaveCancelled: k,
      onBeforeAppear: _ = b,
      onAppear: P = y,
      onAppearCancelled: A = p,
    } = t,
    D = (V, M, F, G) => {
      ;((V._enterCancelled = G), ya(V, M ? u : r), ya(V, M ? c : i), F && F())
    },
    E = (V, M) => {
      ;((V._isLeaving = !1), ya(V, d), ya(V, v), ya(V, f), M && M())
    },
    R = (V) => (M, F) => {
      const G = V ? P : y,
        W = () => D(M, V, F)
      ;(Da(G, [M, W]),
        Sf(() => {
          ;(ya(M, V ? s : o), Tn(M, V ? u : r), pf(G) || wf(M, a, h, W))
        }))
    }
  return Ct(t, {
    onBeforeEnter(V) {
      ;(Da(b, [V]), Tn(V, o), Tn(V, i))
    },
    onBeforeAppear(V) {
      ;(Da(_, [V]), Tn(V, s), Tn(V, c))
    },
    onEnter: R(!1),
    onAppear: R(!0),
    onLeave(V, M) {
      V._isLeaving = !0
      const F = () => E(V, M)
      ;(Tn(V, d),
        V._enterCancelled ? (Tn(V, f), au(V)) : (au(V), Tn(V, f)),
        Sf(() => {
          V._isLeaving && (ya(V, d), Tn(V, v), pf(S) || wf(V, a, m, F))
        }),
        Da(S, [V, F]))
    },
    onEnterCancelled(V) {
      ;(D(V, !1, void 0, !0), Da(p, [V]))
    },
    onAppearCancelled(V) {
      ;(D(V, !0, void 0, !0), Da(A, [V]))
    },
    onLeaveCancelled(V) {
      ;(E(V), Da(k, [V]))
    },
  })
}
function C0(e) {
  if (e == null) return null
  if (Ze(e)) return [gs(e.enter), gs(e.leave)]
  {
    const t = gs(e)
    return [t, t]
  }
}
function gs(e) {
  return Mm(e)
}
function Tn(e, t) {
  ;(t.split(/\s+/).forEach((n) => n && e.classList.add(n)), (e[Ol] || (e[Ol] = new Set())).add(t))
}
function ya(e, t) {
  t.split(/\s+/).forEach((a) => a && e.classList.remove(a))
  const n = e[Ol]
  n && (n.delete(t), n.size || (e[Ol] = void 0))
}
function Sf(e) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e)
  })
}
let x0 = 0
function wf(e, t, n, a) {
  const l = (e._endId = ++x0),
    o = () => {
      l === e._endId && a()
    }
  if (n != null) return setTimeout(o, n)
  const { type: i, timeout: r, propCount: s } = Qh(e, t)
  if (!i) return a()
  const c = i + 'end'
  let u = 0
  const d = () => {
      ;(e.removeEventListener(c, f), o())
    },
    f = (v) => {
      v.target === e && ++u >= s && d()
    }
  ;(setTimeout(() => {
    u < s && d()
  }, r + 1),
    e.addEventListener(c, f))
}
function Qh(e, t) {
  const n = window.getComputedStyle(e),
    a = (g) => (n[g] || '').split(', '),
    l = a(`${ha}Delay`),
    o = a(`${ha}Duration`),
    i = kf(l, o),
    r = a(`${so}Delay`),
    s = a(`${so}Duration`),
    c = kf(r, s)
  let u = null,
    d = 0,
    f = 0
  t === ha
    ? i > 0 && ((u = ha), (d = i), (f = o.length))
    : t === so
      ? c > 0 && ((u = so), (d = c), (f = s.length))
      : ((d = Math.max(i, c)),
        (u = d > 0 ? (i > c ? ha : so) : null),
        (f = u ? (u === ha ? o.length : s.length) : 0))
  const v = u === ha && /\b(?:transform|all)(?:,|$)/.test(a(`${ha}Property`).toString())
  return { type: u, timeout: d, propCount: f, hasTransform: v }
}
function kf(e, t) {
  for (; e.length < t.length; ) e = e.concat(e)
  return Math.max(...t.map((n, a) => Cf(n) + Cf(e[a])))
}
function Cf(e) {
  return e === 'auto' ? 0 : Number(e.slice(0, -1).replace(',', '.')) * 1e3
}
function au(e) {
  return (e ? e.ownerDocument : document).body.offsetHeight
}
function _0(e, t, n) {
  const a = e[Ol]
  ;(a && (t = (t ? [t, ...a] : [...a]).join(' ')),
    t == null ? e.removeAttribute('class') : n ? e.setAttribute('class', t) : (e.className = t))
}
const er = Symbol('_vod'),
  eg = Symbol('_vsh'),
  Pn = {
    name: 'show',
    beforeMount(e, { value: t }, { transition: n }) {
      ;((e[er] = e.style.display === 'none' ? '' : e.style.display),
        n && t ? n.beforeEnter(e) : uo(e, t))
    },
    mounted(e, { value: t }, { transition: n }) {
      n && t && n.enter(e)
    },
    updated(e, { value: t, oldValue: n }, { transition: a }) {
      !t != !n &&
        (a
          ? t
            ? (a.beforeEnter(e), uo(e, !0), a.enter(e))
            : a.leave(e, () => {
                uo(e, !1)
              })
          : uo(e, t))
    },
    beforeUnmount(e, { value: t }) {
      uo(e, t)
    },
  }
function uo(e, t) {
  ;((e.style.display = t ? e[er] : 'none'), (e[eg] = !t))
}
const P0 = Symbol(''),
  V0 = /(?:^|;)\s*display\s*:/
function I0(e, t, n) {
  const a = e.style,
    l = at(n)
  let o = !1
  if (n && !l) {
    if (t)
      if (at(t))
        for (const i of t.split(';')) {
          const r = i.slice(0, i.indexOf(':')).trim()
          n[r] == null && Oi(a, r, '')
        }
      else for (const i in t) n[i] == null && Oi(a, i, '')
    for (const i in n) (i === 'display' && (o = !0), Oi(a, i, n[i]))
  } else if (l) {
    if (t !== n) {
      const i = a[P0]
      ;(i && (n += ';' + i), (a.cssText = n), (o = V0.test(n)))
    }
  } else t && e.removeAttribute('style')
  er in e && ((e[er] = o ? a.display : ''), e[eg] && (a.display = 'none'))
}
const xf = /\s*!important$/
function Oi(e, t, n) {
  if (Te(n)) n.forEach((a) => Oi(e, t, a))
  else if ((n == null && (n = ''), t.startsWith('--'))) e.setProperty(t, n)
  else {
    const a = T0(e, t)
    xf.test(n) ? e.setProperty(ll(a), n.replace(xf, ''), 'important') : (e[a] = n)
  }
}
const _f = ['Webkit', 'Moz', 'ms'],
  ys = {}
function T0(e, t) {
  const n = ys[t]
  if (n) return n
  let a = Wt(t)
  if (a !== 'filter' && a in e) return (ys[t] = a)
  a = Hn(a)
  for (let l = 0; l < _f.length; l++) {
    const o = _f[l] + a
    if (o in e) return (ys[t] = o)
  }
  return t
}
const Pf = 'http://www.w3.org/1999/xlink'
function Vf(e, t, n, a, l, o = OS(t)) {
  a && t.startsWith('xlink:')
    ? n == null
      ? e.removeAttributeNS(Pf, t.slice(6, t.length))
      : e.setAttributeNS(Pf, t, n)
    : n == null || (o && !Bm(n))
      ? e.removeAttribute(t)
      : e.setAttribute(t, o ? '' : ra(n) ? String(n) : n)
}
function If(e, t, n, a, l) {
  if (t === 'innerHTML' || t === 'textContent') {
    n != null && (e[t] = t === 'innerHTML' ? qh(n) : n)
    return
  }
  const o = e.tagName
  if (t === 'value' && o !== 'PROGRESS' && !o.includes('-')) {
    const r = o === 'OPTION' ? e.getAttribute('value') || '' : e.value,
      s = n == null ? (e.type === 'checkbox' ? 'on' : '') : String(n)
    ;((r !== s || !('_value' in e)) && (e.value = s),
      n == null && e.removeAttribute(t),
      (e._value = n))
    return
  }
  let i = !1
  if (n === '' || n == null) {
    const r = typeof e[t]
    r === 'boolean'
      ? (n = Bm(n))
      : n == null && r === 'string'
        ? ((n = ''), (i = !0))
        : r === 'number' && ((n = 0), (i = !0))
  }
  try {
    e[t] = n
  } catch {}
  i && e.removeAttribute(l || t)
}
function kl(e, t, n, a) {
  e.addEventListener(t, n, a)
}
function A0(e, t, n, a) {
  e.removeEventListener(t, n, a)
}
const Tf = Symbol('_vei')
function E0(e, t, n, a, l = null) {
  const o = e[Tf] || (e[Tf] = {}),
    i = o[t]
  if (a && i) i.value = a
  else {
    const [r, s] = D0(t)
    if (a) {
      const c = (o[t] = B0(a, l))
      kl(e, r, c, s)
    } else i && (A0(e, r, i, s), (o[t] = void 0))
  }
}
const Af = /(?:Once|Passive|Capture)$/
function D0(e) {
  let t
  if (Af.test(e)) {
    t = {}
    let a
    for (; (a = e.match(Af)); )
      ((e = e.slice(0, e.length - a[0].length)), (t[a[0].toLowerCase()] = !0))
  }
  return [e[2] === ':' ? e.slice(3) : ll(e.slice(2)), t]
}
let bs = 0
const R0 = Promise.resolve(),
  M0 = () => bs || (R0.then(() => (bs = 0)), (bs = Date.now()))
function B0(e, t) {
  const n = (a) => {
    if (!a._vts) a._vts = Date.now()
    else if (a._vts <= n.attached) return
    kn(L0(a, n.value), t, 5, [a])
  }
  return ((n.value = e), (n.attached = M0()), n)
}
function L0(e, t) {
  if (Te(t)) {
    const n = e.stopImmediatePropagation
    return (
      (e.stopImmediatePropagation = () => {
        ;(n.call(e), (e._stopped = !0))
      }),
      t.map((a) => (l) => !l._stopped && a && a(l))
    )
  } else return t
}
const Ef = (e) =>
    e.charCodeAt(0) === 111 &&
    e.charCodeAt(1) === 110 &&
    e.charCodeAt(2) > 96 &&
    e.charCodeAt(2) < 123,
  O0 = (e, t, n, a, l, o) => {
    const i = l === 'svg'
    t === 'class'
      ? _0(e, a, i)
      : t === 'style'
        ? I0(e, n, a)
        : Xo(t)
          ? sc(t) || E0(e, t, n, a, o)
          : (
                t[0] === '.'
                  ? ((t = t.slice(1)), !0)
                  : t[0] === '^'
                    ? ((t = t.slice(1)), !1)
                    : $0(e, t, a, i)
              )
            ? (If(e, t, a),
              !e.tagName.includes('-') &&
                (t === 'value' || t === 'checked' || t === 'selected') &&
                Vf(e, t, a, i, o, t !== 'value'))
            : e._isVueCE && (/[A-Z]/.test(t) || !at(a))
              ? If(e, Wt(t), a, o, t)
              : (t === 'true-value'
                  ? (e._trueValue = a)
                  : t === 'false-value' && (e._falseValue = a),
                Vf(e, t, a, i))
  }
function $0(e, t, n, a) {
  if (a) return !!(t === 'innerHTML' || t === 'textContent' || (t in e && Ef(t) && Ee(n)))
  if (
    t === 'spellcheck' ||
    t === 'draggable' ||
    t === 'translate' ||
    t === 'autocorrect' ||
    t === 'form' ||
    (t === 'list' && e.tagName === 'INPUT') ||
    (t === 'type' && e.tagName === 'TEXTAREA')
  )
    return !1
  if (t === 'width' || t === 'height') {
    const l = e.tagName
    if (l === 'IMG' || l === 'VIDEO' || l === 'CANVAS' || l === 'SOURCE') return !1
  }
  return Ef(t) && at(n) ? !1 : t in e
}
const tg = new WeakMap(),
  ng = new WeakMap(),
  tr = Symbol('_moveCb'),
  Df = Symbol('_enterCb'),
  F0 = (e) => (delete e.props.mode, e),
  N0 = F0({
    name: 'TransitionGroup',
    props: Ct({}, Zh, { tag: String, moveClass: String }),
    setup(e, { slots: t }) {
      const n = jn(),
        a = dh()
      let l, o
      return (
        xr(() => {
          if (!l.length) return
          const i = e.moveClass || `${e.name || 'v'}-move`
          if (!W0(l[0].el, n.vnode.el, i)) {
            l = []
            return
          }
          ;(l.forEach(H0), l.forEach(j0))
          const r = l.filter(z0)
          ;(au(n.vnode.el),
            r.forEach((s) => {
              const c = s.el,
                u = c.style
              ;(Tn(c, i), (u.transform = u.webkitTransform = u.transitionDuration = ''))
              const d = (c[tr] = (f) => {
                ;(f && f.target !== c) ||
                  ((!f || f.propertyName.endsWith('transform')) &&
                    (c.removeEventListener('transitionend', d), (c[tr] = null), ya(c, i)))
              })
              c.addEventListener('transitionend', d)
            }),
            (l = []))
        }),
        () => {
          const i = _e(e),
            r = Jh(i)
          let s = i.tag || he
          if (((l = []), o))
            for (let c = 0; c < o.length; c++) {
              const u = o[c]
              u.el &&
                u.el instanceof Element &&
                (l.push(u), xa(u, Io(u, r, a, n)), tg.set(u, u.el.getBoundingClientRect()))
            }
          o = t.default ? wc(t.default()) : []
          for (let c = 0; c < o.length; c++) {
            const u = o[c]
            u.key != null && xa(u, Io(u, r, a, n))
          }
          return w(s, null, o)
        }
      )
    },
  }),
  Ac = N0
function H0(e) {
  const t = e.el
  ;(t[tr] && t[tr](), t[Df] && t[Df]())
}
function j0(e) {
  ng.set(e, e.el.getBoundingClientRect())
}
function z0(e) {
  const t = tg.get(e),
    n = ng.get(e),
    a = t.left - n.left,
    l = t.top - n.top
  if (a || l) {
    const o = e.el.style
    return (
      (o.transform = o.webkitTransform = `translate(${a}px,${l}px)`),
      (o.transitionDuration = '0s'),
      e
    )
  }
}
function W0(e, t, n) {
  const a = e.cloneNode(),
    l = e[Ol]
  ;(l &&
    l.forEach((r) => {
      r.split(/\s+/).forEach((s) => s && a.classList.remove(s))
    }),
    n.split(/\s+/).forEach((r) => r && a.classList.add(r)),
    (a.style.display = 'none'))
  const o = t.nodeType === 1 ? t : t.parentNode
  o.appendChild(a)
  const { hasTransform: i } = Qh(a)
  return (o.removeChild(a), i)
}
const Rf = (e) => {
  const t = e.props['onUpdate:modelValue'] || !1
  return Te(t) ? (n) => Al(t, n) : t
}
function U0(e) {
  e.target.composing = !0
}
function Mf(e) {
  const t = e.target
  t.composing && ((t.composing = !1), t.dispatchEvent(new Event('input')))
}
const ps = Symbol('_assign'),
  K0 = {
    created(e, { modifiers: { lazy: t, trim: n, number: a } }, l) {
      e[ps] = Rf(l)
      const o = a || (l.props && l.props.type === 'number')
      ;(kl(e, t ? 'change' : 'input', (i) => {
        if (i.target.composing) return
        let r = e.value
        ;(n && (r = r.trim()), o && (r = Ns(r)), e[ps](r))
      }),
        n &&
          kl(e, 'change', () => {
            e.value = e.value.trim()
          }),
        t || (kl(e, 'compositionstart', U0), kl(e, 'compositionend', Mf), kl(e, 'change', Mf)))
    },
    mounted(e, { value: t }) {
      e.value = t ?? ''
    },
    beforeUpdate(e, { value: t, oldValue: n, modifiers: { lazy: a, trim: l, number: o } }, i) {
      if (((e[ps] = Rf(i)), e.composing)) return
      const r = (o || e.type === 'number') && !/^0\d/.test(e.value) ? Ns(e.value) : e.value,
        s = t ?? ''
      r !== s &&
        ((document.activeElement === e &&
          e.type !== 'range' &&
          ((a && t === n) || (l && e.value.trim() === s))) ||
          (e.value = s))
    },
  },
  G0 = ['ctrl', 'shift', 'alt', 'meta'],
  Y0 = {
    stop: (e) => e.stopPropagation(),
    prevent: (e) => e.preventDefault(),
    self: (e) => e.target !== e.currentTarget,
    ctrl: (e) => !e.ctrlKey,
    shift: (e) => !e.shiftKey,
    alt: (e) => !e.altKey,
    meta: (e) => !e.metaKey,
    left: (e) => 'button' in e && e.button !== 0,
    middle: (e) => 'button' in e && e.button !== 1,
    right: (e) => 'button' in e && e.button !== 2,
    exact: (e, t) => G0.some((n) => e[`${n}Key`] && !t.includes(n)),
  },
  ki = (e, t) => {
    const n = e._withMods || (e._withMods = {}),
      a = t.join('.')
    return (
      n[a] ||
      (n[a] = (l, ...o) => {
        for (let i = 0; i < t.length; i++) {
          const r = Y0[t[i]]
          if (r && r(l, t)) return
        }
        return e(l, ...o)
      })
    )
  },
  ag = Ct({ patchProp: O0 }, w0)
let ko,
  Bf = !1
function lg() {
  return ko || (ko = zw(ag))
}
function q0() {
  return ((ko = Bf ? ko : Ww(ag)), (Bf = !0), ko)
}
const og = (...e) => {
    lg().render(...e)
  },
  X0 = (...e) => {
    const t = lg().createApp(...e),
      { mount: n } = t
    return (
      (t.mount = (a) => {
        const l = rg(a)
        if (!l) return
        const o = t._component
        ;(!Ee(o) && !o.render && !o.template && (o.template = l.innerHTML),
          l.nodeType === 1 && (l.textContent = ''))
        const i = n(l, !1, ig(l))
        return (
          l instanceof Element && (l.removeAttribute('v-cloak'), l.setAttribute('data-v-app', '')),
          i
        )
      }),
      t
    )
  },
  Z0 = (...e) => {
    const t = q0().createApp(...e),
      { mount: n } = t
    return (
      (t.mount = (a) => {
        const l = rg(a)
        if (l) return n(l, !0, ig(l))
      }),
      t
    )
  }
function ig(e) {
  if (e instanceof SVGElement) return 'svg'
  if (typeof MathMLElement == 'function' && e instanceof MathMLElement) return 'mathml'
}
function rg(e) {
  return at(e) ? document.querySelector(e) : e
}
const J0 =
    /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
  Q0 =
    /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
  ek = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/
function tk(e, t) {
  if (e === '__proto__' || (e === 'constructor' && t && typeof t == 'object' && 'prototype' in t)) {
    nk(e)
    return
  }
  return t
}
function nk(e) {
  console.warn(`[destr] Dropping "${e}" key to prevent prototype pollution.`)
}
function nr(e, t = {}) {
  if (typeof e != 'string') return e
  if (e[0] === '"' && e[e.length - 1] === '"' && e.indexOf('\\') === -1) return e.slice(1, -1)
  const n = e.trim()
  if (n.length <= 9)
    switch (n.toLowerCase()) {
      case 'true':
        return !0
      case 'false':
        return !1
      case 'undefined':
        return
      case 'null':
        return null
      case 'nan':
        return Number.NaN
      case 'infinity':
        return Number.POSITIVE_INFINITY
      case '-infinity':
        return Number.NEGATIVE_INFINITY
    }
  if (!ek.test(e)) {
    if (t.strict) throw new SyntaxError('[destr] Invalid JSON')
    return e
  }
  try {
    if (J0.test(e) || Q0.test(e)) {
      if (t.strict) throw new Error('[destr] Possible prototype pollution')
      return JSON.parse(e, tk)
    }
    return JSON.parse(e)
  } catch (a) {
    if (t.strict) throw a
    return e
  }
}
const ak = /#/g,
  lk = /&/g,
  ok = /\//g,
  ik = /=/g,
  Ec = /\+/g,
  rk = /%5e/gi,
  sk = /%60/gi,
  uk = /%7c/gi,
  ck = /%20/gi
function dk(e) {
  return encodeURI('' + e).replace(uk, '|')
}
function lu(e) {
  return dk(typeof e == 'string' ? e : JSON.stringify(e))
    .replace(Ec, '%2B')
    .replace(ck, '+')
    .replace(ak, '%23')
    .replace(lk, '%26')
    .replace(sk, '`')
    .replace(rk, '^')
    .replace(ok, '%2F')
}
function Ss(e) {
  return lu(e).replace(ik, '%3D')
}
function ar(e = '') {
  try {
    return decodeURIComponent('' + e)
  } catch {
    return '' + e
  }
}
function fk(e) {
  return ar(e.replace(Ec, ' '))
}
function vk(e) {
  return ar(e.replace(Ec, ' '))
}
function Dc(e = '') {
  const t = Object.create(null)
  e[0] === '?' && (e = e.slice(1))
  for (const n of e.split('&')) {
    const a = n.match(/([^=]+)=?(.*)/) || []
    if (a.length < 2) continue
    const l = fk(a[1])
    if (l === '__proto__' || l === 'constructor') continue
    const o = vk(a[2] || '')
    t[l] === void 0 ? (t[l] = o) : Array.isArray(t[l]) ? t[l].push(o) : (t[l] = [t[l], o])
  }
  return t
}
function mk(e, t) {
  return (
    (typeof t == 'number' || typeof t == 'boolean') && (t = String(t)),
    t
      ? Array.isArray(t)
        ? t.map((n) => `${Ss(e)}=${lu(n)}`).join('&')
        : `${Ss(e)}=${lu(t)}`
      : Ss(e)
  )
}
function hk(e) {
  return Object.keys(e)
    .filter((t) => e[t] !== void 0)
    .map((t) => mk(t, e[t]))
    .filter(Boolean)
    .join('&')
}
const gk = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/,
  yk = /^[\s\w\0+.-]{2,}:([/\\]{2})?/,
  bk = /^([/\\]\s*){2,}[^/\\]/,
  pk = /^[\s\0]*(blob|data|javascript|vbscript):$/i,
  Sk = /\/$|\/\?|\/#/,
  wk = /^\.?\//
function ca(e, t = {}) {
  return (
    typeof t == 'boolean' && (t = { acceptRelative: t }),
    t.strict ? gk.test(e) : yk.test(e) || (t.acceptRelative ? bk.test(e) : !1)
  )
}
function kk(e) {
  return !!e && pk.test(e)
}
function ou(e = '', t) {
  return t ? Sk.test(e) : e.endsWith('/')
}
function $l(e = '', t) {
  if (!t) return (ou(e) ? e.slice(0, -1) : e) || '/'
  if (!ou(e, !0)) return e || '/'
  let n = e,
    a = ''
  const l = e.indexOf('#')
  l !== -1 && ((n = e.slice(0, l)), (a = e.slice(l)))
  const [o, ...i] = n.split('?')
  return (
    ((o.endsWith('/') ? o.slice(0, -1) : o) || '/') + (i.length > 0 ? `?${i.join('?')}` : '') + a
  )
}
function sg(e = '', t) {
  if (!t) return e.endsWith('/') ? e : e + '/'
  if (ou(e, !0)) return e || '/'
  let n = e,
    a = ''
  const l = e.indexOf('#')
  if (l !== -1 && ((n = e.slice(0, l)), (a = e.slice(l)), !n)) return a
  const [o, ...i] = n.split('?')
  return o + '/' + (i.length > 0 ? `?${i.join('?')}` : '') + a
}
function Ck(e, t) {
  if (cg(t) || ca(e)) return e
  const n = $l(t)
  return e.startsWith(n) ? e : Tr(n, e)
}
function Lf(e, t) {
  if (cg(t)) return e
  const n = $l(t)
  if (!e.startsWith(n)) return e
  const a = e.slice(n.length)
  return a[0] === '/' ? a : '/' + a
}
function ug(e, t) {
  const n = vg(e),
    a = { ...Dc(n.search), ...t }
  return ((n.search = hk(a)), Pk(n))
}
function cg(e) {
  return !e || e === '/'
}
function xk(e) {
  return e && e !== '/'
}
function Tr(e, ...t) {
  let n = e || ''
  for (const a of t.filter((l) => xk(l)))
    if (n) {
      const l = a.replace(wk, '')
      n = sg(n) + l
    } else n = a
  return n
}
function dg(...e) {
  const t = /\/(?!\/)/,
    n = e.filter(Boolean),
    a = []
  let l = 0
  for (const i of n)
    if (!(!i || i === '/')) {
      for (const [r, s] of i.split(t).entries())
        if (!(!s || s === '.')) {
          if (s === '..') {
            if (a.length === 1 && ca(a[0])) continue
            ;(a.pop(), l--)
            continue
          }
          if (r === 1 && a[a.length - 1]?.endsWith(':/')) {
            a[a.length - 1] += '/' + s
            continue
          }
          ;(a.push(s), l++)
        }
    }
  let o = a.join('/')
  return (
    l >= 0
      ? n[0]?.startsWith('/') && !o.startsWith('/')
        ? (o = '/' + o)
        : n[0]?.startsWith('./') && !o.startsWith('./') && (o = './' + o)
      : (o = '../'.repeat(-1 * l) + o),
    n[n.length - 1]?.endsWith('/') && !o.endsWith('/') && (o += '/'),
    o
  )
}
function _k(e, t) {
  return ar($l(e)) === ar($l(t))
}
const fg = Symbol.for('ufo:protocolRelative')
function vg(e = '', t) {
  const n = e.match(/^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i)
  if (n) {
    const [, d, f = ''] = n
    return {
      protocol: d.toLowerCase(),
      pathname: f,
      href: d + f,
      auth: '',
      host: '',
      search: '',
      hash: '',
    }
  }
  if (!ca(e, { acceptRelative: !0 })) return Of(e)
  const [, a = '', l, o = ''] =
    e.replace(/\\/g, '/').match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || []
  let [, i = '', r = ''] = o.match(/([^#/?]*)(.*)?/) || []
  a === 'file:' && (r = r.replace(/\/(?=[A-Za-z]:)/, ''))
  const { pathname: s, search: c, hash: u } = Of(r)
  return {
    protocol: a.toLowerCase(),
    auth: l ? l.slice(0, Math.max(0, l.length - 1)) : '',
    host: i,
    pathname: s,
    search: c,
    hash: u,
    [fg]: !a,
  }
}
function Of(e = '') {
  const [t = '', n = '', a = ''] = (e.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1)
  return { pathname: t, search: n, hash: a }
}
function Pk(e) {
  const t = e.pathname || '',
    n = e.search ? (e.search.startsWith('?') ? '' : '?') + e.search : '',
    a = e.hash || '',
    l = e.auth ? e.auth + '@' : '',
    o = e.host || ''
  return (e.protocol || e[fg] ? (e.protocol || '') + '//' : '') + l + o + t + n + a
}
class Vk extends Error {
  constructor(t, n) {
    ;(super(t, n), (this.name = 'FetchError'), n?.cause && !this.cause && (this.cause = n.cause))
  }
}
function Ik(e) {
  const t = e.error?.message || e.error?.toString() || '',
    n = e.request?.method || e.options?.method || 'GET',
    a = e.request?.url || String(e.request) || '/',
    l = `[${n}] ${JSON.stringify(a)}`,
    o = e.response ? `${e.response.status} ${e.response.statusText}` : '<no response>',
    i = `${l}: ${o}${t ? ` ${t}` : ''}`,
    r = new Vk(i, e.error ? { cause: e.error } : void 0)
  for (const s of ['request', 'options', 'response'])
    Object.defineProperty(r, s, {
      get() {
        return e[s]
      },
    })
  for (const [s, c] of [
    ['data', '_data'],
    ['status', 'status'],
    ['statusCode', 'status'],
    ['statusText', 'statusText'],
    ['statusMessage', 'statusText'],
  ])
    Object.defineProperty(r, s, {
      get() {
        return e.response && e.response[c]
      },
    })
  return r
}
const Tk = new Set(Object.freeze(['PATCH', 'POST', 'PUT', 'DELETE']))
function $f(e = 'GET') {
  return Tk.has(e.toUpperCase())
}
function Ak(e) {
  if (e === void 0) return !1
  const t = typeof e
  return t === 'string' || t === 'number' || t === 'boolean' || t === null
    ? !0
    : t !== 'object'
      ? !1
      : Array.isArray(e)
        ? !0
        : e.buffer
          ? !1
          : (e.constructor && e.constructor.name === 'Object') || typeof e.toJSON == 'function'
}
const Ek = new Set(['image/svg', 'application/xml', 'application/xhtml', 'application/html']),
  Dk = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i
function Rk(e = '') {
  if (!e) return 'json'
  const t = e.split(';').shift() || ''
  return Dk.test(t) ? 'json' : Ek.has(t) || t.startsWith('text/') ? 'text' : 'blob'
}
function Mk(e, t, n, a) {
  const l = Bk(t?.headers ?? e?.headers, n?.headers, a)
  let o
  return (
    (n?.query || n?.params || t?.params || t?.query) &&
      (o = { ...n?.params, ...n?.query, ...t?.params, ...t?.query }),
    { ...n, ...t, query: o, params: o, headers: l }
  )
}
function Bk(e, t, n) {
  if (!t) return new n(e)
  const a = new n(t)
  if (e) for (const [l, o] of Symbol.iterator in e || Array.isArray(e) ? e : new n(e)) a.set(l, o)
  return a
}
async function Ci(e, t) {
  if (t)
    if (Array.isArray(t)) for (const n of t) await n(e)
    else await t(e)
}
const Lk = new Set([408, 409, 425, 429, 500, 502, 503, 504]),
  Ok = new Set([101, 204, 205, 304])
function mg(e = {}) {
  const {
    fetch: t = globalThis.fetch,
    Headers: n = globalThis.Headers,
    AbortController: a = globalThis.AbortController,
  } = e
  async function l(r) {
    const s = (r.error && r.error.name === 'AbortError' && !r.options.timeout) || !1
    if (r.options.retry !== !1 && !s) {
      let u
      typeof r.options.retry == 'number'
        ? (u = r.options.retry)
        : (u = $f(r.options.method) ? 0 : 1)
      const d = (r.response && r.response.status) || 500
      if (
        u > 0 &&
        (Array.isArray(r.options.retryStatusCodes)
          ? r.options.retryStatusCodes.includes(d)
          : Lk.has(d))
      ) {
        const f =
          typeof r.options.retryDelay == 'function'
            ? r.options.retryDelay(r)
            : r.options.retryDelay || 0
        return (
          f > 0 && (await new Promise((v) => setTimeout(v, f))),
          o(r.request, { ...r.options, retry: u - 1 })
        )
      }
    }
    const c = Ik(r)
    throw (Error.captureStackTrace && Error.captureStackTrace(c, o), c)
  }
  const o = async function (s, c = {}) {
      const u = { request: s, options: Mk(s, c, e.defaults, n), response: void 0, error: void 0 }
      ;(u.options.method && (u.options.method = u.options.method.toUpperCase()),
        u.options.onRequest && (await Ci(u, u.options.onRequest)),
        typeof u.request == 'string' &&
          (u.options.baseURL && (u.request = Ck(u.request, u.options.baseURL)),
          u.options.query && ((u.request = ug(u.request, u.options.query)), delete u.options.query),
          'query' in u.options && delete u.options.query,
          'params' in u.options && delete u.options.params),
        u.options.body &&
          $f(u.options.method) &&
          (Ak(u.options.body)
            ? ((u.options.body =
                typeof u.options.body == 'string'
                  ? u.options.body
                  : JSON.stringify(u.options.body)),
              (u.options.headers = new n(u.options.headers || {})),
              u.options.headers.has('content-type') ||
                u.options.headers.set('content-type', 'application/json'),
              u.options.headers.has('accept') ||
                u.options.headers.set('accept', 'application/json'))
            : (('pipeTo' in u.options.body && typeof u.options.body.pipeTo == 'function') ||
                typeof u.options.body.pipe == 'function') &&
              ('duplex' in u.options || (u.options.duplex = 'half'))))
      let d
      if (!u.options.signal && u.options.timeout) {
        const v = new a()
        ;((d = setTimeout(() => {
          const g = new Error('[TimeoutError]: The operation was aborted due to timeout')
          ;((g.name = 'TimeoutError'), (g.code = 23), v.abort(g))
        }, u.options.timeout)),
          (u.options.signal = v.signal))
      }
      try {
        u.response = await t(u.request, u.options)
      } catch (v) {
        return (
          (u.error = v),
          u.options.onRequestError && (await Ci(u, u.options.onRequestError)),
          await l(u)
        )
      } finally {
        d && clearTimeout(d)
      }
      if (
        (u.response.body || u.response._bodyInit) &&
        !Ok.has(u.response.status) &&
        u.options.method !== 'HEAD'
      ) {
        const v =
          (u.options.parseResponse ? 'json' : u.options.responseType) ||
          Rk(u.response.headers.get('content-type') || '')
        switch (v) {
          case 'json': {
            const g = await u.response.text(),
              h = u.options.parseResponse || nr
            u.response._data = h(g)
            break
          }
          case 'stream': {
            u.response._data = u.response.body || u.response._bodyInit
            break
          }
          default:
            u.response._data = await u.response[v]()
        }
      }
      return (
        u.options.onResponse && (await Ci(u, u.options.onResponse)),
        !u.options.ignoreResponseError && u.response.status >= 400 && u.response.status < 600
          ? (u.options.onResponseError && (await Ci(u, u.options.onResponseError)), await l(u))
          : u.response
      )
    },
    i = async function (s, c) {
      return (await o(s, c))._data
    }
  return (
    (i.raw = o),
    (i.native = (...r) => t(...r)),
    (i.create = (r = {}, s = {}) =>
      mg({ ...e, ...s, defaults: { ...e.defaults, ...s.defaults, ...r } })),
    i
  )
}
const lr = (function () {
    if (typeof globalThis < 'u') return globalThis
    if (typeof self < 'u') return self
    if (typeof window < 'u') return window
    if (typeof global < 'u') return global
    throw new Error('unable to locate global object')
  })(),
  $k = lr.fetch
    ? (...e) => lr.fetch(...e)
    : () => Promise.reject(new Error('[ofetch] global.fetch is not supported!')),
  Fk = lr.Headers,
  Nk = lr.AbortController,
  Hk = mg({ fetch: $k, Headers: Fk, AbortController: Nk }),
  jk = Hk,
  zk = () => window?.__NUXT__?.config || {},
  Rc = () => zk().app,
  Wk = () => Rc().baseURL,
  Uk = () => Rc().buildAssetsDir,
  Mc = (...e) => dg(hg(), Uk(), ...e),
  hg = (...e) => {
    const t = Rc(),
      n = t.cdnURL || t.baseURL
    return e.length ? dg(n, ...e) : n
  }
;((globalThis.__buildAssetsURL = Mc), (globalThis.__publicAssetsURL = hg))
globalThis.$fetch || (globalThis.$fetch = jk.create({ baseURL: Wk() }))
'global' in globalThis || (globalThis.global = globalThis)
function iu(e, t = {}, n) {
  for (const a in e) {
    const l = e[a],
      o = n ? `${n}:${a}` : a
    typeof l == 'object' && l !== null ? iu(l, t, o) : typeof l == 'function' && (t[o] = l)
  }
  return t
}
const Kk = { run: (e) => e() },
  Gk = () => Kk,
  gg = typeof console.createTask < 'u' ? console.createTask : Gk
function Yk(e, t) {
  const n = t.shift(),
    a = gg(n)
  return e.reduce((l, o) => l.then(() => a.run(() => o(...t))), Promise.resolve())
}
function qk(e, t) {
  const n = t.shift(),
    a = gg(n)
  return Promise.all(e.map((l) => a.run(() => l(...t))))
}
function ws(e, t) {
  for (const n of [...e]) n(t)
}
class Xk {
  constructor() {
    ;((this._hooks = {}),
      (this._before = void 0),
      (this._after = void 0),
      (this._deprecatedMessages = void 0),
      (this._deprecatedHooks = {}),
      (this.hook = this.hook.bind(this)),
      (this.callHook = this.callHook.bind(this)),
      (this.callHookWith = this.callHookWith.bind(this)))
  }
  hook(t, n, a = {}) {
    if (!t || typeof n != 'function') return () => {}
    const l = t
    let o
    for (; this._deprecatedHooks[t]; ) ((o = this._deprecatedHooks[t]), (t = o.to))
    if (o && !a.allowDeprecated) {
      let i = o.message
      ;(i || (i = `${l} hook has been deprecated` + (o.to ? `, please use ${o.to}` : '')),
        this._deprecatedMessages || (this._deprecatedMessages = new Set()),
        this._deprecatedMessages.has(i) || (console.warn(i), this._deprecatedMessages.add(i)))
    }
    if (!n.name)
      try {
        Object.defineProperty(n, 'name', {
          get: () => '_' + t.replace(/\W+/g, '_') + '_hook_cb',
          configurable: !0,
        })
      } catch {}
    return (
      (this._hooks[t] = this._hooks[t] || []),
      this._hooks[t].push(n),
      () => {
        n && (this.removeHook(t, n), (n = void 0))
      }
    )
  }
  hookOnce(t, n) {
    let a,
      l = (...o) => (typeof a == 'function' && a(), (a = void 0), (l = void 0), n(...o))
    return ((a = this.hook(t, l)), a)
  }
  removeHook(t, n) {
    if (this._hooks[t]) {
      const a = this._hooks[t].indexOf(n)
      ;(a !== -1 && this._hooks[t].splice(a, 1),
        this._hooks[t].length === 0 && delete this._hooks[t])
    }
  }
  deprecateHook(t, n) {
    this._deprecatedHooks[t] = typeof n == 'string' ? { to: n } : n
    const a = this._hooks[t] || []
    delete this._hooks[t]
    for (const l of a) this.hook(t, l)
  }
  deprecateHooks(t) {
    Object.assign(this._deprecatedHooks, t)
    for (const n in t) this.deprecateHook(n, t[n])
  }
  addHooks(t) {
    const n = iu(t),
      a = Object.keys(n).map((l) => this.hook(l, n[l]))
    return () => {
      for (const l of a.splice(0, a.length)) l()
    }
  }
  removeHooks(t) {
    const n = iu(t)
    for (const a in n) this.removeHook(a, n[a])
  }
  removeAllHooks() {
    for (const t in this._hooks) delete this._hooks[t]
  }
  callHook(t, ...n) {
    return (n.unshift(t), this.callHookWith(Yk, t, ...n))
  }
  callHookParallel(t, ...n) {
    return (n.unshift(t), this.callHookWith(qk, t, ...n))
  }
  callHookWith(t, n, ...a) {
    const l = this._before || this._after ? { name: n, args: a, context: {} } : void 0
    this._before && ws(this._before, l)
    const o = t(n in this._hooks ? [...this._hooks[n]] : [], a)
    return o instanceof Promise
      ? o.finally(() => {
          this._after && l && ws(this._after, l)
        })
      : (this._after && l && ws(this._after, l), o)
  }
  beforeEach(t) {
    return (
      (this._before = this._before || []),
      this._before.push(t),
      () => {
        if (this._before !== void 0) {
          const n = this._before.indexOf(t)
          n !== -1 && this._before.splice(n, 1)
        }
      }
    )
  }
  afterEach(t) {
    return (
      (this._after = this._after || []),
      this._after.push(t),
      () => {
        if (this._after !== void 0) {
          const n = this._after.indexOf(t)
          n !== -1 && this._after.splice(n, 1)
        }
      }
    )
  }
}
function yg() {
  return new Xk()
}
function Zk(e = {}) {
  let t,
    n = !1
  const a = (i) => {
    if (t && t !== i) throw new Error('Context conflict')
  }
  let l
  if (e.asyncContext) {
    const i = e.AsyncLocalStorage || globalThis.AsyncLocalStorage
    i ? (l = new i()) : console.warn('[unctx] `AsyncLocalStorage` is not provided.')
  }
  const o = () => {
    if (l) {
      const i = l.getStore()
      if (i !== void 0) return i
    }
    return t
  }
  return {
    use: () => {
      const i = o()
      if (i === void 0) throw new Error('Context is not available')
      return i
    },
    tryUse: () => o(),
    set: (i, r) => {
      ;(r || a(i), (t = i), (n = !0))
    },
    unset: () => {
      ;((t = void 0), (n = !1))
    },
    call: (i, r) => {
      ;(a(i), (t = i))
      try {
        return l ? l.run(i, r) : r()
      } finally {
        n || (t = void 0)
      }
    },
    async callAsync(i, r) {
      t = i
      const s = () => {
          t = i
        },
        c = () => (t === i ? s : void 0)
      ru.add(c)
      try {
        const u = l ? l.run(i, r) : r()
        return (n || (t = void 0), await u)
      } finally {
        ru.delete(c)
      }
    },
  }
}
function Jk(e = {}) {
  const t = {}
  return {
    get(n, a = {}) {
      return (t[n] || (t[n] = Zk({ ...e, ...a })), t[n])
    },
  }
}
const or =
    typeof globalThis < 'u'
      ? globalThis
      : typeof self < 'u'
        ? self
        : typeof global < 'u'
          ? global
          : typeof window < 'u'
            ? window
            : {},
  Ff = '__unctx__',
  Qk = or[Ff] || (or[Ff] = Jk()),
  eC = (e, t = {}) => Qk.get(e, t),
  Nf = '__unctx_async_handlers__',
  ru = or[Nf] || (or[Nf] = new Set())
function Ml(e) {
  const t = []
  for (const l of ru) {
    const o = l()
    o && t.push(o)
  }
  const n = () => {
    for (const l of t) l()
  }
  let a = e()
  return (
    a &&
      typeof a == 'object' &&
      'catch' in a &&
      (a = a.catch((l) => {
        throw (n(), l)
      })),
    [a, n]
  )
}
const Hf = !1,
  tC = !1,
  nC = { componentName: 'NuxtLink', prefetch: !0, prefetchOn: { visibility: !0 } },
  wM = { value: null, errorValue: null, deep: !0 },
  aC = null,
  kM = {},
  lC = '#__nuxt',
  bg = 'nuxt-app',
  jf = 36e5,
  oC = 'vite:preloadError'
function pg(e = bg) {
  return eC(e, { asyncContext: !1 })
}
const iC = '__nuxt_plugin'
function rC(e) {
  let t = 0
  const n = {
    _id: e.id || bg || 'nuxt-app',
    _scope: Ya(),
    provide: void 0,
    globalName: 'nuxt',
    versions: {
      get nuxt() {
        return '3.19.2'
      },
      get vue() {
        return n.vueApp.version
      },
    },
    payload: ea({
      ...(e.ssrContext?.payload || {}),
      data: ea({}),
      state: it({}),
      once: new Set(),
      _errors: ea({}),
    }),
    static: { data: {} },
    runWithContext(l) {
      return n._scope.active && !fc() ? n._scope.run(() => zf(n, l)) : zf(n, l)
    },
    isHydrating: !0,
    deferHydration() {
      if (!n.isHydrating) return () => {}
      t++
      let l = !1
      return () => {
        if (!l && ((l = !0), t--, t === 0))
          return ((n.isHydrating = !1), n.callHook('app:suspense:resolve'))
      }
    },
    _asyncDataPromises: {},
    _asyncData: ea({}),
    _payloadRevivers: {},
    ...e,
  }
  {
    const l = window.__NUXT__
    if (l)
      for (const o in l)
        switch (o) {
          case 'data':
          case 'state':
          case '_errors':
            Object.assign(n.payload[o], l[o])
            break
          default:
            n.payload[o] = l[o]
        }
  }
  ;((n.hooks = yg()),
    (n.hook = n.hooks.hook),
    (n.callHook = n.hooks.callHook),
    (n.provide = (l, o) => {
      const i = '$' + l
      ;(xi(n, i, o), xi(n.vueApp.config.globalProperties, i, o))
    }),
    xi(n.vueApp, '$nuxt', n),
    xi(n.vueApp.config.globalProperties, '$nuxt', n))
  {
    ;(window.addEventListener(oC, (o) => {
      ;(n.callHook('app:chunkError', { error: o.payload }),
        o.payload.message.includes('Unable to preload CSS') && o.preventDefault())
    }),
      (window.useNuxtApp ||= ht))
    const l = n.hook('app:error', (...o) => {
      console.error('[nuxt] error caught during app initialization', ...o)
    })
    n.hook('app:mounted', l)
  }
  const a = n.payload.config
  return (n.provide('config', a), n)
}
function sC(e, t) {
  t.hooks && e.hooks.addHooks(t.hooks)
}
async function uC(e, t) {
  if (typeof t == 'function') {
    const { provide: n } = (await e.runWithContext(() => t(e))) || {}
    if (n && typeof n == 'object') for (const a in n) e.provide(a, n[a])
  }
}
async function cC(e, t) {
  const n = new Set(),
    a = [],
    l = []
  let o,
    i = 0
  async function r(s) {
    const c = s.dependsOn?.filter((u) => t.some((d) => d._name === u) && !n.has(u)) ?? []
    if (c.length > 0) a.push([new Set(c), s])
    else {
      const u = uC(e, s)
        .then(async () => {
          s._name &&
            (n.add(s._name),
            await Promise.all(
              a.map(async ([d, f]) => {
                d.has(s._name) && (d.delete(s._name), d.size === 0 && (i++, await r(f)))
              })
            ))
        })
        .catch((d) => {
          if (!s.parallel && !e.payload.error) throw d
          o ||= d
        })
      s.parallel ? l.push(u) : await u
    }
  }
  for (const s of t) sC(e, s)
  for (const s of t) await r(s)
  if ((await Promise.all(l), i)) for (let s = 0; s < i; s++) await Promise.all(l)
  if (o) throw e.payload.error || o
}
function zn(e) {
  if (typeof e == 'function') return e
  const t = e._name || e.name
  return (delete e.name, Object.assign(e.setup || (() => {}), e, { [iC]: !0, _name: t }))
}
function zf(e, t, n) {
  const a = () => t()
  return (pg(e._id).set(e), e.vueApp.runWithContext(a))
}
function Sg(e) {
  let t
  return (_r() && (t = jn()?.appContext.app.$nuxt), (t ||= pg(e).tryUse()), t || null)
}
function ht(e) {
  const t = Sg(e)
  if (!t) throw new Error('[nuxt] instance unavailable')
  return t
}
function ei(e) {
  return ht().$config
}
function xi(e, t, n) {
  Object.defineProperty(e, t, { get: () => n })
}
function dC(e, t) {
  return { ctx: { table: e }, matchAll: (n) => kg(n, e) }
}
function wg(e) {
  const t = {}
  for (const n in e)
    t[n] =
      n === 'dynamic'
        ? new Map(Object.entries(e[n]).map(([a, l]) => [a, wg(l)]))
        : new Map(Object.entries(e[n]))
  return t
}
function fC(e) {
  return dC(wg(e))
}
function kg(e, t, n) {
  e.endsWith('/') && (e = e.slice(0, -1) || '/')
  const a = []
  for (const [o, i] of Wf(t.wildcard)) (e === o || e.startsWith(o + '/')) && a.push(i)
  for (const [o, i] of Wf(t.dynamic))
    if (e.startsWith(o + '/')) {
      const r = '/' + e.slice(o.length).split('/').splice(2).join('/')
      a.push(...kg(r, i))
    }
  const l = t.static.get(e)
  return (l && a.push(l), a.filter(Boolean))
}
function Wf(e) {
  return [...e.entries()].sort((t, n) => t[0].length - n[0].length)
}
function ks(e) {
  if (e === null || typeof e != 'object') return !1
  const t = Object.getPrototypeOf(e)
  return (t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null) ||
    Symbol.iterator in e
    ? !1
    : Symbol.toStringTag in e
      ? Object.prototype.toString.call(e) === '[object Module]'
      : !0
}
function su(e, t, n = '.', a) {
  if (!ks(t)) return su(e, {}, n, a)
  const l = Object.assign({}, t)
  for (const o in e) {
    if (o === '__proto__' || o === 'constructor') continue
    const i = e[o]
    i != null &&
      ((a && a(l, o, i, n)) ||
        (Array.isArray(i) && Array.isArray(l[o])
          ? (l[o] = [...i, ...l[o]])
          : ks(i) && ks(l[o])
            ? (l[o] = su(i, l[o], (n ? `${n}.` : '') + o.toString(), a))
            : (l[o] = i)))
  }
  return l
}
function vC(e) {
  return (...t) => t.reduce((n, a) => su(n, a, '', e), {})
}
const Cg = vC()
function mC(e, t) {
  try {
    return t in e
  } catch {
    return !1
  }
}
class Uf extends Error {
  static __h3_error__ = !0
  statusCode = 500
  fatal = !1
  unhandled = !1
  statusMessage
  data
  cause
  constructor(t, n = {}) {
    ;(super(t, n), n.cause && !this.cause && (this.cause = n.cause))
  }
  toJSON() {
    const t = { message: this.message, statusCode: uu(this.statusCode, 500) }
    return (
      this.statusMessage && (t.statusMessage = xg(this.statusMessage)),
      this.data !== void 0 && (t.data = this.data),
      t
    )
  }
}
function hC(e) {
  if (typeof e == 'string') return new Uf(e)
  if (gC(e)) return e
  const t = new Uf(e.message ?? e.statusMessage ?? '', { cause: e.cause || e })
  if (mC(e, 'stack'))
    try {
      Object.defineProperty(t, 'stack', {
        get() {
          return e.stack
        },
      })
    } catch {
      try {
        t.stack = e.stack
      } catch {}
    }
  if (
    (e.data && (t.data = e.data),
    e.statusCode
      ? (t.statusCode = uu(e.statusCode, t.statusCode))
      : e.status && (t.statusCode = uu(e.status, t.statusCode)),
    e.statusMessage
      ? (t.statusMessage = e.statusMessage)
      : e.statusText && (t.statusMessage = e.statusText),
    t.statusMessage)
  ) {
    const n = t.statusMessage
    xg(t.statusMessage) !== n &&
      console.warn(
        '[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.'
      )
  }
  return (
    e.fatal !== void 0 && (t.fatal = e.fatal),
    e.unhandled !== void 0 && (t.unhandled = e.unhandled),
    t
  )
}
function gC(e) {
  return e?.constructor?.__h3_error__ === !0
}
const yC = /[^\u0009\u0020-\u007E]/g
function xg(e = '') {
  return e.replace(yC, '')
}
function uu(e, t = 200) {
  return !e || (typeof e == 'string' && (e = Number.parseInt(e, 10)), e < 100 || e > 999) ? t : e
}
const bC = Symbol('layout-meta'),
  Ar = Symbol('route')
import.meta.url.replace(/\/app\/.*$/, '/')
const Xt = () => ht()?.$router,
  _g = () => (_r() ? Ve(Ar, ht()._route) : ht()._route)
const pC = () => {
    try {
      if (ht()._processingMiddleware) return !0
    } catch {
      return !1
    }
    return !1
  },
  SC = (e, t) => {
    e ||= '/'
    const n = typeof e == 'string' ? e : 'path' in e ? cu(e) : Xt().resolve(e).href
    if (t?.open) {
      const { target: s = '_blank', windowFeatures: c = {} } = t.open,
        u = []
      for (const [d, f] of Object.entries(c)) f !== void 0 && u.push(`${d.toLowerCase()}=${f}`)
      return (open(n, s, u.join(', ')), Promise.resolve())
    }
    const a = ca(n, { acceptRelative: !0 }),
      l = t?.external || a
    if (l) {
      if (!t?.external)
        throw new Error(
          'Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.'
        )
      const { protocol: s } = new URL(n, window.location.href)
      if (s && kk(s)) throw new Error(`Cannot navigate to a URL with '${s}' protocol.`)
    }
    const o = pC()
    if (!l && o) {
      if (t?.replace) {
        if (typeof e == 'string') {
          const { pathname: s, search: c, hash: u } = vg(e)
          return { path: s, ...(c && { query: Dc(c) }), ...(u && { hash: u }), replace: !0 }
        }
        return { ...e, replace: !0 }
      }
      return e
    }
    const i = Xt(),
      r = ht()
    return l
      ? (r._scope.stop(),
        t?.replace ? location.replace(n) : (location.href = n),
        o ? (r.isHydrating ? new Promise(() => {}) : !1) : Promise.resolve())
      : t?.replace
        ? i.replace(e)
        : i.push(e)
  }
function cu(e) {
  return ug(e.path || '', e.query || {}) + (e.hash || '')
}
const Pg = '__nuxt_error',
  Er = () => B(ht().payload, 'error'),
  Oa = (e) => {
    const t = za(e)
    try {
      const n = ht(),
        a = Er()
      ;(n.hooks.callHook('app:error', t), (a.value ||= t))
    } catch {
      throw t
    }
    return t
  },
  wC = async (e = {}) => {
    const t = ht(),
      n = Er()
    ;(t.callHook('app:error:cleared', e),
      e.redirect && (await Xt().replace(e.redirect)),
      (n.value = aC))
  },
  Vg = (e) => !!e && typeof e == 'object' && Pg in e,
  za = (e) => {
    const t = hC(e)
    return (Object.defineProperty(t, Pg, { value: !0, configurable: !1, writable: !1 }), t)
  }
function kC(e) {
  const t = xC(e),
    n = new ArrayBuffer(t.length),
    a = new DataView(n)
  for (let l = 0; l < n.byteLength; l++) a.setUint8(l, t.charCodeAt(l))
  return n
}
const CC = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
function xC(e) {
  e.length % 4 === 0 && (e = e.replace(/==?$/, ''))
  let t = '',
    n = 0,
    a = 0
  for (let l = 0; l < e.length; l++)
    ((n <<= 6),
      (n |= CC.indexOf(e[l])),
      (a += 6),
      a === 24 &&
        ((t += String.fromCharCode((n & 16711680) >> 16)),
        (t += String.fromCharCode((n & 65280) >> 8)),
        (t += String.fromCharCode(n & 255)),
        (n = a = 0)))
  return (
    a === 12
      ? ((n >>= 4), (t += String.fromCharCode(n)))
      : a === 18 &&
        ((n >>= 2),
        (t += String.fromCharCode((n & 65280) >> 8)),
        (t += String.fromCharCode(n & 255))),
    t
  )
}
const _C = -1,
  PC = -2,
  VC = -3,
  IC = -4,
  TC = -5,
  AC = -6
function EC(e, t) {
  return DC(JSON.parse(e), t)
}
function DC(e, t) {
  if (typeof e == 'number') return l(e, !0)
  if (!Array.isArray(e) || e.length === 0) throw new Error('Invalid input')
  const n = e,
    a = Array(n.length)
  function l(o, i = !1) {
    if (o === _C) return
    if (o === VC) return NaN
    if (o === IC) return 1 / 0
    if (o === TC) return -1 / 0
    if (o === AC) return -0
    if (i || typeof o != 'number') throw new Error('Invalid input')
    if (o in a) return a[o]
    const r = n[o]
    if (!r || typeof r != 'object') a[o] = r
    else if (Array.isArray(r))
      if (typeof r[0] == 'string') {
        const s = r[0],
          c = t?.[s]
        if (c) return (a[o] = c(l(r[1])))
        switch (s) {
          case 'Date':
            a[o] = new Date(r[1])
            break
          case 'Set':
            const u = new Set()
            a[o] = u
            for (let v = 1; v < r.length; v += 1) u.add(l(r[v]))
            break
          case 'Map':
            const d = new Map()
            a[o] = d
            for (let v = 1; v < r.length; v += 2) d.set(l(r[v]), l(r[v + 1]))
            break
          case 'RegExp':
            a[o] = new RegExp(r[1], r[2])
            break
          case 'Object':
            a[o] = Object(r[1])
            break
          case 'BigInt':
            a[o] = BigInt(r[1])
            break
          case 'null':
            const f = Object.create(null)
            a[o] = f
            for (let v = 1; v < r.length; v += 2) f[r[v]] = l(r[v + 1])
            break
          case 'Int8Array':
          case 'Uint8Array':
          case 'Uint8ClampedArray':
          case 'Int16Array':
          case 'Uint16Array':
          case 'Int32Array':
          case 'Uint32Array':
          case 'Float32Array':
          case 'Float64Array':
          case 'BigInt64Array':
          case 'BigUint64Array': {
            const v = globalThis[s],
              g = new v(l(r[1]))
            a[o] = r[2] !== void 0 ? g.subarray(r[2], r[3]) : g
            break
          }
          case 'ArrayBuffer': {
            const v = r[1],
              g = kC(v)
            a[o] = g
            break
          }
          case 'Temporal.Duration':
          case 'Temporal.Instant':
          case 'Temporal.PlainDate':
          case 'Temporal.PlainTime':
          case 'Temporal.PlainDateTime':
          case 'Temporal.PlainMonthDay':
          case 'Temporal.PlainYearMonth':
          case 'Temporal.ZonedDateTime': {
            const v = s.slice(9)
            a[o] = Temporal[v].from(r[1])
            break
          }
          case 'URL': {
            const v = new URL(r[1])
            a[o] = v
            break
          }
          case 'URLSearchParams': {
            const v = new URLSearchParams(r[1])
            a[o] = v
            break
          }
          default:
            throw new Error(`Unknown type ${s}`)
        }
      } else {
        const s = new Array(r.length)
        a[o] = s
        for (let c = 0; c < r.length; c += 1) {
          const u = r[c]
          u !== PC && (s[c] = l(u))
        }
      }
    else {
      const s = {}
      a[o] = s
      for (const c in r) {
        if (c === '__proto__') throw new Error('Cannot parse an object with a `__proto__` property')
        const u = r[c]
        s[c] = l(u)
      }
    }
    return a[o]
  }
  return l(0)
}
const RC = new Set(['link', 'style', 'script', 'noscript']),
  MC = new Set(['title', 'titleTemplate', 'script', 'style', 'noscript']),
  Kf = new Set(['base', 'meta', 'link', 'style', 'script', 'noscript']),
  BC = new Set([
    'title',
    'base',
    'htmlAttrs',
    'bodyAttrs',
    'meta',
    'link',
    'style',
    'script',
    'noscript',
  ]),
  LC = new Set(['base', 'title', 'titleTemplate', 'bodyAttrs', 'htmlAttrs', 'templateParams']),
  OC = new Set([
    'key',
    'tagPosition',
    'tagPriority',
    'tagDuplicateStrategy',
    'innerHTML',
    'textContent',
    'processTemplateParams',
  ]),
  $C = new Set(['templateParams', 'htmlAttrs', 'bodyAttrs']),
  FC = new Set([
    'theme-color',
    'google-site-verification',
    'og',
    'article',
    'book',
    'profile',
    'twitter',
    'author',
  ])
const NC = ['name', 'property', 'http-equiv'],
  HC = new Set(['viewport', 'description', 'keywords', 'robots'])
function Ig(e) {
  const t = e.split(':')
  return t.length ? FC.has(t[1]) : !1
}
function du(e) {
  const { props: t, tag: n } = e
  if (LC.has(n)) return n
  if (n === 'link' && t.rel === 'canonical') return 'canonical'
  if (t.charset) return 'charset'
  if (e.tag === 'meta') {
    for (const a of NC)
      if (t[a] !== void 0) {
        const l = t[a],
          o = l.includes(':'),
          i = HC.has(l),
          s = !(o || i) && e.key ? `:key:${e.key}` : ''
        return `${n}:${l}${s}`
      }
  }
  if (e.key) return `${n}:key:${e.key}`
  if (t.id) return `${n}:id:${t.id}`
  if (MC.has(n)) {
    const a = e.textContent || e.innerHTML
    if (a) return `${n}:content:${a}`
  }
}
function Gf(e) {
  const t = e._h || e._d
  if (t) return t
  const n = e.textContent || e.innerHTML
  return (
    n ||
    `${e.tag}:${Object.entries(e.props)
      .map(([a, l]) => `${a}:${String(l)}`)
      .join(',')}`
  )
}
function ir(e, t, n) {
  typeof e === 'function' &&
    (!n || (n !== 'titleTemplate' && !(n[0] === 'o' && n[1] === 'n'))) &&
    (e = e())
  let l
  if ((t && (l = t(n, e)), Array.isArray(l))) return l.map((o) => ir(o, t))
  if (l?.constructor === Object) {
    const o = {}
    for (const i of Object.keys(l)) o[i] = ir(l[i], t, i)
    return o
  }
  return l
}
function jC(e, t) {
  const n = e === 'style' ? new Map() : new Set()
  function a(l) {
    const o = l.trim()
    if (o)
      if (e === 'style') {
        const [i, ...r] = o.split(':').map((s) => s.trim())
        i && r.length && n.set(i, r.join(':'))
      } else
        o.split(' ')
          .filter(Boolean)
          .forEach((i) => n.add(i))
  }
  return (
    typeof t == 'string'
      ? e === 'style'
        ? t.split(';').forEach(a)
        : a(t)
      : Array.isArray(t)
        ? t.forEach((l) => a(l))
        : t &&
          typeof t == 'object' &&
          Object.entries(t).forEach(([l, o]) => {
            o && o !== 'false' && (e === 'style' ? n.set(l.trim(), o) : a(l))
          }),
    n
  )
}
function Tg(e, t) {
  return (
    (e.props = e.props || {}),
    t
      ? e.tag === 'templateParams'
        ? ((e.props = t), e)
        : (Object.entries(t).forEach(([n, a]) => {
            if (a === null) {
              e.props[n] = null
              return
            }
            if (n === 'class' || n === 'style') {
              e.props[n] = jC(n, a)
              return
            }
            if (OC.has(n)) {
              if (['textContent', 'innerHTML'].includes(n) && typeof a == 'object') {
                let i = t.type
                if (
                  (t.type || (i = 'application/json'),
                  !i?.endsWith('json') && i !== 'speculationrules')
                )
                  return
                ;((t.type = i), (e.props.type = i), (e[n] = JSON.stringify(a)))
              } else e[n] = a
              return
            }
            const l = String(a),
              o = n.startsWith('data-')
            l === 'true' || l === ''
              ? (e.props[n] = o ? l : !0)
              : !a && o && l === 'false'
                ? (e.props[n] = 'false')
                : a !== void 0 && (e.props[n] = a)
          }),
          e)
      : e
  )
}
function zC(e, t) {
  const n =
      typeof t == 'object' && typeof t != 'function'
        ? t
        : {
            [e === 'script' || e === 'noscript' || e === 'style' ? 'innerHTML' : 'textContent']: t,
          },
    a = Tg({ tag: e, props: {} }, n)
  return (
    a.key && RC.has(a.tag) && (a.props['data-hid'] = a._h = a.key),
    a.tag === 'script' &&
      typeof a.innerHTML == 'object' &&
      ((a.innerHTML = JSON.stringify(a.innerHTML)),
      (a.props.type = a.props.type || 'application/json')),
    Array.isArray(a.props.content)
      ? a.props.content.map((l) => ({ ...a, props: { ...a.props, content: l } }))
      : a
  )
}
function WC(e, t) {
  if (!e) return []
  typeof e == 'function' && (e = e())
  const n = (l, o) => {
    for (let i = 0; i < t.length; i++) o = t[i](l, o)
    return o
  }
  e = n(void 0, e)
  const a = []
  return (
    (e = ir(e, n)),
    Object.entries(e || {}).forEach(([l, o]) => {
      if (o !== void 0) for (const i of Array.isArray(o) ? o : [o]) a.push(zC(l, i))
    }),
    a.flat()
  )
}
const fu = (e, t) => (e._w === t._w ? e._p - t._p : e._w - t._w),
  Yf = { base: -10, title: 10 },
  UC = { critical: -8, high: -1, low: 2 },
  qf = {
    meta: { 'content-security-policy': -30, charset: -20, viewport: -15 },
    link: {
      preconnect: 20,
      stylesheet: 60,
      preload: 70,
      modulepreload: 70,
      prefetch: 90,
      'dns-prefetch': 90,
      prerender: 90,
    },
    script: { async: 30, defer: 80, sync: 50 },
    style: { imported: 40, sync: 60 },
  },
  KC = /@import/,
  co = (e) => e === '' || e === !0
function GC(e, t) {
  if (typeof t.tagPriority == 'number') return t.tagPriority
  let n = 100
  const a = UC[t.tagPriority] || 0,
    l = e.resolvedOptions.disableCapoSorting ? { link: {}, script: {}, style: {} } : qf
  if (t.tag in Yf) n = Yf[t.tag]
  else if (t.tag === 'meta') {
    const o =
      t.props['http-equiv'] === 'content-security-policy'
        ? 'content-security-policy'
        : t.props.charset
          ? 'charset'
          : t.props.name === 'viewport'
            ? 'viewport'
            : null
    o && (n = qf.meta[o])
  } else
    t.tag === 'link' && t.props.rel
      ? (n = l.link[t.props.rel])
      : t.tag === 'script'
        ? co(t.props.async)
          ? (n = l.script.async)
          : t.props.src &&
              !co(t.props.defer) &&
              !co(t.props.async) &&
              t.props.type !== 'module' &&
              !t.props.type?.endsWith('json')
            ? (n = l.script.sync)
            : co(t.props.defer) && t.props.src && !co(t.props.async) && (n = l.script.defer)
        : t.tag === 'style' &&
          (n = t.innerHTML && KC.test(t.innerHTML) ? l.style.imported : l.style.sync)
  return (n || 100) + a
}
function Xf(e, t) {
  const n = typeof t == 'function' ? t(e) : t,
    a = n.key || String(e.plugins.size + 1)
  e.plugins.get(a) || (e.plugins.set(a, n), e.hooks.addHooks(n.hooks || {}))
}
function YC(e = {}) {
  const t = yg()
  t.addHooks(e.hooks || {})
  const n = !e.document,
    a = new Map(),
    l = new Map(),
    o = new Set(),
    i = {
      _entryCount: 1,
      plugins: l,
      dirty: !1,
      resolvedOptions: e,
      hooks: t,
      ssr: n,
      entries: a,
      headEntries() {
        return [...a.values()]
      },
      use: (r) => Xf(i, r),
      push(r, s) {
        const c = { ...(s || {}) }
        delete c.head
        const u = c._index ?? i._entryCount++,
          d = { _i: u, input: r, options: c },
          f = {
            _poll(v = !1) {
              ;((i.dirty = !0), !v && o.add(u), t.callHook('entries:updated', i))
            },
            dispose() {
              a.delete(u) && i.invalidate()
            },
            patch(v) {
              ;(!c.mode || (c.mode === 'server' && n) || (c.mode === 'client' && !n)) &&
                ((d.input = v), a.set(u, d), f._poll())
            },
          }
        return (f.patch(r), f)
      },
      async resolveTags() {
        const r = { tagMap: new Map(), tags: [], entries: [...i.entries.values()] }
        for (await t.callHook('entries:resolve', r); o.size; ) {
          const f = o.values().next().value
          o.delete(f)
          const v = a.get(f)
          if (v) {
            const g = {
              tags: WC(v.input, e.propResolvers || []).map((h) => Object.assign(h, v.options)),
              entry: v,
            }
            ;(await t.callHook('entries:normalize', g),
              (v._tags = g.tags.map(
                (h, m) => ((h._w = GC(i, h)), (h._p = (v._i << 10) + m), (h._d = du(h)), h)
              )))
          }
        }
        let s = !1
        r.entries
          .flatMap((f) => (f._tags || []).map((v) => ({ ...v, props: { ...v.props } })))
          .sort(fu)
          .reduce((f, v) => {
            const g = String(v._d || v._p)
            if (!f.has(g)) return f.set(g, v)
            const h = f.get(g)
            if (
              (v?.tagDuplicateStrategy ||
                ($C.has(v.tag) ? 'merge' : null) ||
                (v.key && v.key === h.key ? 'merge' : null)) === 'merge'
            ) {
              const b = { ...h.props }
              ;(Object.entries(v.props).forEach(
                ([y, p]) =>
                  (b[y] =
                    y === 'style'
                      ? new Map([...(h.props.style || new Map()), ...p])
                      : y === 'class'
                        ? new Set([...(h.props.class || new Set()), ...p])
                        : p)
              ),
                f.set(g, { ...v, props: b }))
            } else
              v._p >> 10 === h._p >> 10 && v.tag === 'meta' && Ig(g)
                ? (f.set(g, Object.assign([...(Array.isArray(h) ? h : [h]), v], v)), (s = !0))
                : (v._w === h._w ? v._p > h._p : v?._w < h?._w) && f.set(g, v)
            return f
          }, r.tagMap)
        const c = r.tagMap.get('title'),
          u = r.tagMap.get('titleTemplate')
        if (((i._title = c?.textContent), u)) {
          const f = u?.textContent
          if (((i._titleTemplate = f), f)) {
            let v = typeof f == 'function' ? f(c?.textContent) : f
            ;(typeof v == 'string' &&
              !i.plugins.has('template-params') &&
              (v = v.replace('%s', c?.textContent || '')),
              c
                ? v === null
                  ? r.tagMap.delete('title')
                  : r.tagMap.set('title', { ...c, textContent: v })
                : ((u.tag = 'title'), (u.textContent = v)))
          }
        }
        ;((r.tags = Array.from(r.tagMap.values())),
          s && (r.tags = r.tags.flat().sort(fu)),
          await t.callHook('tags:beforeResolve', r),
          await t.callHook('tags:resolve', r),
          await t.callHook('tags:afterResolve', r))
        const d = []
        for (const f of r.tags) {
          const { innerHTML: v, tag: g, props: h } = f
          if (
            BC.has(g) &&
            !(Object.keys(h).length === 0 && !f.innerHTML && !f.textContent) &&
            !(g === 'meta' && !h.content && !h['http-equiv'] && !h.charset)
          ) {
            if (g === 'script' && v) {
              if (h.type?.endsWith('json')) {
                const m = typeof v == 'string' ? v : JSON.stringify(v)
                f.innerHTML = m.replace(/</g, '\\u003C')
              } else
                typeof v == 'string' &&
                  (f.innerHTML = v.replace(new RegExp(`</${g}`, 'g'), `<\\/${g}`))
              f._d = du(f)
            }
            d.push(f)
          }
        }
        return d
      },
      invalidate() {
        for (const r of a.values()) o.add(r._i)
        ;((i.dirty = !0), t.callHook('entries:updated', i))
      },
    }
  return (
    (e?.plugins || []).forEach((r) => Xf(i, r)),
    i.hooks.callHook('init', i),
    e.init?.forEach((r) => r && i.push(r)),
    i
  )
}
const Cs = '%separator'
function qC(e, t, n = !1) {
  let a
  if (t === 's' || t === 'pageTitle') a = e.pageTitle
  else if (t.includes('.')) {
    const l = t.indexOf('.')
    a = e[t.substring(0, l)]?.[t.substring(l + 1)]
  } else a = e[t]
  if (a !== void 0)
    return n
      ? (a || '').replace(/\\/g, '\\\\').replace(/</g, '\\u003C').replace(/"/g, '\\"')
      : a || ''
}
function _i(e, t, n, a = !1) {
  if (typeof e != 'string' || !e.includes('%')) return e
  let l = e
  try {
    l = decodeURI(e)
  } catch {}
  const o = l.match(/%\w+(?:\.\w+)?/g)
  if (!o) return e
  const i = e.includes(Cs)
  return (
    (e = e
      .replace(/%\w+(?:\.\w+)?/g, (r) => {
        if (r === Cs || !o.includes(r)) return r
        const s = qC(t, r.slice(1), a)
        return s !== void 0 ? s : r
      })
      .trim()),
    i &&
      (e = e
        .split(Cs)
        .map((r) => r.trim())
        .filter((r) => r !== '')
        .join(n ? ` ${n} ` : ' ')),
    e
  )
}
const Zf = (e) => (e.includes(':key') ? e : e.split(':').join(':key:')),
  XC = {
    key: 'aliasSorting',
    hooks: {
      'tags:resolve': (e) => {
        let t = !1
        for (const n of e.tags) {
          const a = n.tagPriority
          if (!a) continue
          const l = String(a)
          if (l.startsWith('before:')) {
            const o = Zf(l.slice(7)),
              i = e.tagMap.get(o)
            i &&
              (typeof i.tagPriority == 'number' && (n.tagPriority = i.tagPriority),
              (n._p = i._p - 1),
              (t = !0))
          } else if (l.startsWith('after:')) {
            const o = Zf(l.slice(6)),
              i = e.tagMap.get(o)
            i &&
              (typeof i.tagPriority == 'number' && (n.tagPriority = i.tagPriority),
              (n._p = i._p + 1),
              (t = !0))
          }
        }
        t && (e.tags = e.tags.sort(fu))
      },
    },
  },
  ZC = {
    key: 'deprecations',
    hooks: {
      'entries:normalize': ({ tags: e }) => {
        for (const t of e)
          (t.props.children && ((t.innerHTML = t.props.children), delete t.props.children),
            t.props.hid && ((t.key = t.props.hid), delete t.props.hid),
            t.props.vmid && ((t.key = t.props.vmid), delete t.props.vmid),
            t.props.body && ((t.tagPosition = 'bodyClose'), delete t.props.body))
      },
    },
  }
async function vu(e) {
  if (typeof e === 'function') return e
  if (e instanceof Promise) return await e
  if (Array.isArray(e)) return await Promise.all(e.map((n) => vu(n)))
  if (e?.constructor === Object) {
    const n = {}
    for (const a of Object.keys(e)) n[a] = await vu(e[a])
    return n
  }
  return e
}
const JC = {
    key: 'promises',
    hooks: {
      'entries:resolve': async (e) => {
        const t = []
        for (const n in e.entries)
          e.entries[n]._promisesProcessed ||
            t.push(
              vu(e.entries[n].input).then((a) => {
                ;((e.entries[n].input = a), (e.entries[n]._promisesProcessed = !0))
              })
            )
        await Promise.all(t)
      },
    },
  },
  QC = { meta: 'content', link: 'href', htmlAttrs: 'lang' },
  ex = ['innerHTML', 'textContent'],
  tx = (e) => ({
    key: 'template-params',
    hooks: {
      'entries:normalize': (t) => {
        const n =
          t.tags.filter((a) => a.tag === 'templateParams' && a.mode === 'server')?.[0]?.props || {}
        Object.keys(n).length &&
          (e._ssrPayload = { templateParams: { ...(e._ssrPayload?.templateParams || {}), ...n } })
      },
      'tags:resolve': ({ tagMap: t, tags: n }) => {
        const a = t.get('templateParams')?.props || {},
          l = a.separator || '|'
        ;(delete a.separator, (a.pageTitle = _i(a.pageTitle || e._title || '', a, l)))
        for (const o of n) {
          if (o.processTemplateParams === !1) continue
          const i = QC[o.tag]
          if (i && typeof o.props[i] == 'string') o.props[i] = _i(o.props[i], a, l)
          else if (o.processTemplateParams || o.tag === 'titleTemplate' || o.tag === 'title')
            for (const r of ex)
              typeof o[r] == 'string' &&
                (o[r] = _i(o[r], a, l, o.tag === 'script' && o.props.type.endsWith('json')))
        }
        ;((e._templateParams = a), (e._separator = l))
      },
      'tags:afterResolve': ({ tagMap: t }) => {
        const n = t.get('title')
        n?.textContent &&
          n.processTemplateParams !== !1 &&
          (n.textContent = _i(n.textContent, e._templateParams, e._separator))
      },
    },
  }),
  nx = (e, t) => (ct(t) ? Ft(t) : t),
  Bc = 'usehead'
function ax(e) {
  return {
    install(n) {
      ;((n.config.globalProperties.$unhead = e),
        (n.config.globalProperties.$head = e),
        n.provide(Bc, e))
    },
  }.install
}
function lx() {
  if (_r()) {
    const e = Ve(Bc)
    if (!e)
      throw new Error(
        'useHead() was called without provide context, ensure you call it through the setup() function.'
      )
    return e
  }
  throw new Error(
    'useHead() was called without provide context, ensure you call it through the setup() function.'
  )
}
function ox(e, t = {}) {
  const n = t.head || lx()
  return n.ssr ? n.push(e || {}, t) : ix(n, e, t)
}
function ix(e, t, n = {}) {
  const a = ae(!1)
  let l
  return (
    qe(() => {
      const i = a.value ? {} : ir(t, nx)
      l ? l.patch(i) : (l = e.push(i, n))
    }),
    jn() &&
      (dt(() => {
        l.dispose()
      }),
      kr(() => {
        a.value = !0
      }),
      Cc(() => {
        a.value = !1
      })),
    l
  )
}
function rx(e) {
  const t = e || Sg()
  return (
    t?.ssrContext?.head ||
    t?.runWithContext(() => {
      if (_r()) return Ve(Bc)
    })
  )
}
function sx(e, t = {}) {
  const n = rx(t.nuxt)
  if (n) return ox(e, { head: n, ...t })
}
const ux = 'modulepreload',
  cx = function (e, t) {
    return new URL(e, t).href
  },
  Jf = {},
  $i = function (t, n, a) {
    let l = Promise.resolve()
    if (n && n.length > 0) {
      let c = function (u) {
        return Promise.all(
          u.map((d) =>
            Promise.resolve(d).then(
              (f) => ({ status: 'fulfilled', value: f }),
              (f) => ({ status: 'rejected', reason: f })
            )
          )
        )
      }
      const i = document.getElementsByTagName('link'),
        r = document.querySelector('meta[property=csp-nonce]'),
        s = r?.nonce || r?.getAttribute('nonce')
      l = c(
        n.map((u) => {
          if (((u = cx(u, a)), u in Jf)) return
          Jf[u] = !0
          const d = u.endsWith('.css'),
            f = d ? '[rel="stylesheet"]' : ''
          if (a)
            for (let g = i.length - 1; g >= 0; g--) {
              const h = i[g]
              if (h.href === u && (!d || h.rel === 'stylesheet')) return
            }
          else if (document.querySelector(`link[href="${u}"]${f}`)) return
          const v = document.createElement('link')
          if (
            ((v.rel = d ? 'stylesheet' : ux),
            d || (v.as = 'script'),
            (v.crossOrigin = ''),
            (v.href = u),
            s && v.setAttribute('nonce', s),
            document.head.appendChild(v),
            d)
          )
            return new Promise((g, h) => {
              ;(v.addEventListener('load', g),
                v.addEventListener('error', () => h(new Error(`Unable to preload CSS for ${u}`))))
            })
        })
      )
    }
    function o(i) {
      const r = new Event('vite:preloadError', { cancelable: !0 })
      if (((r.payload = i), window.dispatchEvent(r), !r.defaultPrevented)) throw i
    }
    return l.then((i) => {
      for (const r of i || []) r.status === 'rejected' && o(r.reason)
      return t().catch(o)
    })
  }
let Fi, Ni
function dx() {
  return (
    (Fi = $fetch(Mc(`builds/meta/${ei().app.buildId}.json`), { responseType: 'json' })),
    Fi.then((e) => {
      Ni = fC(e.matcher)
    }).catch((e) => {
      console.error('[nuxt] Error fetching app manifest.', e)
    }),
    Fi
  )
}
function Dr() {
  return Fi || dx()
}
async function Lc(e) {
  const t = typeof e == 'string' ? e : e.path
  if ((await Dr(), !Ni))
    return (console.error('[nuxt] Error creating app manifest matcher.', Ni), {})
  try {
    return Cg({}, ...Ni.matchAll(t).reverse())
  } catch (n) {
    return (console.error('[nuxt] Error matching route rules.', n), {})
  }
}
async function Qf(e, t = {}) {
  if (!(await Eg(e))) return null
  const a = await vx(e, t)
  return (await Ag(a)) || null
}
const fx = '_payload.json'
async function vx(e, t = {}) {
  const n = new URL(e, 'http://localhost')
  if (n.host !== 'localhost' || ca(n.pathname, { acceptRelative: !0 }))
    throw new Error('Payload URL must not include hostname: ' + e)
  const a = ei(),
    l = t.hash || (t.fresh ? Date.now() : a.app.buildId),
    o = a.app.cdnURL,
    i = o && (await Eg(e)) ? o : a.app.baseURL
  return Tr(i, n.pathname, fx + (l ? `?${l}` : ''))
}
async function Ag(e) {
  const t = fetch(e, { cache: 'force-cache' }).then((n) => n.text().then(Dg))
  try {
    return await t
  } catch (n) {
    console.warn('[nuxt] Cannot load payload ', e, n)
  }
  return null
}
async function Eg(e = _g().path) {
  const t = ht()
  return (
    (e = $l(e)),
    (await Dr()).prerendered.includes(e)
      ? !0
      : t.runWithContext(async () => {
          const a = await Lc({ path: e })
          return !!a.prerender && !a.redirect
        })
  )
}
let Ra = null
async function mx() {
  if (Ra) return Ra
  const e = document.getElementById('__NUXT_DATA__')
  if (!e) return {}
  const t = await Dg(e.textContent || ''),
    n = e.dataset.src ? await Ag(e.dataset.src) : void 0
  return (
    (Ra = { ...t, ...n, ...window.__NUXT__ }),
    Ra.config?.public && (Ra.config.public = it(Ra.config.public)),
    Ra
  )
}
async function Dg(e) {
  return await EC(e, ht()._payloadRevivers)
}
function hx(e, t) {
  ht()._payloadRevivers[e] = t
}
const gx = [
    ['NuxtError', (e) => za(e)],
    ['EmptyShallowRef', (e) => oe(e === '_' ? void 0 : e === '0n' ? BigInt(0) : nr(e))],
    ['EmptyRef', (e) => ae(e === '_' ? void 0 : e === '0n' ? BigInt(0) : nr(e))],
    ['ShallowRef', (e) => oe(e)],
    ['ShallowReactive', (e) => ea(e)],
    ['Ref', (e) => ae(e)],
    ['Reactive', (e) => it(e)],
  ],
  yx = zn({
    name: 'nuxt:revive-payload:client',
    order: -30,
    async setup(e) {
      let t, n
      for (const [a, l] of gx) hx(a, l)
      ;(Object.assign(
        e.payload,
        (([t, n] = Ml(() => e.runWithContext(mx))), (t = await t), n(), t)
      ),
        (window.__NUXT__ = e.payload))
    },
  })
async function Oc(e, t = {}) {
  const n = t.document || e.resolvedOptions.document
  if (!n || !e.dirty) return
  const a = { shouldRender: !0, tags: [] }
  if ((await e.hooks.callHook('dom:beforeRender', a), !!a.shouldRender))
    return (
      e._domUpdatePromise ||
        (e._domUpdatePromise = new Promise(async (l) => {
          const o = new Map(),
            i = new Promise((v) => {
              e.resolveTags().then((g) => {
                v(
                  g.map((h) => {
                    const m = o.get(h._d) || 0,
                      b = { tag: h, id: (m ? `${h._d}:${m}` : h._d) || Gf(h), shouldRender: !0 }
                    return (h._d && Ig(h._d) && o.set(h._d, m + 1), b)
                  })
                )
              })
            })
          let r = e._dom
          if (!r) {
            r = {
              title: n.title,
              elMap: new Map().set('htmlAttrs', n.documentElement).set('bodyAttrs', n.body),
            }
            for (const v of ['body', 'head']) {
              const g = n[v]?.children
              for (const h of g) {
                const m = h.tagName.toLowerCase()
                if (!Kf.has(m)) continue
                const b = Tg(
                  { tag: m, props: {} },
                  {
                    innerHTML: h.innerHTML,
                    ...(h
                      .getAttributeNames()
                      .reduce((y, p) => ((y[p] = h.getAttribute(p)), y), {}) || {}),
                  }
                )
                if (
                  ((b.key = h.getAttribute('data-hid') || void 0),
                  (b._d = du(b) || Gf(b)),
                  r.elMap.has(b._d))
                ) {
                  let y = 1,
                    p = b._d
                  for (; r.elMap.has(p); ) p = `${b._d}:${y++}`
                  r.elMap.set(p, h)
                } else r.elMap.set(b._d, h)
              }
            }
          }
          ;((r.pendingSideEffects = { ...r.sideEffects }), (r.sideEffects = {}))
          function s(v, g, h) {
            const m = `${v}:${g}`
            ;((r.sideEffects[m] = h), delete r.pendingSideEffects[m])
          }
          function c({ id: v, $el: g, tag: h }) {
            const m = h.tag.endsWith('Attrs')
            ;(r.elMap.set(v, g),
              m ||
                (h.textContent &&
                  h.textContent !== g.textContent &&
                  (g.textContent = h.textContent),
                h.innerHTML && h.innerHTML !== g.innerHTML && (g.innerHTML = h.innerHTML),
                s(v, 'el', () => {
                  ;(g?.remove(), r.elMap.delete(v))
                })))
            for (const b in h.props) {
              if (!Object.prototype.hasOwnProperty.call(h.props, b)) continue
              const y = h.props[b]
              if (b.startsWith('on') && typeof y == 'function') {
                const S = g?.dataset
                if (S && S[`${b}fired`]) {
                  const k = b.slice(0, -5)
                  y.call(g, new Event(k.substring(2)))
                }
                g.getAttribute(`data-${b}`) !== '' &&
                  ((h.tag === 'bodyAttrs' ? n.defaultView : g).addEventListener(
                    b.substring(2),
                    y.bind(g)
                  ),
                  g.setAttribute(`data-${b}`, ''))
                continue
              }
              const p = `attr:${b}`
              if (b === 'class') {
                if (!y) continue
                for (const S of y)
                  (m && s(v, `${p}:${S}`, () => g.classList.remove(S)),
                    !g.classList.contains(S) && g.classList.add(S))
              } else if (b === 'style') {
                if (!y) continue
                for (const [S, k] of y)
                  (s(v, `${p}:${S}`, () => {
                    g.style.removeProperty(S)
                  }),
                    g.style.setProperty(S, k))
              } else
                y !== !1 &&
                  y !== null &&
                  (g.getAttribute(b) !== y && g.setAttribute(b, y === !0 ? '' : String(y)),
                  m && s(v, p, () => g.removeAttribute(b)))
            }
          }
          const u = [],
            d = { bodyClose: void 0, bodyOpen: void 0, head: void 0 },
            f = await i
          for (const v of f) {
            const { tag: g, shouldRender: h, id: m } = v
            if (h) {
              if (g.tag === 'title') {
                ;((n.title = g.textContent), s('title', '', () => (n.title = r.title)))
                continue
              }
              ;((v.$el = v.$el || r.elMap.get(m)), v.$el ? c(v) : Kf.has(g.tag) && u.push(v))
            }
          }
          for (const v of u) {
            const g = v.tag.tagPosition || 'head'
            ;((v.$el = n.createElement(v.tag.tag)),
              c(v),
              (d[g] = d[g] || n.createDocumentFragment()),
              d[g].appendChild(v.$el))
          }
          for (const v of f) await e.hooks.callHook('dom:renderTag', v, n, s)
          ;(d.head && n.head.appendChild(d.head),
            d.bodyOpen && n.body.insertBefore(d.bodyOpen, n.body.firstChild),
            d.bodyClose && n.body.appendChild(d.bodyClose))
          for (const v in r.pendingSideEffects) r.pendingSideEffects[v]()
          ;((e._dom = r), await e.hooks.callHook('dom:rendered', { renders: f }), l())
        }).finally(() => {
          ;((e._domUpdatePromise = void 0), (e.dirty = !1))
        })),
      e._domUpdatePromise
    )
}
function bx(e = {}) {
  const t = e.domOptions?.render || Oc
  e.document = e.document || (typeof window < 'u' ? document : void 0)
  const n = e.document?.head.querySelector('script[id="unhead:payload"]')?.innerHTML || !1
  return YC({
    ...e,
    plugins: [...(e.plugins || []), { key: 'client', hooks: { 'entries:updated': t } }],
    init: [n ? JSON.parse(n) : !1, ...(e.init || [])],
  })
}
function px(e, t) {
  let n = 0
  return () => {
    const a = ++n
    t(() => {
      n === a && e()
    })
  }
}
function Sx(e = {}) {
  const t = bx({
    domOptions: {
      render: px(
        () => Oc(t),
        (n) => setTimeout(n, 0)
      ),
    },
    ...e,
  })
  return ((t.install = ax(t)), t)
}
const wx = { disableDefaults: !0, disableCapoSorting: !1, plugins: [ZC, JC, tx, XC] },
  kx = zn({
    name: 'nuxt:head',
    enforce: 'pre',
    setup(e) {
      const t = Sx(wx)
      e.vueApp.use(t)
      {
        let n = !0
        const a = async () => {
          ;((n = !1), await Oc(t))
        }
        ;(t.hooks.hook('dom:beforeRender', (l) => {
          l.shouldRender = !n
        }),
          e.hooks.hook('page:start', () => {
            n = !0
          }),
          e.hooks.hook('page:finish', () => {
            e.isHydrating || a()
          }),
          e.hooks.hook('app:error', a),
          e.hooks.hook('app:suspense:resolve', a))
      }
    },
  })
/*!
 * vue-router v4.5.1
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */ const Cl = typeof document < 'u'
function Rg(e) {
  return typeof e == 'object' || 'displayName' in e || 'props' in e || '__vccOpts' in e
}
function Cx(e) {
  return e.__esModule || e[Symbol.toStringTag] === 'Module' || (e.default && Rg(e.default))
}
const We = Object.assign
function xs(e, t) {
  const n = {}
  for (const a in t) {
    const l = t[a]
    n[a] = Cn(l) ? l.map(e) : e(l)
  }
  return n
}
const Co = () => {},
  Cn = Array.isArray,
  Mg = /#/g,
  xx = /&/g,
  _x = /\//g,
  Px = /=/g,
  Vx = /\?/g,
  Bg = /\+/g,
  Ix = /%5B/g,
  Tx = /%5D/g,
  Lg = /%5E/g,
  Ax = /%60/g,
  Og = /%7B/g,
  Ex = /%7C/g,
  $g = /%7D/g,
  Dx = /%20/g
function $c(e) {
  return encodeURI('' + e)
    .replace(Ex, '|')
    .replace(Ix, '[')
    .replace(Tx, ']')
}
function Rx(e) {
  return $c(e).replace(Og, '{').replace($g, '}').replace(Lg, '^')
}
function mu(e) {
  return $c(e)
    .replace(Bg, '%2B')
    .replace(Dx, '+')
    .replace(Mg, '%23')
    .replace(xx, '%26')
    .replace(Ax, '`')
    .replace(Og, '{')
    .replace($g, '}')
    .replace(Lg, '^')
}
function Mx(e) {
  return mu(e).replace(Px, '%3D')
}
function Bx(e) {
  return $c(e).replace(Mg, '%23').replace(Vx, '%3F')
}
function Lx(e) {
  return e == null ? '' : Bx(e).replace(_x, '%2F')
}
function Ao(e) {
  try {
    return decodeURIComponent('' + e)
  } catch {}
  return '' + e
}
const Ox = /\/$/,
  $x = (e) => e.replace(Ox, '')
function _s(e, t, n = '/') {
  let a,
    l = {},
    o = '',
    i = ''
  const r = t.indexOf('#')
  let s = t.indexOf('?')
  return (
    r < s && r >= 0 && (s = -1),
    s > -1 && ((a = t.slice(0, s)), (o = t.slice(s + 1, r > -1 ? r : t.length)), (l = e(o))),
    r > -1 && ((a = a || t.slice(0, r)), (i = t.slice(r, t.length))),
    (a = jx(a ?? t, n)),
    { fullPath: a + (o && '?') + o + i, path: a, query: l, hash: Ao(i) }
  )
}
function Fx(e, t) {
  const n = t.query ? e(t.query) : ''
  return t.path + (n && '?') + n + (t.hash || '')
}
function ev(e, t) {
  return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || '/'
}
function Nx(e, t, n) {
  const a = t.matched.length - 1,
    l = n.matched.length - 1
  return (
    a > -1 &&
    a === l &&
    Fl(t.matched[a], n.matched[l]) &&
    Fg(t.params, n.params) &&
    e(t.query) === e(n.query) &&
    t.hash === n.hash
  )
}
function Fl(e, t) {
  return (e.aliasOf || e) === (t.aliasOf || t)
}
function Fg(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length) return !1
  for (const n in e) if (!Hx(e[n], t[n])) return !1
  return !0
}
function Hx(e, t) {
  return Cn(e) ? tv(e, t) : Cn(t) ? tv(t, e) : e === t
}
function tv(e, t) {
  return Cn(t)
    ? e.length === t.length && e.every((n, a) => n === t[a])
    : e.length === 1 && e[0] === t
}
function jx(e, t) {
  if (e.startsWith('/')) return e
  if (!e) return t
  const n = t.split('/'),
    a = e.split('/'),
    l = a[a.length - 1]
  ;(l === '..' || l === '.') && a.push('')
  let o = n.length - 1,
    i,
    r
  for (i = 0; i < a.length; i++)
    if (((r = a[i]), r !== '.'))
      if (r === '..') o > 1 && o--
      else break
  return n.slice(0, o).join('/') + '/' + a.slice(i).join('/')
}
const fn = {
  path: '/',
  name: void 0,
  params: {},
  query: {},
  hash: '',
  fullPath: '/',
  matched: [],
  meta: {},
  redirectedFrom: void 0,
}
var Eo
;(function (e) {
  ;((e.pop = 'pop'), (e.push = 'push'))
})(Eo || (Eo = {}))
var xo
;(function (e) {
  ;((e.back = 'back'), (e.forward = 'forward'), (e.unknown = ''))
})(xo || (xo = {}))
function zx(e) {
  if (!e)
    if (Cl) {
      const t = document.querySelector('base')
      ;((e = (t && t.getAttribute('href')) || '/'), (e = e.replace(/^\w+:\/\/[^\/]+/, '')))
    } else e = '/'
  return (e[0] !== '/' && e[0] !== '#' && (e = '/' + e), $x(e))
}
const Wx = /^[^#]+#/
function Ux(e, t) {
  return e.replace(Wx, '#') + t
}
function Kx(e, t) {
  const n = document.documentElement.getBoundingClientRect(),
    a = e.getBoundingClientRect()
  return {
    behavior: t.behavior,
    left: a.left - n.left - (t.left || 0),
    top: a.top - n.top - (t.top || 0),
  }
}
const Rr = () => ({ left: window.scrollX, top: window.scrollY })
function Gx(e) {
  let t
  if ('el' in e) {
    const n = e.el,
      a = typeof n == 'string' && n.startsWith('#'),
      l =
        typeof n == 'string'
          ? a
            ? document.getElementById(n.slice(1))
            : document.querySelector(n)
          : n
    if (!l) return
    t = Kx(l, e)
  } else t = e
  'scrollBehavior' in document.documentElement.style
    ? window.scrollTo(t)
    : window.scrollTo(
        t.left != null ? t.left : window.scrollX,
        t.top != null ? t.top : window.scrollY
      )
}
function nv(e, t) {
  return (history.state ? history.state.position - t : -1) + e
}
const hu = new Map()
function Yx(e, t) {
  hu.set(e, t)
}
function qx(e) {
  const t = hu.get(e)
  return (hu.delete(e), t)
}
let Xx = () => location.protocol + '//' + location.host
function Ng(e, t) {
  const { pathname: n, search: a, hash: l } = t,
    o = e.indexOf('#')
  if (o > -1) {
    let r = l.includes(e.slice(o)) ? e.slice(o).length : 1,
      s = l.slice(r)
    return (s[0] !== '/' && (s = '/' + s), ev(s, ''))
  }
  return ev(n, e) + a + l
}
function Zx(e, t, n, a) {
  let l = [],
    o = [],
    i = null
  const r = ({ state: f }) => {
    const v = Ng(e, location),
      g = n.value,
      h = t.value
    let m = 0
    if (f) {
      if (((n.value = v), (t.value = f), i && i === g)) {
        i = null
        return
      }
      m = h ? f.position - h.position : 0
    } else a(v)
    l.forEach((b) => {
      b(n.value, g, {
        delta: m,
        type: Eo.pop,
        direction: m ? (m > 0 ? xo.forward : xo.back) : xo.unknown,
      })
    })
  }
  function s() {
    i = n.value
  }
  function c(f) {
    l.push(f)
    const v = () => {
      const g = l.indexOf(f)
      g > -1 && l.splice(g, 1)
    }
    return (o.push(v), v)
  }
  function u() {
    const { history: f } = window
    f.state && f.replaceState(We({}, f.state, { scroll: Rr() }), '')
  }
  function d() {
    for (const f of o) f()
    ;((o = []),
      window.removeEventListener('popstate', r),
      window.removeEventListener('beforeunload', u))
  }
  return (
    window.addEventListener('popstate', r),
    window.addEventListener('beforeunload', u, { passive: !0 }),
    { pauseListeners: s, listen: c, destroy: d }
  )
}
function av(e, t, n, a = !1, l = !1) {
  return {
    back: e,
    current: t,
    forward: n,
    replaced: a,
    position: window.history.length,
    scroll: l ? Rr() : null,
  }
}
function Jx(e) {
  const { history: t, location: n } = window,
    a = { value: Ng(e, n) },
    l = { value: t.state }
  l.value ||
    o(
      a.value,
      {
        back: null,
        current: a.value,
        forward: null,
        position: t.length - 1,
        replaced: !0,
        scroll: null,
      },
      !0
    )
  function o(s, c, u) {
    const d = e.indexOf('#'),
      f = d > -1 ? (n.host && document.querySelector('base') ? e : e.slice(d)) + s : Xx() + e + s
    try {
      ;(t[u ? 'replaceState' : 'pushState'](c, '', f), (l.value = c))
    } catch (v) {
      ;(console.error(v), n[u ? 'replace' : 'assign'](f))
    }
  }
  function i(s, c) {
    const u = We({}, t.state, av(l.value.back, s, l.value.forward, !0), c, {
      position: l.value.position,
    })
    ;(o(s, u, !0), (a.value = s))
  }
  function r(s, c) {
    const u = We({}, l.value, t.state, { forward: s, scroll: Rr() })
    o(u.current, u, !0)
    const d = We({}, av(a.value, s, null), { position: u.position + 1 }, c)
    ;(o(s, d, !1), (a.value = s))
  }
  return { location: a, state: l, push: r, replace: i }
}
function Qx(e) {
  e = zx(e)
  const t = Jx(e),
    n = Zx(e, t.state, t.location, t.replace)
  function a(o, i = !0) {
    ;(i || n.pauseListeners(), history.go(o))
  }
  const l = We({ location: '', base: e, go: a, createHref: Ux.bind(null, e) }, t, n)
  return (
    Object.defineProperty(l, 'location', { enumerable: !0, get: () => t.location.value }),
    Object.defineProperty(l, 'state', { enumerable: !0, get: () => t.state.value }),
    l
  )
}
function e_(e) {
  return typeof e == 'string' || (e && typeof e == 'object')
}
function Hg(e) {
  return typeof e == 'string' || typeof e == 'symbol'
}
const jg = Symbol('')
var lv
;(function (e) {
  ;((e[(e.aborted = 4)] = 'aborted'),
    (e[(e.cancelled = 8)] = 'cancelled'),
    (e[(e.duplicated = 16)] = 'duplicated'))
})(lv || (lv = {}))
function Nl(e, t) {
  return We(new Error(), { type: e, [jg]: !0 }, t)
}
function Gn(e, t) {
  return e instanceof Error && jg in e && (t == null || !!(e.type & t))
}
const ov = '[^/]+?',
  t_ = { sensitive: !1, strict: !1, start: !0, end: !0 },
  n_ = /[.+*?^${}()[\]/\\]/g
function a_(e, t) {
  const n = We({}, t_, t),
    a = []
  let l = n.start ? '^' : ''
  const o = []
  for (const c of e) {
    const u = c.length ? [] : [90]
    n.strict && !c.length && (l += '/')
    for (let d = 0; d < c.length; d++) {
      const f = c[d]
      let v = 40 + (n.sensitive ? 0.25 : 0)
      if (f.type === 0) (d || (l += '/'), (l += f.value.replace(n_, '\\$&')), (v += 40))
      else if (f.type === 1) {
        const { value: g, repeatable: h, optional: m, regexp: b } = f
        o.push({ name: g, repeatable: h, optional: m })
        const y = b || ov
        if (y !== ov) {
          v += 10
          try {
            new RegExp(`(${y})`)
          } catch (S) {
            throw new Error(`Invalid custom RegExp for param "${g}" (${y}): ` + S.message)
          }
        }
        let p = h ? `((?:${y})(?:/(?:${y}))*)` : `(${y})`
        ;(d || (p = m && c.length < 2 ? `(?:/${p})` : '/' + p),
          m && (p += '?'),
          (l += p),
          (v += 20),
          m && (v += -8),
          h && (v += -20),
          y === '.*' && (v += -50))
      }
      u.push(v)
    }
    a.push(u)
  }
  if (n.strict && n.end) {
    const c = a.length - 1
    a[c][a[c].length - 1] += 0.7000000000000001
  }
  ;(n.strict || (l += '/?'), n.end ? (l += '$') : n.strict && !l.endsWith('/') && (l += '(?:/|$)'))
  const i = new RegExp(l, n.sensitive ? '' : 'i')
  function r(c) {
    const u = c.match(i),
      d = {}
    if (!u) return null
    for (let f = 1; f < u.length; f++) {
      const v = u[f] || '',
        g = o[f - 1]
      d[g.name] = v && g.repeatable ? v.split('/') : v
    }
    return d
  }
  function s(c) {
    let u = '',
      d = !1
    for (const f of e) {
      ;((!d || !u.endsWith('/')) && (u += '/'), (d = !1))
      for (const v of f)
        if (v.type === 0) u += v.value
        else if (v.type === 1) {
          const { value: g, repeatable: h, optional: m } = v,
            b = g in c ? c[g] : ''
          if (Cn(b) && !h)
            throw new Error(
              `Provided param "${g}" is an array but it is not repeatable (* or + modifiers)`
            )
          const y = Cn(b) ? b.join('/') : b
          if (!y)
            if (m) f.length < 2 && (u.endsWith('/') ? (u = u.slice(0, -1)) : (d = !0))
            else throw new Error(`Missing required param "${g}"`)
          u += y
        }
    }
    return u || '/'
  }
  return { re: i, score: a, keys: o, parse: r, stringify: s }
}
function l_(e, t) {
  let n = 0
  for (; n < e.length && n < t.length; ) {
    const a = t[n] - e[n]
    if (a) return a
    n++
  }
  return e.length < t.length
    ? e.length === 1 && e[0] === 80
      ? -1
      : 1
    : e.length > t.length
      ? t.length === 1 && t[0] === 80
        ? 1
        : -1
      : 0
}
function zg(e, t) {
  let n = 0
  const a = e.score,
    l = t.score
  for (; n < a.length && n < l.length; ) {
    const o = l_(a[n], l[n])
    if (o) return o
    n++
  }
  if (Math.abs(l.length - a.length) === 1) {
    if (iv(a)) return 1
    if (iv(l)) return -1
  }
  return l.length - a.length
}
function iv(e) {
  const t = e[e.length - 1]
  return e.length > 0 && t[t.length - 1] < 0
}
const o_ = { type: 0, value: '' },
  i_ = /[a-zA-Z0-9_]/
function r_(e) {
  if (!e) return [[]]
  if (e === '/') return [[o_]]
  if (!e.startsWith('/')) throw new Error(`Invalid path "${e}"`)
  function t(v) {
    throw new Error(`ERR (${n})/"${c}": ${v}`)
  }
  let n = 0,
    a = n
  const l = []
  let o
  function i() {
    ;(o && l.push(o), (o = []))
  }
  let r = 0,
    s,
    c = '',
    u = ''
  function d() {
    c &&
      (n === 0
        ? o.push({ type: 0, value: c })
        : n === 1 || n === 2 || n === 3
          ? (o.length > 1 &&
              (s === '*' || s === '+') &&
              t(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`),
            o.push({
              type: 1,
              value: c,
              regexp: u,
              repeatable: s === '*' || s === '+',
              optional: s === '*' || s === '?',
            }))
          : t('Invalid state to consume buffer'),
      (c = ''))
  }
  function f() {
    c += s
  }
  for (; r < e.length; ) {
    if (((s = e[r++]), s === '\\' && n !== 2)) {
      ;((a = n), (n = 4))
      continue
    }
    switch (n) {
      case 0:
        s === '/' ? (c && d(), i()) : s === ':' ? (d(), (n = 1)) : f()
        break
      case 4:
        ;(f(), (n = a))
        break
      case 1:
        s === '('
          ? (n = 2)
          : i_.test(s)
            ? f()
            : (d(), (n = 0), s !== '*' && s !== '?' && s !== '+' && r--)
        break
      case 2:
        s === ')' ? (u[u.length - 1] == '\\' ? (u = u.slice(0, -1) + s) : (n = 3)) : (u += s)
        break
      case 3:
        ;(d(), (n = 0), s !== '*' && s !== '?' && s !== '+' && r--, (u = ''))
        break
      default:
        t('Unknown state')
        break
    }
  }
  return (n === 2 && t(`Unfinished custom RegExp for param "${c}"`), d(), i(), l)
}
function s_(e, t, n) {
  const a = a_(r_(e.path), n),
    l = We(a, { record: e, parent: t, children: [], alias: [] })
  return (t && !l.record.aliasOf == !t.record.aliasOf && t.children.push(l), l)
}
function u_(e, t) {
  const n = [],
    a = new Map()
  t = cv({ strict: !1, end: !0, sensitive: !1 }, t)
  function l(d) {
    return a.get(d)
  }
  function o(d, f, v) {
    const g = !v,
      h = sv(d)
    h.aliasOf = v && v.record
    const m = cv(t, d),
      b = [h]
    if ('alias' in d) {
      const S = typeof d.alias == 'string' ? [d.alias] : d.alias
      for (const k of S)
        b.push(
          sv(
            We({}, h, {
              components: v ? v.record.components : h.components,
              path: k,
              aliasOf: v ? v.record : h,
            })
          )
        )
    }
    let y, p
    for (const S of b) {
      const { path: k } = S
      if (f && k[0] !== '/') {
        const _ = f.record.path,
          P = _[_.length - 1] === '/' ? '' : '/'
        S.path = f.record.path + (k && P + k)
      }
      if (
        ((y = s_(S, f, m)),
        v
          ? v.alias.push(y)
          : ((p = p || y), p !== y && p.alias.push(y), g && d.name && !uv(y) && i(d.name)),
        Wg(y) && s(y),
        h.children)
      ) {
        const _ = h.children
        for (let P = 0; P < _.length; P++) o(_[P], y, v && v.children[P])
      }
      v = v || y
    }
    return p
      ? () => {
          i(p)
        }
      : Co
  }
  function i(d) {
    if (Hg(d)) {
      const f = a.get(d)
      f && (a.delete(d), n.splice(n.indexOf(f), 1), f.children.forEach(i), f.alias.forEach(i))
    } else {
      const f = n.indexOf(d)
      f > -1 &&
        (n.splice(f, 1),
        d.record.name && a.delete(d.record.name),
        d.children.forEach(i),
        d.alias.forEach(i))
    }
  }
  function r() {
    return n
  }
  function s(d) {
    const f = f_(d, n)
    ;(n.splice(f, 0, d), d.record.name && !uv(d) && a.set(d.record.name, d))
  }
  function c(d, f) {
    let v,
      g = {},
      h,
      m
    if ('name' in d && d.name) {
      if (((v = a.get(d.name)), !v)) throw Nl(1, { location: d })
      ;((m = v.record.name),
        (g = We(
          rv(
            f.params,
            v.keys
              .filter((p) => !p.optional)
              .concat(v.parent ? v.parent.keys.filter((p) => p.optional) : [])
              .map((p) => p.name)
          ),
          d.params &&
            rv(
              d.params,
              v.keys.map((p) => p.name)
            )
        )),
        (h = v.stringify(g)))
    } else if (d.path != null)
      ((h = d.path),
        (v = n.find((p) => p.re.test(h))),
        v && ((g = v.parse(h)), (m = v.record.name)))
    else {
      if (((v = f.name ? a.get(f.name) : n.find((p) => p.re.test(f.path))), !v))
        throw Nl(1, { location: d, currentLocation: f })
      ;((m = v.record.name), (g = We({}, f.params, d.params)), (h = v.stringify(g)))
    }
    const b = []
    let y = v
    for (; y; ) (b.unshift(y.record), (y = y.parent))
    return { name: m, path: h, params: g, matched: b, meta: d_(b) }
  }
  e.forEach((d) => o(d))
  function u() {
    ;((n.length = 0), a.clear())
  }
  return {
    addRoute: o,
    resolve: c,
    removeRoute: i,
    clearRoutes: u,
    getRoutes: r,
    getRecordMatcher: l,
  }
}
function rv(e, t) {
  const n = {}
  for (const a of t) a in e && (n[a] = e[a])
  return n
}
function sv(e) {
  const t = {
    path: e.path,
    redirect: e.redirect,
    name: e.name,
    meta: e.meta || {},
    aliasOf: e.aliasOf,
    beforeEnter: e.beforeEnter,
    props: c_(e),
    children: e.children || [],
    instances: {},
    leaveGuards: new Set(),
    updateGuards: new Set(),
    enterCallbacks: {},
    components: 'components' in e ? e.components || null : e.component && { default: e.component },
  }
  return (Object.defineProperty(t, 'mods', { value: {} }), t)
}
function c_(e) {
  const t = {},
    n = e.props || !1
  if ('component' in e) t.default = n
  else for (const a in e.components) t[a] = typeof n == 'object' ? n[a] : n
  return t
}
function uv(e) {
  for (; e; ) {
    if (e.record.aliasOf) return !0
    e = e.parent
  }
  return !1
}
function d_(e) {
  return e.reduce((t, n) => We(t, n.meta), {})
}
function cv(e, t) {
  const n = {}
  for (const a in e) n[a] = a in t ? t[a] : e[a]
  return n
}
function f_(e, t) {
  let n = 0,
    a = t.length
  for (; n !== a; ) {
    const o = (n + a) >> 1
    zg(e, t[o]) < 0 ? (a = o) : (n = o + 1)
  }
  const l = v_(e)
  return (l && (a = t.lastIndexOf(l, a - 1)), a)
}
function v_(e) {
  let t = e
  for (; (t = t.parent); ) if (Wg(t) && zg(e, t) === 0) return t
}
function Wg({ record: e }) {
  return !!(e.name || (e.components && Object.keys(e.components).length) || e.redirect)
}
function m_(e) {
  const t = {}
  if (e === '' || e === '?') return t
  const a = (e[0] === '?' ? e.slice(1) : e).split('&')
  for (let l = 0; l < a.length; ++l) {
    const o = a[l].replace(Bg, ' '),
      i = o.indexOf('='),
      r = Ao(i < 0 ? o : o.slice(0, i)),
      s = i < 0 ? null : Ao(o.slice(i + 1))
    if (r in t) {
      let c = t[r]
      ;(Cn(c) || (c = t[r] = [c]), c.push(s))
    } else t[r] = s
  }
  return t
}
function dv(e) {
  let t = ''
  for (let n in e) {
    const a = e[n]
    if (((n = Mx(n)), a == null)) {
      a !== void 0 && (t += (t.length ? '&' : '') + n)
      continue
    }
    ;(Cn(a) ? a.map((o) => o && mu(o)) : [a && mu(a)]).forEach((o) => {
      o !== void 0 && ((t += (t.length ? '&' : '') + n), o != null && (t += '=' + o))
    })
  }
  return t
}
function h_(e) {
  const t = {}
  for (const n in e) {
    const a = e[n]
    a !== void 0 &&
      (t[n] = Cn(a) ? a.map((l) => (l == null ? null : '' + l)) : a == null ? a : '' + a)
  }
  return t
}
const g_ = Symbol(''),
  fv = Symbol(''),
  Fc = Symbol(''),
  Nc = Symbol(''),
  gu = Symbol('')
function fo() {
  let e = []
  function t(a) {
    return (
      e.push(a),
      () => {
        const l = e.indexOf(a)
        l > -1 && e.splice(l, 1)
      }
    )
  }
  function n() {
    e = []
  }
  return { add: t, list: () => e.slice(), reset: n }
}
function Sa(e, t, n, a, l, o = (i) => i()) {
  const i = a && (a.enterCallbacks[l] = a.enterCallbacks[l] || [])
  return () =>
    new Promise((r, s) => {
      const c = (f) => {
          f === !1
            ? s(Nl(4, { from: n, to: t }))
            : f instanceof Error
              ? s(f)
              : e_(f)
                ? s(Nl(2, { from: t, to: f }))
                : (i && a.enterCallbacks[l] === i && typeof f == 'function' && i.push(f), r())
        },
        u = o(() => e.call(a && a.instances[l], t, n, c))
      let d = Promise.resolve(u)
      ;(e.length < 3 && (d = d.then(c)), d.catch((f) => s(f)))
    })
}
function Ps(e, t, n, a, l = (o) => o()) {
  const o = []
  for (const i of e)
    for (const r in i.components) {
      let s = i.components[r]
      if (!(t !== 'beforeRouteEnter' && !i.instances[r]))
        if (Rg(s)) {
          const u = (s.__vccOpts || s)[t]
          u && o.push(Sa(u, n, a, i, r, l))
        } else {
          let c = s()
          o.push(() =>
            c.then((u) => {
              if (!u) throw new Error(`Couldn't resolve component "${r}" at "${i.path}"`)
              const d = Cx(u) ? u.default : u
              ;((i.mods[r] = u), (i.components[r] = d))
              const v = (d.__vccOpts || d)[t]
              return v && Sa(v, n, a, i, r, l)()
            })
          )
        }
    }
  return o
}
function vv(e) {
  const t = Ve(Fc),
    n = Ve(Nc),
    a = C(() => {
      const s = Ke(e.to)
      return t.resolve(s)
    }),
    l = C(() => {
      const { matched: s } = a.value,
        { length: c } = s,
        u = s[c - 1],
        d = n.matched
      if (!u || !d.length) return -1
      const f = d.findIndex(Fl.bind(null, u))
      if (f > -1) return f
      const v = mv(s[c - 2])
      return c > 1 && mv(u) === v && d[d.length - 1].path !== v
        ? d.findIndex(Fl.bind(null, s[c - 2]))
        : f
    }),
    o = C(() => l.value > -1 && w_(n.params, a.value.params)),
    i = C(() => l.value > -1 && l.value === n.matched.length - 1 && Fg(n.params, a.value.params))
  function r(s = {}) {
    if (S_(s)) {
      const c = t[Ke(e.replace) ? 'replace' : 'push'](Ke(e.to)).catch(Co)
      return (
        e.viewTransition &&
          typeof document < 'u' &&
          'startViewTransition' in document &&
          document.startViewTransition(() => c),
        c
      )
    }
    return Promise.resolve()
  }
  return { route: a, href: C(() => a.value.href), isActive: o, isExactActive: i, navigate: r }
}
function y_(e) {
  return e.length === 1 ? e[0] : e
}
const b_ = sa({
    name: 'RouterLink',
    compatConfig: { MODE: 3 },
    props: {
      to: { type: [String, Object], required: !0 },
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String,
      custom: Boolean,
      ariaCurrentValue: { type: String, default: 'page' },
      viewTransition: Boolean,
    },
    useLink: vv,
    setup(e, { slots: t }) {
      const n = it(vv(e)),
        { options: a } = Ve(Fc),
        l = C(() => ({
          [hv(e.activeClass, a.linkActiveClass, 'router-link-active')]: n.isActive,
          [hv(e.exactActiveClass, a.linkExactActiveClass, 'router-link-exact-active')]:
            n.isExactActive,
        }))
      return () => {
        const o = t.default && y_(t.default(n))
        return e.custom
          ? o
          : ut(
              'a',
              {
                'aria-current': n.isExactActive ? e.ariaCurrentValue : null,
                href: n.href,
                onClick: n.navigate,
                class: l.value,
              },
              o
            )
      }
    },
  }),
  p_ = b_
function S_(e) {
  if (
    !(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) &&
    !e.defaultPrevented &&
    !(e.button !== void 0 && e.button !== 0)
  ) {
    if (e.currentTarget && e.currentTarget.getAttribute) {
      const t = e.currentTarget.getAttribute('target')
      if (/\b_blank\b/i.test(t)) return
    }
    return (e.preventDefault && e.preventDefault(), !0)
  }
}
function w_(e, t) {
  for (const n in t) {
    const a = t[n],
      l = e[n]
    if (typeof a == 'string') {
      if (a !== l) return !1
    } else if (!Cn(l) || l.length !== a.length || a.some((o, i) => o !== l[i])) return !1
  }
  return !0
}
function mv(e) {
  return e ? (e.aliasOf ? e.aliasOf.path : e.path) : ''
}
const hv = (e, t, n) => e ?? t ?? n,
  k_ = sa({
    name: 'RouterView',
    inheritAttrs: !1,
    props: { name: { type: String, default: 'default' }, route: Object },
    compatConfig: { MODE: 3 },
    setup(e, { attrs: t, slots: n }) {
      const a = Ve(gu),
        l = C(() => e.route || a.value),
        o = Ve(fv, 0),
        i = C(() => {
          let c = Ke(o)
          const { matched: u } = l.value
          let d
          for (; (d = u[c]) && !d.components; ) c++
          return c
        }),
        r = C(() => l.value.matched[i.value])
      ;(Fe(
        fv,
        C(() => i.value + 1)
      ),
        Fe(g_, r),
        Fe(gu, l))
      const s = ae()
      return (
        ue(
          () => [s.value, r.value, e.name],
          ([c, u, d], [f, v, g]) => {
            ;(u &&
              ((u.instances[d] = c),
              v &&
                v !== u &&
                c &&
                c === f &&
                (u.leaveGuards.size || (u.leaveGuards = v.leaveGuards),
                u.updateGuards.size || (u.updateGuards = v.updateGuards))),
              c && u && (!v || !Fl(u, v) || !f) && (u.enterCallbacks[d] || []).forEach((h) => h(c)))
          },
          { flush: 'post' }
        ),
        () => {
          const c = l.value,
            u = e.name,
            d = r.value,
            f = d && d.components[u]
          if (!f) return gv(n.default, { Component: f, route: c })
          const v = d.props[u],
            g = v ? (v === !0 ? c.params : typeof v == 'function' ? v(c) : v) : null,
            m = ut(
              f,
              We({}, g, t, {
                onVnodeUnmounted: (b) => {
                  b.component.isUnmounted && (d.instances[u] = null)
                },
                ref: s,
              })
            )
          return gv(n.default, { Component: m, route: c }) || m
        }
      )
    },
  })
function gv(e, t) {
  if (!e) return null
  const n = e(t)
  return n.length === 1 ? n[0] : n
}
const Ug = k_
function C_(e) {
  const t = u_(e.routes, e),
    n = e.parseQuery || m_,
    a = e.stringifyQuery || dv,
    l = e.history,
    o = fo(),
    i = fo(),
    r = fo(),
    s = oe(fn)
  let c = fn
  Cl && e.scrollBehavior && 'scrollRestoration' in history && (history.scrollRestoration = 'manual')
  const u = xs.bind(null, (L) => '' + L),
    d = xs.bind(null, Lx),
    f = xs.bind(null, Ao)
  function v(L, q) {
    let le, ie
    return (Hg(L) ? ((le = t.getRecordMatcher(L)), (ie = q)) : (ie = L), t.addRoute(ie, le))
  }
  function g(L) {
    const q = t.getRecordMatcher(L)
    q && t.removeRoute(q)
  }
  function h() {
    return t.getRoutes().map((L) => L.record)
  }
  function m(L) {
    return !!t.getRecordMatcher(L)
  }
  function b(L, q) {
    if (((q = We({}, q || s.value)), typeof L == 'string')) {
      const T = _s(n, L, q.path),
        z = t.resolve({ path: T.path }, q),
        X = l.createHref(T.fullPath)
      return We(T, z, { params: f(z.params), hash: Ao(T.hash), redirectedFrom: void 0, href: X })
    }
    let le
    if (L.path != null) le = We({}, L, { path: _s(n, L.path, q.path).path })
    else {
      const T = We({}, L.params)
      for (const z in T) T[z] == null && delete T[z]
      ;((le = We({}, L, { params: d(T) })), (q.params = d(q.params)))
    }
    const ie = t.resolve(le, q),
      Ce = L.hash || ''
    ie.params = u(f(ie.params))
    const pe = Fx(a, We({}, L, { hash: Rx(Ce), path: ie.path })),
      I = l.createHref(pe)
    return We({ fullPath: pe, hash: Ce, query: a === dv ? h_(L.query) : L.query || {} }, ie, {
      redirectedFrom: void 0,
      href: I,
    })
  }
  function y(L) {
    return typeof L == 'string' ? _s(n, L, s.value.path) : We({}, L)
  }
  function p(L, q) {
    if (c !== L) return Nl(8, { from: q, to: L })
  }
  function S(L) {
    return P(L)
  }
  function k(L) {
    return S(We(y(L), { replace: !0 }))
  }
  function _(L) {
    const q = L.matched[L.matched.length - 1]
    if (q && q.redirect) {
      const { redirect: le } = q
      let ie = typeof le == 'function' ? le(L) : le
      return (
        typeof ie == 'string' &&
          ((ie = ie.includes('?') || ie.includes('#') ? (ie = y(ie)) : { path: ie }),
          (ie.params = {})),
        We({ query: L.query, hash: L.hash, params: ie.path != null ? {} : L.params }, ie)
      )
    }
  }
  function P(L, q) {
    const le = (c = b(L)),
      ie = s.value,
      Ce = L.state,
      pe = L.force,
      I = L.replace === !0,
      T = _(le)
    if (T)
      return P(
        We(y(T), { state: typeof T == 'object' ? We({}, Ce, T.state) : Ce, force: pe, replace: I }),
        q || le
      )
    const z = le
    z.redirectedFrom = q
    let X
    return (
      !pe && Nx(a, ie, le) && ((X = Nl(16, { to: z, from: ie })), U(ie, ie, !0, !1)),
      (X ? Promise.resolve(X) : E(z, ie))
        .catch((N) => (Gn(N) ? (Gn(N, 2) ? N : j(N)) : H(N, z, ie)))
        .then((N) => {
          if (N) {
            if (Gn(N, 2))
              return P(
                We({ replace: I }, y(N.to), {
                  state: typeof N.to == 'object' ? We({}, Ce, N.to.state) : Ce,
                  force: pe,
                }),
                q || z
              )
          } else N = V(z, ie, !0, I, Ce)
          return (R(z, ie, N), N)
        })
    )
  }
  function A(L, q) {
    const le = p(L, q)
    return le ? Promise.reject(le) : Promise.resolve()
  }
  function D(L) {
    const q = se.values().next().value
    return q && typeof q.runWithContext == 'function' ? q.runWithContext(L) : L()
  }
  function E(L, q) {
    let le
    const [ie, Ce, pe] = x_(L, q)
    le = Ps(ie.reverse(), 'beforeRouteLeave', L, q)
    for (const T of ie)
      T.leaveGuards.forEach((z) => {
        le.push(Sa(z, L, q))
      })
    const I = A.bind(null, L, q)
    return (
      le.push(I),
      ye(le)
        .then(() => {
          le = []
          for (const T of o.list()) le.push(Sa(T, L, q))
          return (le.push(I), ye(le))
        })
        .then(() => {
          le = Ps(Ce, 'beforeRouteUpdate', L, q)
          for (const T of Ce)
            T.updateGuards.forEach((z) => {
              le.push(Sa(z, L, q))
            })
          return (le.push(I), ye(le))
        })
        .then(() => {
          le = []
          for (const T of pe)
            if (T.beforeEnter)
              if (Cn(T.beforeEnter)) for (const z of T.beforeEnter) le.push(Sa(z, L, q))
              else le.push(Sa(T.beforeEnter, L, q))
          return (le.push(I), ye(le))
        })
        .then(
          () => (
            L.matched.forEach((T) => (T.enterCallbacks = {})),
            (le = Ps(pe, 'beforeRouteEnter', L, q, D)),
            le.push(I),
            ye(le)
          )
        )
        .then(() => {
          le = []
          for (const T of i.list()) le.push(Sa(T, L, q))
          return (le.push(I), ye(le))
        })
        .catch((T) => (Gn(T, 8) ? T : Promise.reject(T)))
    )
  }
  function R(L, q, le) {
    r.list().forEach((ie) => D(() => ie(L, q, le)))
  }
  function V(L, q, le, ie, Ce) {
    const pe = p(L, q)
    if (pe) return pe
    const I = q === fn,
      T = Cl ? history.state : {}
    ;(le &&
      (ie || I
        ? l.replace(L.fullPath, We({ scroll: I && T && T.scroll }, Ce))
        : l.push(L.fullPath, Ce)),
      (s.value = L),
      U(L, q, le, I),
      j())
  }
  let M
  function F() {
    M ||
      (M = l.listen((L, q, le) => {
        if (!de.listening) return
        const ie = b(L),
          Ce = _(ie)
        if (Ce) {
          P(We(Ce, { replace: !0, force: !0 }), ie).catch(Co)
          return
        }
        c = ie
        const pe = s.value
        ;(Cl && Yx(nv(pe.fullPath, le.delta), Rr()),
          E(ie, pe)
            .catch((I) =>
              Gn(I, 12)
                ? I
                : Gn(I, 2)
                  ? (P(We(y(I.to), { force: !0 }), ie)
                      .then((T) => {
                        Gn(T, 20) && !le.delta && le.type === Eo.pop && l.go(-1, !1)
                      })
                      .catch(Co),
                    Promise.reject())
                  : (le.delta && l.go(-le.delta, !1), H(I, ie, pe))
            )
            .then((I) => {
              ;((I = I || V(ie, pe, !1)),
                I &&
                  (le.delta && !Gn(I, 8)
                    ? l.go(-le.delta, !1)
                    : le.type === Eo.pop && Gn(I, 20) && l.go(-1, !1)),
                R(ie, pe, I))
            })
            .catch(Co))
      }))
  }
  let G = fo(),
    W = fo(),
    te
  function H(L, q, le) {
    j(L)
    const ie = W.list()
    return (ie.length ? ie.forEach((Ce) => Ce(L, q, le)) : console.error(L), Promise.reject(L))
  }
  function O() {
    return te && s.value !== fn
      ? Promise.resolve()
      : new Promise((L, q) => {
          G.add([L, q])
        })
  }
  function j(L) {
    return (te || ((te = !L), F(), G.list().forEach(([q, le]) => (L ? le(L) : q())), G.reset()), L)
  }
  function U(L, q, le, ie) {
    const { scrollBehavior: Ce } = e
    if (!Cl || !Ce) return Promise.resolve()
    const pe =
      (!le && qx(nv(L.fullPath, 0))) ||
      ((ie || !le) && history.state && history.state.scroll) ||
      null
    return Re()
      .then(() => Ce(L, q, pe))
      .then((I) => I && Gx(I))
      .catch((I) => H(I, L, q))
  }
  const Y = (L) => l.go(L)
  let K
  const se = new Set(),
    de = {
      currentRoute: s,
      listening: !0,
      addRoute: v,
      removeRoute: g,
      clearRoutes: t.clearRoutes,
      hasRoute: m,
      getRoutes: h,
      resolve: b,
      options: e,
      push: S,
      replace: k,
      go: Y,
      back: () => Y(-1),
      forward: () => Y(1),
      beforeEach: o.add,
      beforeResolve: i.add,
      afterEach: r.add,
      onError: W.add,
      isReady: O,
      install(L) {
        const q = this
        ;(L.component('RouterLink', p_),
          L.component('RouterView', Ug),
          (L.config.globalProperties.$router = q),
          Object.defineProperty(L.config.globalProperties, '$route', {
            enumerable: !0,
            get: () => Ke(s),
          }),
          Cl && !K && s.value === fn && ((K = !0), S(l.location).catch((Ce) => {})))
        const le = {}
        for (const Ce in fn)
          Object.defineProperty(le, Ce, { get: () => s.value[Ce], enumerable: !0 })
        ;(L.provide(Fc, q), L.provide(Nc, ea(le)), L.provide(gu, s))
        const ie = L.unmount
        ;(se.add(L),
          (L.unmount = function () {
            ;(se.delete(L),
              se.size < 1 && ((c = fn), M && M(), (M = null), (s.value = fn), (K = !1), (te = !1)),
              ie())
          }))
      },
    }
  function ye(L) {
    return L.reduce((q, le) => q.then(() => D(le)), Promise.resolve())
  }
  return de
}
function x_(e, t) {
  const n = [],
    a = [],
    l = [],
    o = Math.max(t.matched.length, e.matched.length)
  for (let i = 0; i < o; i++) {
    const r = t.matched[i]
    r && (e.matched.find((c) => Fl(c, r)) ? a.push(r) : n.push(r))
    const s = e.matched[i]
    s && (t.matched.find((c) => Fl(c, s)) || l.push(s))
  }
  return [n, a, l]
}
function CM(e) {
  return Ve(Nc)
}
const __ = /(:\w+)\([^)]+\)/g,
  P_ = /(:\w+)[?+*]/g,
  V_ = /:\w+/g,
  I_ = (e, t) =>
    t.path
      .replace(__, '$1')
      .replace(P_, '$1')
      .replace(V_, (n) => e.params[n.slice(1)]?.toString() || ''),
  yu = (e, t) => {
    const n = e.route.matched.find((l) => l.components?.default === e.Component.type),
      a = t ?? n?.meta.key ?? (n && I_(e.route, n))
    return typeof a == 'function' ? a(e.route) : a
  },
  T_ = (e, t) => ({ default: () => (e ? ut(xw, e === !0 ? {} : e, t) : t) })
function Hc(e) {
  return Array.isArray(e) ? e : [e]
}
const Vs = [
    {
      name: 'index',
      path: '/',
      component: () => $i(() => import('./C-xm6lig.js'), [], import.meta.url),
    },
    {
      name: 'courses-id',
      path: '/courses/:id()',
      component: () => $i(() => import('./D1rZgGeg.js'), __vite__mapDeps([0, 1]), import.meta.url),
    },
    {
      name: 'courses',
      path: '/courses',
      component: () =>
        $i(() => import('./DwVttesH.js'), __vite__mapDeps([2, 1, 3]), import.meta.url),
    },
  ],
  A_ = (e, t) => ({ default: () => (e ? ut(la, e === !0 ? {} : e, t) : t.default?.()) }),
  E_ = /(:\w+)\([^)]+\)/g,
  D_ = /(:\w+)[?+*]/g,
  R_ = /:\w+/g
function yv(e) {
  const t =
    e?.meta.key ??
    e.path
      .replace(E_, '$1')
      .replace(D_, '$1')
      .replace(R_, (n) => e.params[n.slice(1)]?.toString() || '')
  return typeof t == 'function' ? t(e) : t
}
function M_(e, t) {
  return e === t || t === fn
    ? !1
    : yv(e) !== yv(t)
      ? !0
      : !e.matched.every(
          (a, l) => a.components && a.components.default === t.matched[l]?.components?.default
        )
}
const B_ = {
  scrollBehavior(e, t, n) {
    const a = ht(),
      l = Xt().options?.scrollBehaviorType ?? 'auto'
    if (e.path === t.path)
      return t.hash && !e.hash
        ? { left: 0, top: 0 }
        : e.hash
          ? { el: e.hash, top: Kg(e.hash), behavior: l }
          : !1
    if (
      (typeof e.meta.scrollToTop == 'function' ? e.meta.scrollToTop(e, t) : e.meta.scrollToTop) ===
      !1
    )
      return !1
    const i = a._runningTransition ? 'page:transition:finish' : 'page:loading:end'
    return new Promise((r) => {
      if (t === fn) {
        r(bv(e, t, n, l))
        return
      }
      a.hooks.hookOnce(i, () => {
        requestAnimationFrame(() => r(bv(e, t, n, l)))
      })
    })
  },
}
function Kg(e) {
  try {
    const t = document.querySelector(e)
    if (t)
      return (
        (Number.parseFloat(getComputedStyle(t).scrollMarginTop) || 0) +
        (Number.parseFloat(getComputedStyle(document.documentElement).scrollPaddingTop) || 0)
      )
  } catch {}
  return 0
}
function bv(e, t, n, a) {
  if (n) return n
  const l = M_(e, t)
  return e.hash ? { el: e.hash, top: Kg(e.hash), behavior: l ? a : 'instant' } : { left: 0, top: 0 }
}
const L_ = { hashMode: !1, scrollBehaviorType: 'auto' },
  ga = { ...L_, ...B_ },
  O_ = async (e, t) => {
    let n, a
    if (!e.meta?.validate) return
    const l = (([n, a] = Ml(() => Promise.resolve(e.meta.validate(e)))), (n = await n), a(), n)
    if (l === !0) return
    const o = za({
      fatal: !0,
      statusCode: (l && l.statusCode) || 404,
      statusMessage: (l && l.statusMessage) || `Page Not Found: ${e.fullPath}`,
      data: { path: e.fullPath },
    })
    return (typeof window < 'u' && window.history.pushState({}, '', t.fullPath), o)
  },
  $_ = async (e) => {
    let t, n
    const a = (([t, n] = Ml(() => Lc({ path: e.path }))), (t = await t), n(), t)
    if (a.redirect)
      return ca(a.redirect, { acceptRelative: !0 })
        ? ((window.location.href = a.redirect), !1)
        : a.redirect
  },
  F_ = [O_, $_],
  bu = {}
function N_(e, t, n) {
  const { pathname: a, search: l, hash: o } = t,
    i = e.indexOf('#')
  if (i > -1) {
    const c = o.includes(e.slice(i)) ? e.slice(i).length : 1
    let u = o.slice(c)
    return (u[0] !== '/' && (u = '/' + u), Lf(u, ''))
  }
  const r = Lf(a, e),
    s = !n || _k(r, n) ? r : n
  return s + (s.includes('?') ? '' : l) + o
}
const H_ = zn({
    name: 'nuxt:router',
    enforce: 'pre',
    async setup(e) {
      let t,
        n,
        a = ei().app.baseURL
      const l = ga.history?.(a) ?? Qx(a),
        o = ga.routes ? (([t, n] = Ml(() => ga.routes(Vs))), (t = await t), n(), t ?? Vs) : Vs
      let i
      const r = C_({
        ...ga,
        scrollBehavior: (m, b, y) => {
          if (b === fn) {
            i = y
            return
          }
          if (ga.scrollBehavior) {
            if (
              ((r.options.scrollBehavior = ga.scrollBehavior),
              'scrollRestoration' in window.history)
            ) {
              const p = r.beforeEach(() => {
                ;(p(), (window.history.scrollRestoration = 'manual'))
              })
            }
            return ga.scrollBehavior(m, fn, i || y)
          }
        },
        history: l,
        routes: o,
      })
      ;('scrollRestoration' in window.history && (window.history.scrollRestoration = 'auto'),
        e.vueApp.use(r))
      const s = oe(r.currentRoute.value)
      ;(r.afterEach((m, b) => {
        s.value = b
      }),
        Object.defineProperty(e.vueApp.config.globalProperties, 'previousRoute', {
          get: () => s.value,
        }))
      const c = N_(a, window.location, e.payload.path),
        u = oe(r.currentRoute.value),
        d = () => {
          u.value = r.currentRoute.value
        }
      ;(e.hook('page:finish', d),
        r.afterEach((m, b) => {
          m.matched[m.matched.length - 1]?.components?.default ===
            b.matched[b.matched.length - 1]?.components?.default && d()
        }))
      const f = {}
      for (const m in u.value)
        Object.defineProperty(f, m, { get: () => u.value[m], enumerable: !0 })
      ;((e._route = ea(f)), (e._middleware ||= { global: [], named: {} }))
      const v = Er()
      r.afterEach(async (m, b, y) => {
        ;(delete e._processingMiddleware,
          !e.isHydrating && v.value && (await e.runWithContext(wC)),
          y && (await e.callHook('page:loading:end')))
      })
      try {
        ;(([t, n] = Ml(() => r.isReady())), await t, n())
      } catch (m) {
        ;(([t, n] = Ml(() => e.runWithContext(() => Oa(m)))), await t, n())
      }
      const g = c !== r.currentRoute.value.fullPath ? r.resolve(c) : r.currentRoute.value
      d()
      const h = e.payload.state._layout
      return (
        r.beforeEach(async (m, b) => {
          ;(await e.callHook('page:loading:start'),
            (m.meta = it(m.meta)),
            e.isHydrating && h && !aa(m.meta.layout) && (m.meta.layout = h),
            (e._processingMiddleware = !0))
          {
            const y = new Set([...F_, ...e._middleware.global])
            for (const p of m.matched) {
              const S = p.meta.middleware
              if (S) for (const k of Hc(S)) y.add(k)
            }
            {
              const p = await e.runWithContext(() => Lc({ path: m.path }))
              if (p.appMiddleware)
                for (const S in p.appMiddleware) p.appMiddleware[S] ? y.add(S) : y.delete(S)
            }
            for (const p of y) {
              const S =
                typeof p == 'string'
                  ? e._middleware.named[p] || (await bu[p]?.().then((k) => k.default || k))
                  : p
              if (!S) throw new Error(`Unknown route middleware: '${p}'.`)
              try {
                const k = await e.runWithContext(() => S(m, b))
                if (
                  !e.payload.serverRendered &&
                  e.isHydrating &&
                  (k === !1 || k instanceof Error)
                ) {
                  const _ = k || za({ statusCode: 404, statusMessage: `Page Not Found: ${c}` })
                  return (await e.runWithContext(() => Oa(_)), !1)
                }
                if (k === !0) continue
                if (k === !1) return k
                if (k) return (Vg(k) && k.fatal && (await e.runWithContext(() => Oa(k))), k)
              } catch (k) {
                const _ = za(k)
                return (_.fatal && (await e.runWithContext(() => Oa(_))), _)
              }
            }
          }
        }),
        r.onError(async () => {
          ;(delete e._processingMiddleware, await e.callHook('page:loading:end'))
        }),
        r.afterEach((m) => {
          if (m.matched.length === 0)
            return e.runWithContext(() =>
              Oa(
                za({
                  statusCode: 404,
                  fatal: !1,
                  statusMessage: `Page not found: ${m.fullPath}`,
                  data: { path: m.fullPath },
                })
              )
            )
        }),
        e.hooks.hookOnce('app:created', async () => {
          try {
            ;('name' in g && (g.name = void 0),
              await r.replace({ ...g, force: !0 }),
              (r.options.scrollBehavior = ga.scrollBehavior))
          } catch (m) {
            await e.runWithContext(() => Oa(m))
          }
        }),
        { provide: { router: r } }
      )
    },
  }),
  pu =
    globalThis.requestIdleCallback ||
    ((e) => {
      const t = Date.now(),
        n = { didTimeout: !1, timeRemaining: () => Math.max(0, 50 - (Date.now() - t)) }
      return setTimeout(() => {
        e(n)
      }, 1)
    }),
  j_ =
    globalThis.cancelIdleCallback ||
    ((e) => {
      clearTimeout(e)
    }),
  Mr = (e) => {
    const t = ht()
    t.isHydrating
      ? t.hooks.hookOnce('app:suspense:resolve', () => {
          pu(() => e())
        })
      : pu(() => e())
  },
  z_ = zn({
    name: 'nuxt:payload',
    setup(e) {
      const t = new Set()
      ;(Xt().beforeResolve(async (n, a) => {
        if (n.path === a.path) return
        const l = await Qf(n.path)
        if (l) {
          for (const o of t) delete e.static.data[o]
          for (const o in l.data) (o in e.static.data || t.add(o), (e.static.data[o] = l.data[o]))
        }
      }),
        Mr(() => {
          ;(e.hooks.hook('link:prefetch', async (n) => {
            const { hostname: a } = new URL(n, window.location.href)
            a === window.location.hostname &&
              (await Qf(n).catch(() => {
                console.warn('[nuxt] Error preloading payload for', n)
              }))
          }),
            navigator.connection?.effectiveType !== 'slow-2g' && setTimeout(Dr, 1e3))
        }))
    },
  }),
  W_ = zn(() => {
    const e = Xt()
    Mr(() => {
      e.beforeResolve(async () => {
        await new Promise((t) => {
          ;(setTimeout(t, 100),
            requestAnimationFrame(() => {
              setTimeout(t, 0)
            }))
        })
      })
    })
  }),
  U_ = zn((e) => {
    let t
    async function n() {
      let a
      try {
        a = await Dr()
      } catch (l) {
        const o = l
        if (!('status' in o && (o.status === 404 || o.status === 403))) throw o
      }
      ;(t && clearTimeout(t), (t = setTimeout(n, jf)))
      try {
        const l = await $fetch(Mc('builds/latest.json') + `?${Date.now()}`)
        l.id !== a?.id && (e.hooks.callHook('app:manifest:update', l), t && clearTimeout(t))
      } catch {}
    }
    Mr(() => {
      t = setTimeout(n, jf)
    })
  })
function K_(e = {}) {
  const t = e.path || window.location.pathname
  let n = {}
  try {
    n = nr(sessionStorage.getItem('nuxt:reload') || '{}')
  } catch {}
  if (e.force || n?.path !== t || n?.expires < Date.now()) {
    try {
      sessionStorage.setItem(
        'nuxt:reload',
        JSON.stringify({ path: t, expires: Date.now() + (e.ttl ?? 1e4) })
      )
    } catch {}
    if (e.persistState)
      try {
        sessionStorage.setItem('nuxt:reload:state', JSON.stringify({ state: ht().payload.state }))
      } catch {}
    window.location.pathname !== t ? (window.location.href = t) : window.location.reload()
  }
}
const G_ = zn({
    name: 'nuxt:chunk-reload',
    setup(e) {
      const t = Xt(),
        n = ei(),
        a = new Set()
      ;(t.beforeEach(() => {
        a.clear()
      }),
        e.hook('app:chunkError', ({ error: o }) => {
          a.add(o)
        }))
      function l(o) {
        const i = Tr(n.app.baseURL, o.fullPath)
        K_({ path: i, persistState: !0 })
      }
      ;(e.hook('app:manifest:update', () => {
        t.beforeResolve(l)
      }),
        t.onError((o, i) => {
          a.has(o) && l(i)
        }))
    },
  }),
  Y_ = zn({ name: 'nuxt:global-components' }),
  Pi = {
    default: kw(() =>
      $i(() => import('./_z9-3EAc.js'), [], import.meta.url).then((e) => e.default || e)
    ),
  }
function q_(e) {
  if (e?.__asyncLoader && !e.__asyncResolved) return e.__asyncLoader()
}
async function Gg(e, t = Xt()) {
  const { path: n, matched: a } = t.resolve(e)
  if (!a.length || ((t._routePreloaded ||= new Set()), t._routePreloaded.has(n))) return
  const l = (t._preloadPromises ||= [])
  if (l.length > 4) return Promise.all(l).then(() => Gg(e, t))
  t._routePreloaded.add(n)
  for (const o of a) {
    const i = o.components?.default
    if (typeof i != 'function') continue
    const r = Promise.resolve(i())
      .catch(() => {})
      .finally(() => l.splice(l.indexOf(r)))
    l.push(r)
  }
  await Promise.all(l)
}
const X_ = zn({
  name: 'nuxt:prefetch',
  setup(e) {
    const t = Xt()
    ;(e.hooks.hook('app:mounted', () => {
      t.beforeEach(async (n) => {
        const a = n?.meta?.layout
        a && typeof Pi[a] == 'function' && (await Pi[a]())
      })
    }),
      e.hooks.hook('link:prefetch', (n) => {
        if (ca(n)) return
        const a = t.resolve(n)
        if (!a) return
        const l = a.meta.layout
        let o = Hc(a.meta.middleware)
        o = o.filter((i) => typeof i == 'string')
        for (const i of o) typeof bu[i] == 'function' && bu[i]()
        typeof l == 'string' && l in Pi && q_(Pi[l])
      }))
  },
})
function Et(e, t) {
  let n
  function a() {
    ;((n = Ya()),
      n.run(() =>
        t.length
          ? t(() => {
              ;(n?.stop(), a())
            })
          : t()
      ))
  }
  ;(ue(
    e,
    (l) => {
      l && !n ? a() : l || (n?.stop(), (n = void 0))
    },
    { immediate: !0 }
  ),
    bt(() => {
      n?.stop()
    }))
}
const Ne = typeof window < 'u',
  jc = Ne && 'IntersectionObserver' in window,
  Z_ = Ne && ('ontouchstart' in window || window.navigator.maxTouchPoints > 0),
  pv = Ne && 'EyeDropper' in window,
  zc = Ne && 'matchMedia' in window && typeof window.matchMedia == 'function',
  On = () => zc && window.matchMedia('(prefers-reduced-motion: reduce)').matches
function Sv(e, t, n) {
  ;(J_(e, t), t.set(e, n))
}
function J_(e, t) {
  if (t.has(e))
    throw new TypeError('Cannot initialize the same private elements twice on an object')
}
function wv(e, t, n) {
  return (e.set(Yg(e, t), n), n)
}
function Yn(e, t) {
  return e.get(Yg(e, t))
}
function Yg(e, t, n) {
  if (typeof e == 'function' ? e === t : e.has(t)) return arguments.length < 3 ? t : n
  throw new TypeError('Private element is not present on this object')
}
function qg(e, t, n) {
  const a = t.length - 1
  if (a < 0) return e === void 0 ? n : e
  for (let l = 0; l < a; l++) {
    if (e == null) return n
    e = e[t[l]]
  }
  return e == null || e[t[a]] === void 0 ? n : e[t[a]]
}
function kt(e, t) {
  if (e === t) return !0
  if (
    (e instanceof Date && t instanceof Date && e.getTime() !== t.getTime()) ||
    e !== Object(e) ||
    t !== Object(t)
  )
    return !1
  const n = Object.keys(e)
  return n.length !== Object.keys(t).length ? !1 : n.every((a) => kt(e[a], t[a]))
}
function Za(e, t, n) {
  return e == null || !t || typeof t != 'string'
    ? n
    : e[t] !== void 0
      ? e[t]
      : ((t = t.replace(/\[(\w+)\]/g, '.$1')), (t = t.replace(/^\./, '')), qg(e, t.split('.'), n))
}
function st(e, t, n) {
  if (t === !0) return e === void 0 ? n : e
  if (t == null || typeof t == 'boolean') return n
  if (e !== Object(e)) {
    if (typeof t != 'function') return n
    const l = t(e, n)
    return typeof l > 'u' ? n : l
  }
  if (typeof t == 'string') return Za(e, t, n)
  if (Array.isArray(t)) return qg(e, t, n)
  if (typeof t != 'function') return n
  const a = t(e, n)
  return typeof a > 'u' ? n : a
}
function ln(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0
  return Array.from({ length: e }, (n, a) => t + a)
}
function fe(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'px'
  if (e == null || e === '') return
  const n = Number(e)
  return isNaN(n) ? String(e) : isFinite(n) ? `${n}${t}` : void 0
}
function Do(e) {
  return e !== null && typeof e == 'object' && !Array.isArray(e)
}
function kv(e) {
  let t
  return (
    e !== null &&
    typeof e == 'object' &&
    ((t = Object.getPrototypeOf(e)) === Object.prototype || t === null)
  )
}
function Wc(e) {
  if (e && '$el' in e) {
    const t = e.$el
    return t?.nodeType === Node.TEXT_NODE ? t.nextElementSibling : t
  }
  return e
}
const Su = Object.freeze({
  enter: 'Enter',
  tab: 'Tab',
  delete: 'Delete',
  esc: 'Escape',
  space: 'Space',
  up: 'ArrowUp',
  down: 'ArrowDown',
  left: 'ArrowLeft',
  right: 'ArrowRight',
  end: 'End',
  home: 'Home',
  del: 'Delete',
  backspace: 'Backspace',
  insert: 'Insert',
  pageup: 'PageUp',
  pagedown: 'PageDown',
  shift: 'Shift',
})
function Xg(e) {
  return Object.keys(e)
}
function $a(e, t) {
  return t.every((n) => e.hasOwnProperty(n))
}
function Zt(e, t) {
  const n = {}
  for (const a of t) Object.prototype.hasOwnProperty.call(e, a) && (n[a] = e[a])
  return n
}
function wu(e, t, n) {
  const a = Object.create(null),
    l = Object.create(null)
  for (const o in e)
    t.some((i) => (i instanceof RegExp ? i.test(o) : i === o)) ? (a[o] = e[o]) : (l[o] = e[o])
  return [a, l]
}
function je(e, t) {
  const n = { ...e }
  return (t.forEach((a) => delete n[a]), n)
}
const Zg = /^on[^a-z]/,
  Uc = (e) => Zg.test(e),
  Q_ = [
    'onAfterscriptexecute',
    'onAnimationcancel',
    'onAnimationend',
    'onAnimationiteration',
    'onAnimationstart',
    'onAuxclick',
    'onBeforeinput',
    'onBeforescriptexecute',
    'onChange',
    'onClick',
    'onCompositionend',
    'onCompositionstart',
    'onCompositionupdate',
    'onContextmenu',
    'onCopy',
    'onCut',
    'onDblclick',
    'onFocusin',
    'onFocusout',
    'onFullscreenchange',
    'onFullscreenerror',
    'onGesturechange',
    'onGestureend',
    'onGesturestart',
    'onGotpointercapture',
    'onInput',
    'onKeydown',
    'onKeypress',
    'onKeyup',
    'onLostpointercapture',
    'onMousedown',
    'onMousemove',
    'onMouseout',
    'onMouseover',
    'onMouseup',
    'onMousewheel',
    'onPaste',
    'onPointercancel',
    'onPointerdown',
    'onPointerenter',
    'onPointerleave',
    'onPointermove',
    'onPointerout',
    'onPointerover',
    'onPointerup',
    'onReset',
    'onSelect',
    'onSubmit',
    'onTouchcancel',
    'onTouchend',
    'onTouchmove',
    'onTouchstart',
    'onTransitioncancel',
    'onTransitionend',
    'onTransitionrun',
    'onTransitionstart',
    'onWheel',
  ],
  e1 = ['ArrowUp', 'ArrowDown', 'ArrowRight', 'ArrowLeft', 'Enter', 'Escape', 'Tab', ' ']
function t1(e) {
  return e.isComposing && e1.includes(e.key)
}
function Ia(e) {
  const [t, n] = wu(e, [Zg]),
    a = je(t, Q_),
    [l, o] = wu(n, ['class', 'style', 'id', /^data-/])
  return (Object.assign(l, t), Object.assign(o, a), [l, o])
}
function nt(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e]
}
function Jg(e, t) {
  let n = 0
  const a = function () {
    for (var l = arguments.length, o = new Array(l), i = 0; i < l; i++) o[i] = arguments[i]
    ;(clearTimeout(n), (n = setTimeout(() => e(...o), Ke(t))))
  }
  return (
    (a.clear = () => {
      clearTimeout(n)
    }),
    (a.immediate = e),
    a
  )
}
function Ge(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
    n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1
  return Math.max(t, Math.min(n, e))
}
function Cv(e) {
  const t = e.toString().trim()
  return t.includes('.') ? t.length - t.indexOf('.') - 1 : 0
}
function xv(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : '0'
  return e + n.repeat(Math.max(0, t - e.length))
}
function _v(e, t) {
  return (
    (arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : '0').repeat(
      Math.max(0, t - e.length)
    ) + e
  )
}
function n1(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1
  const n = []
  let a = 0
  for (; a < e.length; ) (n.push(e.substr(a, t)), (a += t))
  return n
}
function Pv(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3
  if (e < t) return `${e} B`
  const n = t === 1024 ? ['Ki', 'Mi', 'Gi'] : ['k', 'M', 'G']
  let a = -1
  for (; Math.abs(e) >= t && a < n.length - 1; ) ((e /= t), ++a)
  return `${e.toFixed(1)} ${n[a]}B`
}
function Ot() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
    t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    n = arguments.length > 2 ? arguments[2] : void 0
  const a = {}
  for (const l in e) a[l] = e[l]
  for (const l in t) {
    const o = e[l],
      i = t[l]
    if (kv(o) && kv(i)) {
      a[l] = Ot(o, i, n)
      continue
    }
    if (n && Array.isArray(o) && Array.isArray(i)) {
      a[l] = n(o, i)
      continue
    }
    a[l] = i
  }
  return a
}
function Qg(e) {
  return e.map((t) => (t.type === he ? Qg(t.children) : t)).flat()
}
function Wa() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ''
  if (Wa.cache.has(e)) return Wa.cache.get(e)
  const t = e
    .replace(/[^a-z]/gi, '-')
    .replace(/\B([A-Z])/g, '-$1')
    .toLowerCase()
  return (Wa.cache.set(e, t), t)
}
Wa.cache = new Map()
function _l(e, t) {
  if (!t || typeof t != 'object') return []
  if (Array.isArray(t)) return t.map((n) => _l(e, n)).flat(1)
  if (t.suspense) return _l(e, t.ssContent)
  if (Array.isArray(t.children)) return t.children.map((n) => _l(e, n)).flat(1)
  if (t.component) {
    if (Object.getOwnPropertySymbols(t.component.provides).includes(e)) return [t.component]
    if (t.component.subTree) return _l(e, t.component.subTree).flat(1)
  }
  return []
}
var yl = new WeakMap(),
  Ma = new WeakMap()
class ey {
  constructor(t) {
    ;(Sv(this, yl, []), Sv(this, Ma, 0), (this.size = t))
  }
  get isFull() {
    return Yn(yl, this).length === this.size
  }
  push(t) {
    ;((Yn(yl, this)[Yn(Ma, this)] = t), wv(Ma, this, (Yn(Ma, this) + 1) % this.size))
  }
  values() {
    return Yn(yl, this)
      .slice(Yn(Ma, this))
      .concat(Yn(yl, this).slice(0, Yn(Ma, this)))
  }
  clear() {
    ;((Yn(yl, this).length = 0), wv(Ma, this, 0))
  }
}
function a1(e) {
  return 'touches' in e
    ? { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY }
    : { clientX: e.clientX, clientY: e.clientY }
}
function Kc(e) {
  const t = it({})
  qe(
    () => {
      const a = e()
      for (const l in a) t[l] = a[l]
    },
    { flush: 'sync' }
  )
  const n = {}
  for (const a in t) n[a] = B(() => t[a])
  return n
}
function rr(e, t) {
  return e.includes(t)
}
function ty(e) {
  return e[2].toLowerCase() + e.slice(3)
}
const Pt = () => [Function, Array]
function Vv(e, t) {
  return (
    (t = 'on' + Hn(t)),
    !!(e[t] || e[`${t}Once`] || e[`${t}Capture`] || e[`${t}OnceCapture`] || e[`${t}CaptureOnce`])
  )
}
function ti(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++)
    n[a - 1] = arguments[a]
  if (Array.isArray(e)) for (const l of e) l(...n)
  else typeof e == 'function' && e(...n)
}
function Ro(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
  const n = ['button', '[href]', 'input:not([type="hidden"])', 'select', 'textarea', '[tabindex]']
    .map((a) => `${a}${t ? ':not([tabindex="-1"])' : ''}:not([disabled])`)
    .join(', ')
  return [...e.querySelectorAll(n)]
}
function ny(e, t, n) {
  let a,
    l = e.indexOf(document.activeElement)
  const o = t === 'next' ? 1 : -1
  do ((l += o), (a = e[l]))
  while ((!a || a.offsetParent == null || !(n?.(a) ?? !0)) && l < e.length && l >= 0)
  return a
}
function Ua(e, t) {
  const n = Ro(e)
  if (t == null)
    (e === document.activeElement || !e.contains(document.activeElement)) && n[0]?.focus()
  else if (t === 'first') n[0]?.focus()
  else if (t === 'last') n.at(-1)?.focus()
  else if (typeof t == 'number') n[t]?.focus()
  else {
    const a = ny(n, t)
    a ? a.focus() : Ua(e, t === 'next' ? 'first' : 'last')
  }
}
function Vi(e) {
  return e == null || (typeof e == 'string' && e.trim() === '')
}
function ay() {}
function Hl(e, t) {
  if (!(Ne && typeof CSS < 'u' && typeof CSS.supports < 'u' && CSS.supports(`selector(${t})`)))
    return null
  try {
    return !!e && e.matches(t)
  } catch {
    return null
  }
}
function Br(e) {
  return e.some((t) => (_a(t) ? (t.type === mt ? !1 : t.type !== he || Br(t.children)) : !0))
    ? e
    : null
}
function Ii(e, t, n) {
  return e?.(t) ?? n?.(t)
}
function l1(e, t) {
  if (!Ne || e === 0) return (t(), () => {})
  const n = window.setTimeout(t, e)
  return () => window.clearTimeout(n)
}
function o1(e, t) {
  const n = e.clientX,
    a = e.clientY,
    l = t.getBoundingClientRect(),
    o = l.left,
    i = l.top,
    r = l.right,
    s = l.bottom
  return n >= o && n <= r && a >= i && a <= s
}
function sr() {
  const e = oe(),
    t = (n) => {
      e.value = n
    }
  return (
    Object.defineProperty(t, 'value', {
      enumerable: !0,
      get: () => e.value,
      set: (n) => (e.value = n),
    }),
    Object.defineProperty(t, 'el', { enumerable: !0, get: () => Wc(e.value) }),
    t
  )
}
function jl(e) {
  const t = e.key.length === 1,
    n = !e.ctrlKey && !e.metaKey && !e.altKey
  return t && n
}
function ku(e) {
  return (
    typeof e == 'string' || typeof e == 'number' || typeof e == 'boolean' || typeof e == 'bigint'
  )
}
function ur(e) {
  return '\\^$*+?.()|{}[]'.includes(e) ? `\\${e}` : e
}
function i1(e, t, n) {
  const a = new RegExp(`[\\d\\-${ur(n)}]`),
    l = e
      .split('')
      .filter((i) => a.test(i))
      .filter(
        (i, r, s) => (r === 0 && /[-]/.test(i)) || (i === n && r === s.indexOf(i)) || /\d/.test(i)
      )
      .join('')
  if (t === 0) return l.split(n)[0]
  const o = new RegExp(`${ur(n)}\\d`)
  if (t !== null && o.test(l)) {
    const i = l.split(n)
    return [i[0], i[1].substring(0, t)].join(n)
  }
  return l
}
function r1(e) {
  const t = {}
  for (const n in e) t[Wt(n)] = e[n]
  return t
}
function s1(e) {
  const t = ['checked', 'disabled']
  return Object.fromEntries(
    Object.entries(e).filter((n) => {
      let [a, l] = n
      return t.includes(a) ? !!l : l !== void 0
    })
  )
}
const ly = ['top', 'bottom'],
  u1 = ['start', 'end', 'left', 'right']
function Cu(e, t) {
  let [n, a] = e.split(' ')
  return (
    a || (a = rr(ly, n) ? 'start' : rr(u1, n) ? 'top' : 'center'),
    { side: xu(n, t), align: xu(a, t) }
  )
}
function xu(e, t) {
  return e === 'start' ? (t ? 'right' : 'left') : e === 'end' ? (t ? 'left' : 'right') : e
}
function Is(e) {
  return {
    side: { center: 'center', top: 'bottom', bottom: 'top', left: 'right', right: 'left' }[e.side],
    align: e.align,
  }
}
function Ts(e) {
  return {
    side: e.side,
    align: { center: 'center', top: 'bottom', bottom: 'top', left: 'right', right: 'left' }[
      e.align
    ],
  }
}
function Iv(e) {
  return { side: e.align, align: e.side }
}
function Tv(e) {
  return rr(ly, e.side) ? 'y' : 'x'
}
class Mn {
  constructor(t) {
    let { x: n, y: a, width: l, height: o } = t
    ;((this.x = n), (this.y = a), (this.width = l), (this.height = o))
  }
  get top() {
    return this.y
  }
  get bottom() {
    return this.y + this.height
  }
  get left() {
    return this.x
  }
  get right() {
    return this.x + this.width
  }
}
function Av(e, t) {
  return {
    x: { before: Math.max(0, t.left - e.left), after: Math.max(0, e.right - t.right) },
    y: { before: Math.max(0, t.top - e.top), after: Math.max(0, e.bottom - t.bottom) },
  }
}
function oy(e) {
  return Array.isArray(e)
    ? new Mn({ x: e[0], y: e[1], width: 0, height: 0 })
    : e.getBoundingClientRect()
}
function c1(e) {
  if (e === document.documentElement)
    return visualViewport
      ? new Mn({
          x: visualViewport.scale > 1 ? 0 : visualViewport.offsetLeft,
          y: visualViewport.scale > 1 ? 0 : visualViewport.offsetTop,
          width: visualViewport.width * visualViewport.scale,
          height: visualViewport.height * visualViewport.scale,
        })
      : new Mn({
          x: 0,
          y: 0,
          width: document.documentElement.clientWidth,
          height: document.documentElement.clientHeight,
        })
  {
    const t = e.getBoundingClientRect()
    return new Mn({ x: t.x, y: t.y, width: e.clientWidth, height: e.clientHeight })
  }
}
function Gc(e) {
  const t = e.getBoundingClientRect(),
    n = getComputedStyle(e),
    a = n.transform
  if (a) {
    let l, o, i, r, s
    if (a.startsWith('matrix3d('))
      ((l = a.slice(9, -1).split(/, /)),
        (o = Number(l[0])),
        (i = Number(l[5])),
        (r = Number(l[12])),
        (s = Number(l[13])))
    else if (a.startsWith('matrix('))
      ((l = a.slice(7, -1).split(/, /)),
        (o = Number(l[0])),
        (i = Number(l[3])),
        (r = Number(l[4])),
        (s = Number(l[5])))
    else return new Mn(t)
    const c = n.transformOrigin,
      u = t.x - r - (1 - o) * parseFloat(c),
      d = t.y - s - (1 - i) * parseFloat(c.slice(c.indexOf(' ') + 1)),
      f = o ? t.width / o : e.offsetWidth + 1,
      v = i ? t.height / i : e.offsetHeight + 1
    return new Mn({ x: u, y: d, width: f, height: v })
  } else return new Mn(t)
}
function Zn(e, t, n) {
  if (typeof e.animate > 'u') return { finished: Promise.resolve() }
  let a
  try {
    a = e.animate(t, n)
  } catch {
    return { finished: Promise.resolve() }
  }
  return (
    typeof a.finished > 'u' &&
      (a.finished = new Promise((l) => {
        a.onfinish = () => {
          l(a)
        }
      })),
    a
  )
}
const Hi = new WeakMap()
function d1(e, t) {
  Object.keys(t).forEach((n) => {
    if (Uc(n)) {
      const a = ty(n),
        l = Hi.get(e)
      if (t[n] == null)
        l?.forEach((o) => {
          const [i, r] = o
          i === a && (e.removeEventListener(a, r), l.delete(o))
        })
      else if (!l || ![...l].some((o) => o[0] === a && o[1] === t[n])) {
        e.addEventListener(a, t[n])
        const o = l || new Set()
        ;(o.add([a, t[n]]), Hi.has(e) || Hi.set(e, o))
      }
    } else t[n] == null ? e.removeAttribute(n) : e.setAttribute(n, t[n])
  })
}
function f1(e, t) {
  Object.keys(t).forEach((n) => {
    if (Uc(n)) {
      const a = ty(n),
        l = Hi.get(e)
      l?.forEach((o) => {
        const [i, r] = o
        i === a && (e.removeEventListener(a, r), l.delete(o))
      })
    } else e.removeAttribute(n)
  })
}
const bl = 2.4,
  Ev = 0.2126729,
  Dv = 0.7151522,
  Rv = 0.072175,
  v1 = 0.55,
  m1 = 0.58,
  h1 = 0.57,
  g1 = 0.62,
  Ti = 0.03,
  Mv = 1.45,
  y1 = 5e-4,
  b1 = 1.25,
  p1 = 1.25,
  Bv = 0.078,
  Lv = 12.82051282051282,
  Ai = 0.06,
  Ov = 0.001
function $v(e, t) {
  const n = (e.r / 255) ** bl,
    a = (e.g / 255) ** bl,
    l = (e.b / 255) ** bl,
    o = (t.r / 255) ** bl,
    i = (t.g / 255) ** bl,
    r = (t.b / 255) ** bl
  let s = n * Ev + a * Dv + l * Rv,
    c = o * Ev + i * Dv + r * Rv
  if ((s <= Ti && (s += (Ti - s) ** Mv), c <= Ti && (c += (Ti - c) ** Mv), Math.abs(c - s) < y1))
    return 0
  let u
  if (c > s) {
    const d = (c ** v1 - s ** m1) * b1
    u = d < Ov ? 0 : d < Bv ? d - d * Lv * Ai : d - Ai
  } else {
    const d = (c ** g1 - s ** h1) * p1
    u = d > -Ov ? 0 : d > -Bv ? d - d * Lv * Ai : d + Ai
  }
  return u * 100
}
function iy(e, t) {
  t = Array.isArray(t)
    ? t
        .slice(0, -1)
        .map((n) => `'${n}'`)
        .join(', ') + ` or '${t.at(-1)}'`
    : `'${t}'`
}
const cr = 0.20689655172413793,
  S1 = (e) => (e > cr ** 3 ? Math.cbrt(e) : e / (3 * cr ** 2) + 4 / 29),
  w1 = (e) => (e > cr ? e ** 3 : 3 * cr ** 2 * (e - 4 / 29))
function ry(e) {
  const t = S1,
    n = t(e[1])
  return [116 * n - 16, 500 * (t(e[0] / 0.95047) - n), 200 * (n - t(e[2] / 1.08883))]
}
function sy(e) {
  const t = w1,
    n = (e[0] + 16) / 116
  return [t(n + e[1] / 500) * 0.95047, t(n), t(n - e[2] / 200) * 1.08883]
}
const k1 = [
    [3.2406, -1.5372, -0.4986],
    [-0.9689, 1.8758, 0.0415],
    [0.0557, -0.204, 1.057],
  ],
  C1 = (e) => (e <= 0.0031308 ? e * 12.92 : 1.055 * e ** (1 / 2.4) - 0.055),
  x1 = [
    [0.4124, 0.3576, 0.1805],
    [0.2126, 0.7152, 0.0722],
    [0.0193, 0.1192, 0.9505],
  ],
  _1 = (e) => (e <= 0.04045 ? e / 12.92 : ((e + 0.055) / 1.055) ** 2.4)
function uy(e) {
  const t = Array(3),
    n = C1,
    a = k1
  for (let l = 0; l < 3; ++l)
    t[l] = Math.round(Ge(n(a[l][0] * e[0] + a[l][1] * e[1] + a[l][2] * e[2])) * 255)
  return { r: t[0], g: t[1], b: t[2] }
}
function Yc(e) {
  let { r: t, g: n, b: a } = e
  const l = [0, 0, 0],
    o = _1,
    i = x1
  ;((t = o(t / 255)), (n = o(n / 255)), (a = o(a / 255)))
  for (let r = 0; r < 3; ++r) l[r] = i[r][0] * t + i[r][1] * n + i[r][2] * a
  return l
}
function _u(e) {
  return !!e && /^(#|var\(--|(rgb|hsl)a?\()/.test(e)
}
function P1(e) {
  return _u(e) && !/^((rgb|hsl)a?\()?var\(--/.test(e)
}
const Fv = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/,
  V1 = {
    rgb: (e, t, n, a) => ({ r: e, g: t, b: n, a }),
    rgba: (e, t, n, a) => ({ r: e, g: t, b: n, a }),
    hsl: (e, t, n, a) => Nv({ h: e, s: t, l: n, a }),
    hsla: (e, t, n, a) => Nv({ h: e, s: t, l: n, a }),
    hsv: (e, t, n, a) => $n({ h: e, s: t, v: n, a }),
    hsva: (e, t, n, a) => $n({ h: e, s: t, v: n, a }),
  }
function on(e) {
  if (typeof e == 'number') return { r: (e & 16711680) >> 16, g: (e & 65280) >> 8, b: e & 255 }
  if (typeof e == 'string' && Fv.test(e)) {
    const { groups: t } = e.match(Fv),
      { fn: n, values: a } = t,
      l = a
        .split(/,\s*|\s*\/\s*|\s+/)
        .map((o, i) =>
          o.endsWith('%') || (i > 0 && i < 3 && ['hsl', 'hsla', 'hsv', 'hsva'].includes(n))
            ? parseFloat(o) / 100
            : parseFloat(o)
        )
    return V1[n](...l)
  } else if (typeof e == 'string') {
    let t = e.startsWith('#') ? e.slice(1) : e
    return (
      [3, 4].includes(t.length)
        ? (t = t
            .split('')
            .map((n) => n + n)
            .join(''))
        : [6, 8].includes(t.length),
      vy(t)
    )
  } else if (typeof e == 'object') {
    if ($a(e, ['r', 'g', 'b'])) return e
    if ($a(e, ['h', 's', 'l'])) return $n(qc(e))
    if ($a(e, ['h', 's', 'v'])) return $n(e)
  }
  throw new TypeError(`Invalid color: ${e == null ? e : String(e) || e.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`)
}
function $n(e) {
  const { h: t, s: n, v: a, a: l } = e,
    o = (r) => {
      const s = (r + t / 60) % 6
      return a - a * n * Math.max(Math.min(s, 4 - s, 1), 0)
    },
    i = [o(5), o(3), o(1)].map((r) => Math.round(r * 255))
  return { r: i[0], g: i[1], b: i[2], a: l }
}
function Nv(e) {
  return $n(qc(e))
}
function ni(e) {
  if (!e) return { h: 0, s: 1, v: 1, a: 1 }
  const t = e.r / 255,
    n = e.g / 255,
    a = e.b / 255,
    l = Math.max(t, n, a),
    o = Math.min(t, n, a)
  let i = 0
  ;(l !== o &&
    (l === t
      ? (i = 60 * (0 + (n - a) / (l - o)))
      : l === n
        ? (i = 60 * (2 + (a - t) / (l - o)))
        : l === a && (i = 60 * (4 + (t - n) / (l - o)))),
    i < 0 && (i = i + 360))
  const r = l === 0 ? 0 : (l - o) / l,
    s = [i, r, l]
  return { h: s[0], s: s[1], v: s[2], a: e.a }
}
function Pu(e) {
  const { h: t, s: n, v: a, a: l } = e,
    o = a - (a * n) / 2,
    i = o === 1 || o === 0 ? 0 : (a - o) / Math.min(o, 1 - o)
  return { h: t, s: i, l: o, a: l }
}
function qc(e) {
  const { h: t, s: n, l: a, a: l } = e,
    o = a + n * Math.min(a, 1 - a),
    i = o === 0 ? 0 : 2 - (2 * a) / o
  return { h: t, s: i, v: o, a: l }
}
function cy(e) {
  let { r: t, g: n, b: a, a: l } = e
  return l === void 0 ? `rgb(${t}, ${n}, ${a})` : `rgba(${t}, ${n}, ${a}, ${l})`
}
function dy(e) {
  return cy($n(e))
}
function Ei(e) {
  const t = Math.round(e).toString(16)
  return ('00'.substr(0, 2 - t.length) + t).toUpperCase()
}
function fy(e) {
  let { r: t, g: n, b: a, a: l } = e
  return `#${[Ei(t), Ei(n), Ei(a), l !== void 0 ? Ei(Math.round(l * 255)) : ''].join('')}`
}
function vy(e) {
  e = T1(e)
  let [t, n, a, l] = n1(e, 2).map((o) => parseInt(o, 16))
  return ((l = l === void 0 ? l : l / 255), { r: t, g: n, b: a, a: l })
}
function I1(e) {
  const t = vy(e)
  return ni(t)
}
function my(e) {
  return fy($n(e))
}
function T1(e) {
  return (
    e.startsWith('#') && (e = e.slice(1)),
    (e = e.replace(/([^0-9a-f])/gi, 'F')),
    (e.length === 3 || e.length === 4) &&
      (e = e
        .split('')
        .map((t) => t + t)
        .join('')),
    e.length !== 6 && (e = xv(xv(e, 6), 8, 'F')),
    e
  )
}
function A1(e, t) {
  const n = ry(Yc(e))
  return ((n[0] = n[0] + t * 10), uy(sy(n)))
}
function E1(e, t) {
  const n = ry(Yc(e))
  return ((n[0] = n[0] - t * 10), uy(sy(n)))
}
function Vu(e) {
  const t = on(e)
  return Yc(t)[1]
}
function D1(e, t) {
  const n = Vu(e),
    a = Vu(t),
    l = Math.max(n, a),
    o = Math.min(n, a)
  return (l + 0.05) / (o + 0.05)
}
function hy(e) {
  const t = Math.abs($v(on(0), on(e)))
  return Math.abs($v(on(16777215), on(e))) > Math.min(t, 50) ? '#fff' : '#000'
}
function $(e, t) {
  return (n) =>
    Object.keys(e).reduce((a, l) => {
      const i =
        typeof e[l] == 'object' && e[l] != null && !Array.isArray(e[l]) ? e[l] : { type: e[l] }
      return (
        n && l in n ? (a[l] = { ...i, default: n[l] }) : (a[l] = i),
        t && !a[l].source && (a[l].source = t),
        a
      )
    }, {})
}
const be = $(
  { class: [String, Array, Object], style: { type: [String, Array, Object], default: null } },
  'component'
)
function rt(e, t) {
  const n = jn()
  if (!n) throw new Error(`[Vuetify] ${e} must be called from inside a setup function`)
  return n
}
function Wn() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'composables'
  const t = rt(e).type
  return Wa(t?.aliasName || t?.name)
}
function R1(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : rt('injectSelf')
  const { provides: n } = t
  if (n && e in n) return n[e]
}
const zl = Symbol.for('vuetify:defaults')
function M1(e) {
  return ae(e)
}
function Xc() {
  const e = Ve(zl)
  if (!e) throw new Error('[Vuetify] Could not find defaults instance')
  return e
}
function lt(e, t) {
  const n = Xc(),
    a = ae(e),
    l = C(() => {
      if (Ke(t?.disabled)) return n.value
      const i = Ke(t?.scoped),
        r = Ke(t?.reset),
        s = Ke(t?.root)
      if (a.value == null && !(i || r || s)) return n.value
      let c = Ot(a.value, { prev: n.value })
      if (i) return c
      if (r || s) {
        const u = Number(r || 1 / 0)
        for (let d = 0; d <= u && !(!c || !('prev' in c)); d++) c = c.prev
        return (c && typeof s == 'string' && s in c && (c = Ot(Ot(c, { prev: c }), c[s])), c)
      }
      return c.prev ? Ot(c.prev, c) : c
    })
  return (Fe(zl, l), l)
}
function B1(e, t) {
  return e.props && (typeof e.props[t] < 'u' || typeof e.props[Wa(t)] < 'u')
}
function L1() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
    t = arguments.length > 1 ? arguments[1] : void 0,
    n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Xc()
  const a = rt('useDefaults')
  if (((t = t ?? a.type.name ?? a.type.__name), !t))
    throw new Error('[Vuetify] Could not determine component name')
  const l = C(() => n.value?.[e._as ?? t]),
    o = new Proxy(e, {
      get(s, c) {
        const u = Reflect.get(s, c)
        if (c === 'class' || c === 'style') return [l.value?.[c], u].filter((v) => v != null)
        if (B1(a.vnode, c)) return u
        const d = l.value?.[c]
        if (d !== void 0) return d
        const f = n.value?.global?.[c]
        return f !== void 0 ? f : u
      },
    }),
    i = oe()
  qe(() => {
    if (l.value) {
      const s = Object.entries(l.value).filter((c) => {
        let [u] = c
        return u.startsWith(u[0].toUpperCase())
      })
      i.value = s.length ? Object.fromEntries(s) : void 0
    } else i.value = void 0
  })
  function r() {
    const s = R1(zl, a)
    Fe(
      zl,
      C(() => (i.value ? Ot(s?.value ?? {}, i.value) : s?.value))
    )
  }
  return { props: o, provideSubDefaults: r }
}
function un(e) {
  if (((e._setup = e._setup ?? e.setup), !e.name)) return e
  if (e._setup) {
    e.props = $(e.props ?? {}, e.name)()
    const t = Object.keys(e.props).filter((n) => n !== 'class' && n !== 'style')
    ;((e.filterProps = function (a) {
      return Zt(a, t)
    }),
      (e.props._as = String),
      (e.setup = function (a, l) {
        const o = Xc()
        if (!o.value) return e._setup(a, l)
        const { props: i, provideSubDefaults: r } = L1(a, a._as ?? e.name, o),
          s = e._setup(i, l)
        return (r(), s)
      }))
  }
  return e
}
function J() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0
  return (t) => (e ? un : sa)(t)
}
function O1(e, t) {
  return ((t.props = e), t)
}
function da(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'div',
    n = arguments.length > 2 ? arguments[2] : void 0
  return J()({
    name: n ?? Hn(Wt(e.replace(/__/g, '-'))),
    props: { tag: { type: String, default: t }, ...be() },
    setup(a, l) {
      let { slots: o } = l
      return () => ut(a.tag, { class: [e, a.class], style: a.style }, o.default?.())
    },
  })
}
function gy(e) {
  if (typeof e.getRootNode != 'function') {
    for (; e.parentNode; ) e = e.parentNode
    return e !== document ? null : document
  }
  const t = e.getRootNode()
  return t !== document && t.getRootNode({ composed: !0 }) !== document ? null : t
}
const Mo = 'cubic-bezier(0.4, 0, 0.2, 1)',
  Hv = 'cubic-bezier(0.0, 0, 0.2, 1)',
  jv = 'cubic-bezier(0.4, 0, 1, 1)',
  $1 = {
    linear: (e) => e,
    easeInQuad: (e) => e ** 2,
    easeOutQuad: (e) => e * (2 - e),
    easeInOutQuad: (e) => (e < 0.5 ? 2 * e ** 2 : -1 + (4 - 2 * e) * e),
    easeInCubic: (e) => e ** 3,
    easeOutCubic: (e) => (--e) ** 3 + 1,
    easeInOutCubic: (e) => (e < 0.5 ? 4 * e ** 3 : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1),
    easeInQuart: (e) => e ** 4,
    easeOutQuart: (e) => 1 - (--e) ** 4,
    easeInOutQuart: (e) => (e < 0.5 ? 8 * e ** 4 : 1 - 8 * (--e) ** 4),
    easeInQuint: (e) => e ** 5,
    easeOutQuint: (e) => 1 + (--e) ** 5,
    easeInOutQuint: (e) => (e < 0.5 ? 16 * e ** 5 : 1 + 16 * (--e) ** 5),
    instant: (e) => 1,
  }
function zv(e, t, n) {
  return Object.keys(e)
    .filter((a) => Uc(a) && a.endsWith(t))
    .reduce((a, l) => ((a[l.slice(0, -t.length)] = (o) => ti(e[l], o, n(o))), a), {})
}
function Zc(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1
  for (; e; ) {
    if (t ? F1(e) : Jc(e)) return e
    e = e.parentElement
  }
  return document.scrollingElement
}
function dr(e, t) {
  const n = []
  if (t && e && !t.contains(e)) return n
  for (; e && (Jc(e) && n.push(e), e !== t); ) e = e.parentElement
  return n
}
function Jc(e) {
  if (!e || e.nodeType !== Node.ELEMENT_NODE) return !1
  const t = window.getComputedStyle(e),
    n = t.overflowY === 'scroll' || (t.overflowY === 'auto' && e.scrollHeight > e.clientHeight),
    a = t.overflowX === 'scroll' || (t.overflowX === 'auto' && e.scrollWidth > e.clientWidth)
  return n || a
}
function F1(e) {
  if (!e || e.nodeType !== Node.ELEMENT_NODE) return !1
  const t = window.getComputedStyle(e)
  return ['scroll', 'auto'].includes(t.overflowY)
}
function N1(e) {
  let {
    depth: t,
    isLast: n,
    isLastGroup: a,
    leafLinks: l,
    separateRoots: o,
    parentIndentLines: i,
    variant: r,
  } = e
  if (!i || !t) return { leaf: void 0, node: void 0, children: i }
  if (r === 'simple')
    return { leaf: [...i, 'line'], node: [...i, 'line'], children: [...i, 'line'] }
  const s = n && (!a || o || t > 1)
  return {
    leaf: [...i, s ? 'last-leaf' : 'leaf', ...(l ? ['leaf-link'] : [])],
    node: [...i, s ? 'last-leaf' : 'leaf'],
    children: [...i, s ? 'none' : 'line'],
  }
}
function H1(e) {
  for (; e; ) {
    if (window.getComputedStyle(e).position === 'fixed') return !0
    e = e.offsetParent
  }
  return !1
}
function ne(e) {
  const t = rt('useRender')
  t.render = e
}
function we(e, t, n) {
  let a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (d) => d,
    l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (d) => d
  const o = rt('useProxiedModel'),
    i = ae(e[t] !== void 0 ? e[t] : n),
    r = Wa(t),
    c = C(
      r !== t
        ? () => (
            e[t],
            !!(
              (o.vnode.props?.hasOwnProperty(t) || o.vnode.props?.hasOwnProperty(r)) &&
              (o.vnode.props?.hasOwnProperty(`onUpdate:${t}`) ||
                o.vnode.props?.hasOwnProperty(`onUpdate:${r}`))
            )
          )
        : () => (
            e[t],
            !!(o.vnode.props?.hasOwnProperty(t) && o.vnode.props?.hasOwnProperty(`onUpdate:${t}`))
          )
    )
  Et(
    () => !c.value,
    () => {
      ue(
        () => e[t],
        (d) => {
          i.value = d
        }
      )
    }
  )
  const u = C({
    get() {
      const d = e[t]
      return a(c.value ? d : i.value)
    },
    set(d) {
      const f = l(d),
        v = _e(c.value ? e[t] : i.value)
      v === f || a(v) === d || ((i.value = f), o?.emit(`update:${t}`, f))
    },
  })
  return (Object.defineProperty(u, 'externalValue', { get: () => (c.value ? e[t] : i.value) }), u)
}
const j1 = {
    badge: 'Badge',
    open: 'Open',
    close: 'Close',
    dismiss: 'Dismiss',
    confirmEdit: { ok: 'OK', cancel: 'Cancel' },
    dataIterator: { noResultsText: 'No matching records found', loadingText: 'Loading items...' },
    dataTable: {
      itemsPerPageText: 'Rows per page:',
      ariaLabel: {
        sortDescending: 'Sorted descending.',
        sortAscending: 'Sorted ascending.',
        sortNone: 'Not sorted.',
        activateNone: 'Activate to remove sorting.',
        activateDescending: 'Activate to sort descending.',
        activateAscending: 'Activate to sort ascending.',
      },
      sortBy: 'Sort by',
    },
    dataFooter: {
      itemsPerPageText: 'Items per page:',
      itemsPerPageAll: 'All',
      nextPage: 'Next page',
      prevPage: 'Previous page',
      firstPage: 'First page',
      lastPage: 'Last page',
      pageText: '{0}-{1} of {2}',
    },
    dateRangeInput: { divider: 'to' },
    datePicker: {
      itemsSelected: '{0} selected',
      range: { title: 'Select dates', header: 'Enter dates' },
      title: 'Select date',
      header: 'Enter date',
      input: { placeholder: 'Enter date' },
      ariaLabel: {
        previousMonth: 'Previous month',
        nextMonth: 'Next month',
        selectYear: 'Select year',
        selectDate: '{0}',
        currentDate: 'Today, {0}',
      },
    },
    noDataText: 'No data available',
    carousel: {
      prev: 'Previous visual',
      next: 'Next visual',
      ariaLabel: { delimiter: 'Carousel slide {0} of {1}' },
    },
    calendar: { moreEvents: '{0} more', today: 'Today' },
    input: {
      clear: 'Clear {0}',
      prependAction: '{0} prepended action',
      appendAction: '{0} appended action',
      otp: 'Please enter OTP character {0}',
    },
    fileInput: { counter: '{0} files', counterSize: '{0} files ({1} in total)' },
    fileUpload: { title: 'Drag and drop files here', divider: 'or', browse: 'Browse Files' },
    timePicker: { am: 'AM', pm: 'PM', title: 'Select Time' },
    pagination: {
      ariaLabel: {
        root: 'Pagination Navigation',
        next: 'Next page',
        previous: 'Previous page',
        page: 'Go to page {0}',
        currentPage: 'Page {0}, Current page',
        first: 'First page',
        last: 'Last page',
      },
    },
    stepper: { next: 'Next', prev: 'Previous' },
    rating: { ariaLabel: { item: 'Rating {0} of {1}' } },
    loading: 'Loading...',
    infiniteScroll: { loadMore: 'Load more', empty: 'No more' },
    rules: {
      required: 'This field is required',
      email: 'Please enter a valid email',
      number: 'This field can only contain numbers',
      integer: 'This field can only contain integer values',
      capital: 'This field can only contain uppercase letters',
      maxLength: 'You must enter a maximum of {0} characters',
      minLength: 'You must enter a minimum of {0} characters',
      strictLength: 'The length of the entered field is invalid',
      exclude: 'The {0} character is not allowed',
      notEmpty: 'Please choose at least one value',
      pattern: 'Invalid format',
    },
    hotkey: {
      then: 'then',
      ctrl: 'Ctrl',
      command: 'Command',
      space: 'Space',
      shift: 'Shift',
      alt: 'Alt',
      enter: 'Enter',
      escape: 'Escape',
      upArrow: 'Up Arrow',
      downArrow: 'Down Arrow',
      leftArrow: 'Left Arrow',
      rightArrow: 'Right Arrow',
      backspace: 'Backspace',
      option: 'Option',
      plus: 'plus',
      shortcut: 'Keyboard shortcut: {0}',
    },
    video: {
      play: 'Play',
      pause: 'Pause',
      seek: 'Seek',
      volume: 'Volume',
      showVolume: 'Show volume control',
      mute: 'Mute',
      unmute: 'Unmute',
      enterFullscreen: 'Full screen',
      exitFullscreen: 'Exit full screen',
    },
    colorPicker: {
      ariaLabel: {
        eyedropper: 'Select color with eyedropper',
        hueSlider: 'Hue',
        alphaSlider: 'Alpha',
        redInput: 'Red value',
        greenInput: 'Green value',
        blueInput: 'Blue value',
        alphaInput: 'Alpha value',
        hueInput: 'Hue value',
        saturationInput: 'Saturation value',
        lightnessInput: 'Lightness value',
        hexInput: 'HEX value',
        hexaInput: 'HEX with alpha value',
        changeFormat: 'Change color format',
      },
    },
  },
  Wv = '$vuetify.',
  Uv = (e, t) => e.replace(/\{(\d+)\}/g, (n, a) => String(t[Number(a)])),
  yy = (e, t, n) =>
    function (a) {
      for (var l = arguments.length, o = new Array(l > 1 ? l - 1 : 0), i = 1; i < l; i++)
        o[i - 1] = arguments[i]
      if (!a.startsWith(Wv)) return Uv(a, o)
      const r = a.replace(Wv, ''),
        s = e.value && n.value[e.value],
        c = t.value && n.value[t.value]
      let u = Za(s, r, null)
      return (
        u || (`${a}${e.value}`, (u = Za(c, r, null))),
        u || (u = a),
        typeof u != 'string' && (u = a),
        Uv(u, o)
      )
    }
function Qc(e, t) {
  return (n, a) => new Intl.NumberFormat([e.value, t.value], a).format(n)
}
function by(e, t) {
  return Qc(e, t)(0.1).includes(',') ? ',' : '.'
}
function As(e, t, n) {
  const a = we(e, t, e[t] ?? n.value)
  return (
    (a.value = e[t] ?? n.value),
    ue(n, (l) => {
      e[t] == null && (a.value = n.value)
    }),
    a
  )
}
function py(e) {
  return (t) => {
    const n = As(t, 'locale', e.current),
      a = As(t, 'fallback', e.fallback),
      l = As(t, 'messages', e.messages)
    return {
      name: 'vuetify',
      current: n,
      fallback: a,
      messages: l,
      decimalSeparator: B(() => by(n, a)),
      t: yy(n, a, l),
      n: Qc(n, a),
      provide: py({ current: n, fallback: a, messages: l }),
    }
  }
}
function z1(e) {
  const t = oe(e?.locale ?? 'en'),
    n = oe(e?.fallback ?? 'en'),
    a = ae({ en: j1, ...e?.messages })
  return {
    name: 'vuetify',
    current: t,
    fallback: n,
    messages: a,
    decimalSeparator: B(() => e?.decimalSeparator ?? by(t, n)),
    t: yy(t, n, a),
    n: Qc(t, n),
    provide: py({ current: t, fallback: n, messages: a }),
  }
}
const Wl = Symbol.for('vuetify:locale')
function W1(e) {
  return e.name != null
}
function U1(e) {
  const t = e?.adapter && W1(e?.adapter) ? e?.adapter : z1(e),
    n = Y1(t, e)
  return { ...t, ...n }
}
function ze() {
  const e = Ve(Wl)
  if (!e) throw new Error('[Vuetify] Could not find injected locale instance')
  return e
}
function K1(e) {
  const t = Ve(Wl)
  if (!t) throw new Error('[Vuetify] Could not find injected locale instance')
  const n = t.provide(e),
    a = q1(n, t.rtl, e),
    l = { ...n, ...a }
  return (Fe(Wl, l), l)
}
function G1() {
  return {
    af: !1,
    ar: !0,
    bg: !1,
    ca: !1,
    ckb: !1,
    cs: !1,
    de: !1,
    el: !1,
    en: !1,
    es: !1,
    et: !1,
    fa: !0,
    fi: !1,
    fr: !1,
    hr: !1,
    hu: !1,
    he: !0,
    id: !1,
    it: !1,
    ja: !1,
    km: !1,
    ko: !1,
    lv: !1,
    lt: !1,
    nl: !1,
    no: !1,
    pl: !1,
    pt: !1,
    ro: !1,
    ru: !1,
    sk: !1,
    sl: !1,
    srCyrl: !1,
    srLatn: !1,
    sv: !1,
    th: !1,
    tr: !1,
    az: !1,
    uk: !1,
    vi: !1,
    zhHans: !1,
    zhHant: !1,
  }
}
function Y1(e, t) {
  const n = ae(t?.rtl ?? G1()),
    a = C(() => n.value[e.current.value] ?? !1)
  return { isRtl: a, rtl: n, rtlClasses: B(() => `v-locale--is-${a.value ? 'rtl' : 'ltr'}`) }
}
function q1(e, t, n) {
  const a = C(() => n.rtl ?? t.value[e.current.value] ?? !1)
  return { isRtl: a, rtl: t, rtlClasses: B(() => `v-locale--is-${a.value ? 'rtl' : 'ltr'}`) }
}
function gt() {
  const e = Ve(Wl)
  if (!e) throw new Error('[Vuetify] Could not find injected rtl instance')
  return { isRtl: e.isRtl, rtlClasses: e.rtlClasses }
}
function ai(e) {
  const t = e.slice(-2).toUpperCase()
  switch (!0) {
    case e === 'GB-alt-variant':
      return { firstDay: 0, firstWeekSize: 4 }
    case e === '001':
      return { firstDay: 1, firstWeekSize: 1 }
    case `AG AS BD BR BS BT BW BZ CA CO DM DO ET GT GU HK HN ID IL IN JM JP KE
    KH KR LA MH MM MO MT MX MZ NI NP PA PE PH PK PR PY SA SG SV TH TT TW UM US
    VE VI WS YE ZA ZW`.includes(t):
      return { firstDay: 0, firstWeekSize: 1 }
    case `AI AL AM AR AU AZ BA BM BN BY CL CM CN CR CY EC GE HR KG KZ LB LK LV
    MD ME MK MN MY NZ RO RS SI TJ TM TR UA UY UZ VN XK`.includes(t):
      return { firstDay: 1, firstWeekSize: 1 }
    case `AD AN AT AX BE BG CH CZ DE DK EE ES FI FJ FO FR GB GF GP GR HU IE IS
    IT LI LT LU MC MQ NL NO PL RE RU SE SK SM VA`.includes(t):
      return { firstDay: 1, firstWeekSize: 4 }
    case 'AE AF BH DJ DZ EG IQ IR JO KW LY OM QA SD SY'.includes(t):
      return { firstDay: 6, firstWeekSize: 1 }
    case t === 'MV':
      return { firstDay: 5, firstWeekSize: 1 }
    case t === 'PT':
      return { firstDay: 0, firstWeekSize: 4 }
    default:
      return null
  }
}
function X1(e, t, n) {
  const a = []
  let l = []
  const o = Sy(e),
    i = wy(e),
    r = n ?? ai(t)?.firstDay ?? 0,
    s = (o.getDay() - r + 7) % 7,
    c = (i.getDay() - r + 7) % 7
  for (let u = 0; u < s; u++) {
    const d = new Date(o)
    ;(d.setDate(d.getDate() - (s - u)), l.push(d))
  }
  for (let u = 1; u <= i.getDate(); u++) {
    const d = new Date(e.getFullYear(), e.getMonth(), u)
    ;(l.push(d), l.length === 7 && (a.push(l), (l = [])))
  }
  for (let u = 1; u < 7 - c; u++) {
    const d = new Date(i)
    ;(d.setDate(d.getDate() + u), l.push(d))
  }
  return (l.length > 0 && a.push(l), a)
}
function fr(e, t, n) {
  let a = (n ?? ai(t)?.firstDay ?? 0) % 7
  ;[0, 1, 2, 3, 4, 5, 6].includes(a) || (a = 0)
  const l = new Date(e)
  for (; l.getDay() !== a; ) l.setDate(l.getDate() - 1)
  return l
}
function Z1(e, t) {
  const n = new Date(e),
    a = ((ai(t)?.firstDay ?? 0) + 6) % 7
  for (; n.getDay() !== a; ) n.setDate(n.getDate() + 1)
  return n
}
function Sy(e) {
  return new Date(e.getFullYear(), e.getMonth(), 1)
}
function wy(e) {
  return new Date(e.getFullYear(), e.getMonth() + 1, 0)
}
function J1(e) {
  const t = e.split('-').map(Number)
  return new Date(t[0], t[1] - 1, t[2])
}
const Q1 = /^([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))$/
function ky(e) {
  if (e == null) return new Date()
  if (e instanceof Date) return e
  if (typeof e == 'string') {
    let t
    if (Q1.test(e)) return J1(e)
    if (((t = Date.parse(e)), !isNaN(t))) return new Date(t)
  }
  return null
}
const Kv = new Date(2e3, 0, 2)
function eP(e, t, n) {
  const a = t ?? ai(e)?.firstDay ?? 0
  return ln(7).map((l) => {
    const o = new Date(Kv)
    return (
      o.setDate(Kv.getDate() + a + l),
      new Intl.DateTimeFormat(e, { weekday: n ?? 'narrow' }).format(o)
    )
  })
}
function tP(e, t, n, a) {
  const l = ky(e) ?? new Date(),
    o = a?.[t]
  if (typeof o == 'function') return o(l, t, n)
  let i = {}
  switch (t) {
    case 'fullDate':
      i = { year: 'numeric', month: 'short', day: 'numeric' }
      break
    case 'fullDateWithWeekday':
      i = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }
      break
    case 'normalDate':
      const r = l.getDate(),
        s = new Intl.DateTimeFormat(n, { month: 'long' }).format(l)
      return `${r} ${s}`
    case 'normalDateWithWeekday':
      i = { weekday: 'short', day: 'numeric', month: 'short' }
      break
    case 'shortDate':
      i = { month: 'short', day: 'numeric' }
      break
    case 'year':
      i = { year: 'numeric' }
      break
    case 'month':
      i = { month: 'long' }
      break
    case 'monthShort':
      i = { month: 'short' }
      break
    case 'monthAndYear':
      i = { month: 'long', year: 'numeric' }
      break
    case 'monthAndDate':
      i = { month: 'long', day: 'numeric' }
      break
    case 'weekday':
      i = { weekday: 'long' }
      break
    case 'weekdayShort':
      i = { weekday: 'short' }
      break
    case 'dayOfMonth':
      return new Intl.NumberFormat(n).format(l.getDate())
    case 'hours12h':
      i = { hour: 'numeric', hour12: !0 }
      break
    case 'hours24h':
      i = { hour: 'numeric', hour12: !1 }
      break
    case 'minutes':
      i = { minute: 'numeric' }
      break
    case 'seconds':
      i = { second: 'numeric' }
      break
    case 'fullTime':
      i = { hour: 'numeric', minute: 'numeric' }
      break
    case 'fullTime12h':
      i = { hour: 'numeric', minute: 'numeric', hour12: !0 }
      break
    case 'fullTime24h':
      i = { hour: 'numeric', minute: 'numeric', hour12: !1 }
      break
    case 'fullDateTime':
      i = { year: 'numeric', month: 'short', day: 'numeric', hour: 'numeric', minute: 'numeric' }
      break
    case 'fullDateTime12h':
      i = {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        hour12: !0,
      }
      break
    case 'fullDateTime24h':
      i = {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        hour12: !1,
      }
      break
    case 'keyboardDate':
      i = { year: 'numeric', month: '2-digit', day: '2-digit' }
      break
    case 'keyboardDateTime':
      return (
        (i = {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: 'numeric',
          minute: 'numeric',
        }),
        new Intl.DateTimeFormat(n, i).format(l).replace(/, /g, ' ')
      )
    case 'keyboardDateTime12h':
      return (
        (i = {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: 'numeric',
          minute: 'numeric',
          hour12: !0,
        }),
        new Intl.DateTimeFormat(n, i).format(l).replace(/, /g, ' ')
      )
    case 'keyboardDateTime24h':
      return (
        (i = {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: 'numeric',
          minute: 'numeric',
          hour12: !1,
        }),
        new Intl.DateTimeFormat(n, i).format(l).replace(/, /g, ' ')
      )
    default:
      i = o ?? { timeZone: 'UTC', timeZoneName: 'short' }
  }
  return new Intl.DateTimeFormat(n, i).format(l)
}
function nP(e, t) {
  const n = e.toJsDate(t),
    a = n.getFullYear(),
    l = _v(String(n.getMonth() + 1), 2, '0'),
    o = _v(String(n.getDate()), 2, '0')
  return `${a}-${l}-${o}`
}
function aP(e) {
  const [t, n, a] = e.split('-').map(Number)
  return new Date(t, n - 1, a)
}
function lP(e, t) {
  const n = new Date(e)
  return (n.setMinutes(n.getMinutes() + t), n)
}
function oP(e, t) {
  const n = new Date(e)
  return (n.setHours(n.getHours() + t), n)
}
function Ka(e, t) {
  const n = new Date(e)
  return (n.setDate(n.getDate() + t), n)
}
function iP(e, t) {
  const n = new Date(e)
  return (n.setDate(n.getDate() + t * 7), n)
}
function rP(e, t) {
  const n = new Date(e)
  return (n.setDate(1), n.setMonth(n.getMonth() + t), n)
}
function Bo(e) {
  return e.getFullYear()
}
function sP(e) {
  return e.getMonth()
}
function uP(e, t, n, a) {
  const l = ai(t),
    o = n ?? l?.firstDay ?? 0,
    i = l?.firstWeekSize ?? 1
  return a !== void 0 ? cP(e, t, o, a) : dP(e, t, o, i)
}
function cP(e, t, n, a) {
  const l = (7 + a - n) % 7,
    o = fr(e, t, n),
    i = Ka(o, 6)
  function r(f) {
    return (7 + new Date(f, 0, 1).getDay() - n) % 7
  }
  let s = Bo(e)
  s < Bo(i) && r(s + 1) <= l && s++
  const c = new Date(s, 0, 1),
    u = r(s),
    d = u <= l ? Ka(c, -u) : Ka(c, 7 - u)
  return 1 + mr(ed(e), Lo(d), 'weeks')
}
function dP(e, t, n, a) {
  const l = Ka(fr(e, t, n), 6)
  function o(u) {
    const d = new Date(u, 0, 1)
    return 7 - mr(d, fr(d, t, n), 'days')
  }
  let i = Bo(e)
  i < Bo(l) && o(i + 1) >= a && i++
  const r = new Date(i, 0, 1),
    s = o(i),
    c = s >= a ? Ka(r, s - 7) : Ka(r, s)
  return 1 + mr(ed(e), Lo(c), 'weeks')
}
function fP(e) {
  return e.getDate()
}
function vP(e) {
  return new Date(e.getFullYear(), e.getMonth() + 1, 1)
}
function mP(e) {
  return new Date(e.getFullYear(), e.getMonth() - 1, 1)
}
function hP(e) {
  return e.getHours()
}
function gP(e) {
  return e.getMinutes()
}
function yP(e) {
  return new Date(e.getFullYear(), 0, 1)
}
function bP(e) {
  return new Date(e.getFullYear(), 11, 31)
}
function pP(e, t) {
  return vr(e, t[0]) && kP(e, t[1])
}
function SP(e) {
  const t = new Date(e)
  return t instanceof Date && !isNaN(t.getTime())
}
function vr(e, t) {
  return e.getTime() > t.getTime()
}
function wP(e, t) {
  return vr(Lo(e), Lo(t))
}
function kP(e, t) {
  return e.getTime() < t.getTime()
}
function Gv(e, t) {
  return e.getTime() === t.getTime()
}
function CP(e, t) {
  return (
    e.getDate() === t.getDate() &&
    e.getMonth() === t.getMonth() &&
    e.getFullYear() === t.getFullYear()
  )
}
function xP(e, t) {
  return e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear()
}
function _P(e, t) {
  return e.getFullYear() === t.getFullYear()
}
function mr(e, t, n) {
  const a = new Date(e),
    l = new Date(t)
  switch (n) {
    case 'years':
      return a.getFullYear() - l.getFullYear()
    case 'quarters':
      return Math.floor(
        (a.getMonth() - l.getMonth() + (a.getFullYear() - l.getFullYear()) * 12) / 4
      )
    case 'months':
      return a.getMonth() - l.getMonth() + (a.getFullYear() - l.getFullYear()) * 12
    case 'weeks':
      return Math.floor((a.getTime() - l.getTime()) / (1e3 * 60 * 60 * 24 * 7))
    case 'days':
      return Math.floor((a.getTime() - l.getTime()) / (1e3 * 60 * 60 * 24))
    case 'hours':
      return Math.floor((a.getTime() - l.getTime()) / (1e3 * 60 * 60))
    case 'minutes':
      return Math.floor((a.getTime() - l.getTime()) / (1e3 * 60))
    case 'seconds':
      return Math.floor((a.getTime() - l.getTime()) / 1e3)
    default:
      return a.getTime() - l.getTime()
  }
}
function PP(e, t) {
  const n = new Date(e)
  return (n.setHours(t), n)
}
function VP(e, t) {
  const n = new Date(e)
  return (n.setMinutes(t), n)
}
function IP(e, t) {
  const n = new Date(e)
  return (n.setMonth(t), n)
}
function TP(e, t) {
  const n = new Date(e)
  return (n.setDate(t), n)
}
function AP(e, t) {
  const n = new Date(e)
  return (n.setFullYear(t), n)
}
function Lo(e) {
  return new Date(e.getFullYear(), e.getMonth(), e.getDate(), 0, 0, 0, 0)
}
function ed(e) {
  return new Date(e.getFullYear(), e.getMonth(), e.getDate(), 23, 59, 59, 999)
}
class EP {
  constructor(t) {
    ;((this.locale = t.locale), (this.formats = t.formats))
  }
  date(t) {
    return ky(t)
  }
  toJsDate(t) {
    return t
  }
  toISO(t) {
    return nP(this, t)
  }
  parseISO(t) {
    return aP(t)
  }
  addMinutes(t, n) {
    return lP(t, n)
  }
  addHours(t, n) {
    return oP(t, n)
  }
  addDays(t, n) {
    return Ka(t, n)
  }
  addWeeks(t, n) {
    return iP(t, n)
  }
  addMonths(t, n) {
    return rP(t, n)
  }
  getWeekArray(t, n) {
    const a = n !== void 0 ? Number(n) : void 0
    return X1(t, this.locale, a)
  }
  startOfWeek(t, n) {
    const a = n !== void 0 ? Number(n) : void 0
    return fr(t, this.locale, a)
  }
  endOfWeek(t) {
    return Z1(t, this.locale)
  }
  startOfMonth(t) {
    return Sy(t)
  }
  endOfMonth(t) {
    return wy(t)
  }
  format(t, n) {
    return tP(t, n, this.locale, this.formats)
  }
  isEqual(t, n) {
    return Gv(t, n)
  }
  isValid(t) {
    return SP(t)
  }
  isWithinRange(t, n) {
    return pP(t, n)
  }
  isAfter(t, n) {
    return vr(t, n)
  }
  isAfterDay(t, n) {
    return wP(t, n)
  }
  isBefore(t, n) {
    return !vr(t, n) && !Gv(t, n)
  }
  isSameDay(t, n) {
    return CP(t, n)
  }
  isSameMonth(t, n) {
    return xP(t, n)
  }
  isSameYear(t, n) {
    return _P(t, n)
  }
  setMinutes(t, n) {
    return VP(t, n)
  }
  setHours(t, n) {
    return PP(t, n)
  }
  setMonth(t, n) {
    return IP(t, n)
  }
  setDate(t, n) {
    return TP(t, n)
  }
  setYear(t, n) {
    return AP(t, n)
  }
  getDiff(t, n, a) {
    return mr(t, n, a)
  }
  getWeekdays(t, n) {
    const a = t !== void 0 ? Number(t) : void 0
    return eP(this.locale, a, n)
  }
  getYear(t) {
    return Bo(t)
  }
  getMonth(t) {
    return sP(t)
  }
  getWeek(t, n, a) {
    const l = n !== void 0 ? Number(n) : void 0,
      o = a !== void 0 ? Number(a) : void 0
    return uP(t, this.locale, l, o)
  }
  getDate(t) {
    return fP(t)
  }
  getNextMonth(t) {
    return vP(t)
  }
  getPreviousMonth(t) {
    return mP(t)
  }
  getHours(t) {
    return hP(t)
  }
  getMinutes(t) {
    return gP(t)
  }
  startOfDay(t) {
    return Lo(t)
  }
  endOfDay(t) {
    return ed(t)
  }
  startOfYear(t) {
    return yP(t)
  }
  endOfYear(t) {
    return bP(t)
  }
}
const Cy = Symbol.for('vuetify:date-options'),
  Yv = Symbol.for('vuetify:date-adapter')
function DP(e, t) {
  const n = Ot(
    {
      adapter: EP,
      locale: {
        af: 'af-ZA',
        bg: 'bg-BG',
        ca: 'ca-ES',
        ckb: '',
        cs: 'cs-CZ',
        de: 'de-DE',
        el: 'el-GR',
        en: 'en-US',
        et: 'et-EE',
        fa: 'fa-IR',
        fi: 'fi-FI',
        hr: 'hr-HR',
        hu: 'hu-HU',
        he: 'he-IL',
        id: 'id-ID',
        it: 'it-IT',
        ja: 'ja-JP',
        ko: 'ko-KR',
        lv: 'lv-LV',
        lt: 'lt-LT',
        nl: 'nl-NL',
        no: 'no-NO',
        pl: 'pl-PL',
        pt: 'pt-PT',
        ro: 'ro-RO',
        ru: 'ru-RU',
        sk: 'sk-SK',
        sl: 'sl-SI',
        srCyrl: 'sr-SP',
        srLatn: 'sr-SP',
        sv: 'sv-SE',
        th: 'th-TH',
        tr: 'tr-TR',
        az: 'az-AZ',
        uk: 'uk-UA',
        vi: 'vi-VN',
        zhHans: 'zh-CN',
        zhHant: 'zh-TW',
      },
    },
    e
  )
  return { options: n, instance: xy(n, t) }
}
function RP(e, t, n) {
  const a = e.getDiff(e.endOfDay(n ?? t), e.startOfDay(t), 'days'),
    l = [t]
  for (let o = 1; o < a; o++) {
    const i = e.addDays(t, o)
    l.push(i)
  }
  return (n && l.push(e.endOfDay(n)), l)
}
function xy(e, t) {
  const n = it(
    typeof e.adapter == 'function'
      ? new e.adapter({ locale: e.locale[t.current.value] ?? t.current.value, formats: e.formats })
      : e.adapter
  )
  return (
    ue(t.current, (a) => {
      n.locale = e.locale[a] ?? a ?? n.locale
    }),
    n
  )
}
function li() {
  const e = Ve(Cy)
  if (!e) throw new Error('[Vuetify] Could not find injected date options')
  const t = ze()
  return xy(e, t)
}
const Lr = ['sm', 'md', 'lg', 'xl', 'xxl'],
  Iu = Symbol.for('vuetify:display'),
  qv = {
    mobileBreakpoint: 'lg',
    thresholds: { xs: 0, sm: 600, md: 960, lg: 1280, xl: 1920, xxl: 2560 },
  },
  MP = function () {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : qv
    return Ot(qv, e)
  }
function Xv(e) {
  return Ne && !e ? window.innerWidth : (typeof e == 'object' && e.clientWidth) || 0
}
function Zv(e) {
  return Ne && !e ? window.innerHeight : (typeof e == 'object' && e.clientHeight) || 0
}
function Jv(e) {
  const t = Ne && !e ? window.navigator.userAgent : 'ssr'
  function n(g) {
    return !!t.match(g)
  }
  const a = n(/android/i),
    l = n(/iphone|ipad|ipod/i),
    o = n(/cordova/i),
    i = n(/electron/i),
    r = n(/chrome/i),
    s = n(/edge/i),
    c = n(/firefox/i),
    u = n(/opera/i),
    d = n(/win/i),
    f = n(/mac/i),
    v = n(/linux/i)
  return {
    android: a,
    ios: l,
    cordova: o,
    electron: i,
    chrome: r,
    edge: s,
    firefox: c,
    opera: u,
    win: d,
    mac: f,
    linux: v,
    touch: Z_,
    ssr: t === 'ssr',
  }
}
function BP(e, t) {
  const { thresholds: n, mobileBreakpoint: a } = MP(e),
    l = oe(Zv(t)),
    o = oe(Jv(t)),
    i = it({}),
    r = oe(Xv(t))
  function s() {
    ;((l.value = Zv()), (r.value = Xv()))
  }
  function c() {
    ;(s(), (o.value = Jv()))
  }
  return (
    qe(() => {
      const u = r.value < n.sm,
        d = r.value < n.md && !u,
        f = r.value < n.lg && !(d || u),
        v = r.value < n.xl && !(f || d || u),
        g = r.value < n.xxl && !(v || f || d || u),
        h = r.value >= n.xxl,
        m = u ? 'xs' : d ? 'sm' : f ? 'md' : v ? 'lg' : g ? 'xl' : 'xxl',
        b = typeof a == 'number' ? a : n[a],
        y = r.value < b
      ;((i.xs = u),
        (i.sm = d),
        (i.md = f),
        (i.lg = v),
        (i.xl = g),
        (i.xxl = h),
        (i.smAndUp = !u),
        (i.mdAndUp = !(u || d)),
        (i.lgAndUp = !(u || d || f)),
        (i.xlAndUp = !(u || d || f || v)),
        (i.smAndDown = !(f || v || g || h)),
        (i.mdAndDown = !(v || g || h)),
        (i.lgAndDown = !(g || h)),
        (i.xlAndDown = !h),
        (i.name = m),
        (i.height = l.value),
        (i.width = r.value),
        (i.mobile = y),
        (i.mobileBreakpoint = a),
        (i.platform = o.value),
        (i.thresholds = n))
    }),
    Ne &&
      (window.addEventListener('resize', s, { passive: !0 }),
      bt(() => {
        window.removeEventListener('resize', s)
      }, !0)),
    { ...Yl(i), update: c, ssr: !!t }
  )
}
const ol = $(
  { mobile: { type: Boolean, default: !1 }, mobileBreakpoint: [Number, String] },
  'display'
)
function gn() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { mobile: null },
    t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Wn()
  const n = Ve(Iu)
  if (!n) throw new Error('Could not find Vuetify display injection')
  const a = C(() =>
      e.mobile
        ? !0
        : typeof e.mobileBreakpoint == 'number'
          ? n.width.value < e.mobileBreakpoint
          : e.mobileBreakpoint
            ? n.width.value < n.thresholds.value[e.mobileBreakpoint]
            : e.mobile === null
              ? n.mobile.value
              : !1
    ),
    l = B(() => (t ? { [`${t}--mobile`]: a.value } : {}))
  return { ...n, displayClasses: l, mobile: a }
}
const _y = Symbol.for('vuetify:goto')
function Py() {
  return {
    container: void 0,
    duration: 300,
    layout: !1,
    offset: 0,
    easing: 'easeInOutCubic',
    patterns: $1,
  }
}
function LP(e) {
  return td(e) ?? (document.scrollingElement || document.body)
}
function td(e) {
  return typeof e == 'string' ? document.querySelector(e) : Wc(e)
}
function Es(e, t, n) {
  if (typeof e == 'number') return t && n ? -e : e
  let a = td(e),
    l = 0
  for (; a; ) ((l += t ? a.offsetLeft : a.offsetTop), (a = a.offsetParent))
  return l
}
function OP(e, t) {
  return { rtl: t.isRtl, options: Ot(Py(), e) }
}
async function Qv(e, t, n, a) {
  const l = n ? 'scrollLeft' : 'scrollTop',
    o = Ot(a?.options ?? Py(), t),
    i = a?.rtl.value,
    r = (typeof e == 'number' ? e : td(e)) ?? 0,
    s = o.container === 'parent' && r instanceof HTMLElement ? r.parentElement : LP(o.container),
    c = On() ? o.patterns.instant : typeof o.easing == 'function' ? o.easing : o.patterns[o.easing]
  if (!c) throw new TypeError(`Easing function "${o.easing}" not found.`)
  let u
  if (typeof r == 'number') u = Es(r, n, i)
  else if (((u = Es(r, n, i) - Es(s, n, i)), o.layout)) {
    const g = window.getComputedStyle(r).getPropertyValue('--v-layout-top')
    g && (u -= parseInt(g, 10))
  }
  ;((u += o.offset), (u = FP(s, u, !!i, !!n)))
  const d = s[l] ?? 0
  if (u === d) return Promise.resolve(u)
  const f = performance.now()
  return new Promise((v) =>
    requestAnimationFrame(function g(h) {
      const b = (h - f) / o.duration,
        y = Math.floor(d + (u - d) * c(Ge(b, 0, 1)))
      if (((s[l] = y), b >= 1 && Math.abs(y - s[l]) < 10)) return v(u)
      if (b > 2) return v(s[l])
      requestAnimationFrame(g)
    })
  )
}
function $P() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
  const t = Ve(_y),
    { isRtl: n } = gt()
  if (!t) throw new Error('[Vuetify] Could not find injected goto instance')
  const a = { ...t, rtl: B(() => t.rtl.value || n.value) }
  async function l(o, i) {
    return Qv(o, Ot(e, i), !1, a)
  }
  return ((l.horizontal = async (o, i) => Qv(o, Ot(e, i), !0, a)), l)
}
function FP(e, t, n, a) {
  const { scrollWidth: l, scrollHeight: o } = e,
    [i, r] =
      e === document.scrollingElement
        ? [window.innerWidth, window.innerHeight]
        : [e.offsetWidth, e.offsetHeight]
  let s, c
  return (
    a ? (n ? ((s = -(l - i)), (c = 0)) : ((s = 0), (c = l - i))) : ((s = 0), (c = o + -r)),
    Ge(t, s, c)
  )
}
const NP = {
    collapse: 'mdi-chevron-up',
    complete: 'mdi-check',
    cancel: 'mdi-close-circle',
    close: 'mdi-close',
    delete: 'mdi-close-circle',
    clear: 'mdi-close-circle',
    success: 'mdi-check-circle',
    info: 'mdi-information',
    warning: 'mdi-alert-circle',
    error: 'mdi-close-circle',
    prev: 'mdi-chevron-left',
    next: 'mdi-chevron-right',
    checkboxOn: 'mdi-checkbox-marked',
    checkboxOff: 'mdi-checkbox-blank-outline',
    checkboxIndeterminate: 'mdi-minus-box',
    delimiter: 'mdi-circle',
    sortAsc: 'mdi-arrow-up',
    sortDesc: 'mdi-arrow-down',
    expand: 'mdi-chevron-down',
    menu: 'mdi-menu',
    subgroup: 'mdi-menu-down',
    dropdown: 'mdi-menu-down',
    radioOn: 'mdi-radiobox-marked',
    radioOff: 'mdi-radiobox-blank',
    edit: 'mdi-pencil',
    ratingEmpty: 'mdi-star-outline',
    ratingFull: 'mdi-star',
    ratingHalf: 'mdi-star-half-full',
    loading: 'mdi-cached',
    first: 'mdi-page-first',
    last: 'mdi-page-last',
    unfold: 'mdi-unfold-more-horizontal',
    file: 'mdi-paperclip',
    plus: 'mdi-plus',
    minus: 'mdi-minus',
    calendar: 'mdi-calendar',
    treeviewCollapse: 'mdi-menu-down',
    treeviewExpand: 'mdi-menu-right',
    tableGroupCollapse: 'mdi-chevron-down',
    tableGroupExpand: 'mdi-chevron-right',
    eyeDropper: 'mdi-eyedropper',
    upload: 'mdi-cloud-upload',
    color: 'mdi-palette',
    command: 'mdi-apple-keyboard-command',
    ctrl: 'mdi-apple-keyboard-control',
    space: 'mdi-keyboard-space',
    shift: 'mdi-apple-keyboard-shift',
    alt: 'mdi-apple-keyboard-option',
    enter: 'mdi-keyboard-return',
    arrowup: 'mdi-arrow-up',
    arrowdown: 'mdi-arrow-down',
    arrowleft: 'mdi-arrow-left',
    arrowright: 'mdi-arrow-right',
    backspace: 'mdi-backspace',
    play: 'mdi-play',
    pause: 'mdi-pause',
    fullscreen: 'mdi-fullscreen',
    fullscreenExit: 'mdi-fullscreen-exit',
    volumeHigh: 'mdi-volume-high',
    volumeMedium: 'mdi-volume-medium',
    volumeLow: 'mdi-volume-low',
    volumeOff: 'mdi-volume-variant-off',
  },
  HP = { component: (e) => ut(ad, { ...e, class: 'mdi' }) },
  Se = [String, Function, Object, Array],
  Tu = Symbol.for('vuetify:icons'),
  Or = $({ icon: { type: Se }, tag: { type: [String, Object, Function], required: !0 } }, 'icon'),
  Au = J()({
    name: 'VComponentIcon',
    props: Or(),
    setup(e, t) {
      let { slots: n } = t
      return () => {
        const a = e.icon
        return w(e.tag, null, { default: () => [e.icon ? w(a, null, null) : n.default?.()] })
      }
    },
  }),
  nd = un({
    name: 'VSvgIcon',
    inheritAttrs: !1,
    props: Or(),
    setup(e, t) {
      let { attrs: n } = t
      return () =>
        w(e.tag, Z(n, { style: null }), {
          default: () => [
            x(
              'svg',
              {
                class: 'v-icon__svg',
                xmlns: 'http://www.w3.org/2000/svg',
                viewBox: '0 0 24 24',
                role: 'img',
                'aria-hidden': 'true',
              },
              [
                Array.isArray(e.icon)
                  ? e.icon.map((a) =>
                      Array.isArray(a)
                        ? x('path', { d: a[0], 'fill-opacity': a[1] }, null)
                        : x('path', { d: a }, null)
                    )
                  : x('path', { d: e.icon }, null),
              ]
            ),
          ],
        })
    },
  }),
  jP = un({
    name: 'VLigatureIcon',
    props: Or(),
    setup(e) {
      return () => w(e.tag, null, { default: () => [e.icon] })
    },
  }),
  ad = un({
    name: 'VClassIcon',
    props: Or(),
    setup(e) {
      return () => w(e.tag, { class: ee(e.icon) }, null)
    },
  })
function zP() {
  return { svg: { component: nd }, class: { component: ad } }
}
function WP(e) {
  const t = zP(),
    n = e?.defaultSet ?? 'mdi'
  return (
    n === 'mdi' && !t.mdi && (t.mdi = HP),
    Ot(
      {
        defaultSet: n,
        sets: t,
        aliases: {
          ...NP,
          vuetify: [
            'M8.2241 14.2009L12 21L22 3H14.4459L8.2241 14.2009Z',
            [
              'M7.26303 12.4733L7.00113 12L2 3H12.5261C12.5261 3 12.5261 3 12.5261 3L7.26303 12.4733Z',
              0.6,
            ],
          ],
          'vuetify-outline':
            'svg:M7.26 12.47 12.53 3H2L7.26 12.47ZM14.45 3 8.22 14.2 12 21 22 3H14.45ZM18.6 5 12 16.88 10.51 14.2 15.62 5ZM7.26 8.35 5.4 5H9.13L7.26 8.35Z',
          'vuetify-play': [
            'm6.376 13.184-4.11-7.192C1.505 4.66 2.467 3 4.003 3h8.532l-.953 1.576-.006.01-.396.677c-.429.732-.214 1.507.194 2.015.404.503 1.092.878 1.869.806a3.72 3.72 0 0 1 1.005.022c.276.053.434.143.523.237.138.146.38.635-.25 2.09-.893 1.63-1.553 1.722-1.847 1.677-.213-.033-.468-.158-.756-.406a4.95 4.95 0 0 1-.8-.927c-.39-.564-1.04-.84-1.66-.846-.625-.006-1.316.27-1.693.921l-.478.826-.911 1.506Z',
            [
              'M9.093 11.552c.046-.079.144-.15.32-.148a.53.53 0 0 1 .43.207c.285.414.636.847 1.046 1.2.405.35.914.662 1.516.754 1.334.205 2.502-.698 3.48-2.495l.014-.028.013-.03c.687-1.574.774-2.852-.005-3.675-.37-.391-.861-.586-1.333-.676a5.243 5.243 0 0 0-1.447-.044c-.173.016-.393-.073-.54-.257-.145-.18-.127-.316-.082-.392l.393-.672L14.287 3h5.71c1.536 0 2.499 1.659 1.737 2.992l-7.997 13.996c-.768 1.344-2.706 1.344-3.473 0l-3.037-5.314 1.377-2.278.004-.006.004-.007.481-.831Z',
              0.6,
            ],
          ],
        },
      },
      e
    )
  )
}
const UP = (e) => {
    const t = Ve(Tu)
    if (!t) throw new Error('Missing Vuetify Icons provide!')
    return {
      iconData: C(() => {
        const a = Ft(e)
        if (!a) return { component: Au }
        let l = a
        if (
          (typeof l == 'string' &&
            ((l = l.trim()), l.startsWith('$') && (l = t.aliases?.[l.slice(1)])),
          Array.isArray(l))
        )
          return { component: nd, icon: l }
        if (typeof l != 'string') return { component: Au, icon: l }
        const o = Object.keys(t.sets).find((s) => typeof l == 'string' && l.startsWith(`${s}:`)),
          i = o ? l.slice(o.length + 1) : l
        return { component: t.sets[o ?? t.defaultSet].component, icon: i }
      }),
    }
  },
  Oo = Symbol.for('vuetify:theme'),
  Be = $({ theme: String }, 'theme')
function em() {
  return {
    defaultTheme: 'light',
    prefix: 'v-',
    variations: { colors: [], lighten: 0, darken: 0 },
    themes: {
      light: {
        dark: !1,
        colors: {
          background: '#FFFFFF',
          surface: '#FFFFFF',
          'surface-bright': '#FFFFFF',
          'surface-light': '#EEEEEE',
          'surface-variant': '#424242',
          'on-surface-variant': '#EEEEEE',
          primary: '#1867C0',
          'primary-darken-1': '#1F5592',
          secondary: '#48A9A6',
          'secondary-darken-1': '#018786',
          error: '#B00020',
          info: '#2196F3',
          success: '#4CAF50',
          warning: '#FB8C00',
        },
        variables: {
          'border-color': '#000000',
          'border-opacity': 0.12,
          'high-emphasis-opacity': 0.87,
          'medium-emphasis-opacity': 0.6,
          'disabled-opacity': 0.38,
          'idle-opacity': 0.04,
          'hover-opacity': 0.04,
          'focus-opacity': 0.12,
          'selected-opacity': 0.08,
          'activated-opacity': 0.12,
          'pressed-opacity': 0.12,
          'dragged-opacity': 0.08,
          'theme-kbd': '#EEEEEE',
          'theme-on-kbd': '#000000',
          'theme-code': '#F5F5F5',
          'theme-on-code': '#000000',
        },
      },
      dark: {
        dark: !0,
        colors: {
          background: '#121212',
          surface: '#212121',
          'surface-bright': '#ccbfd6',
          'surface-light': '#424242',
          'surface-variant': '#c8c8c8',
          'on-surface-variant': '#000000',
          primary: '#2196F3',
          'primary-darken-1': '#277CC1',
          secondary: '#54B6B2',
          'secondary-darken-1': '#48A9A6',
          error: '#CF6679',
          info: '#2196F3',
          success: '#4CAF50',
          warning: '#FB8C00',
        },
        variables: {
          'border-color': '#FFFFFF',
          'border-opacity': 0.12,
          'high-emphasis-opacity': 1,
          'medium-emphasis-opacity': 0.7,
          'disabled-opacity': 0.5,
          'idle-opacity': 0.1,
          'hover-opacity': 0.04,
          'focus-opacity': 0.12,
          'selected-opacity': 0.08,
          'activated-opacity': 0.12,
          'pressed-opacity': 0.16,
          'dragged-opacity': 0.08,
          'theme-kbd': '#424242',
          'theme-on-kbd': '#FFFFFF',
          'theme-code': '#343434',
          'theme-on-code': '#CCCCCC',
        },
      },
    },
    stylesheetId: 'vuetify-theme-stylesheet',
    scoped: !1,
    unimportant: !1,
    utilities: !0,
  }
}
function KP() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : em()
  const t = em()
  if (!e) return { ...t, isDisabled: !0 }
  const n = {}
  for (const [a, l] of Object.entries(e.themes ?? {})) {
    const o = l.dark || a === 'dark' ? t.themes?.dark : t.themes?.light
    n[a] = Ot(o, l)
  }
  return Ot(t, { ...e, themes: n })
}
function Ba(e, t, n, a) {
  e.push(
    `${XP(t, a)} {
`,
    ...n.map(
      (l) => `  ${l};
`
    ),
    `}
`
  )
}
function tm(e, t) {
  const n = e.dark ? 2 : 1,
    a = e.dark ? 1 : 2,
    l = []
  for (const [o, i] of Object.entries(e.colors)) {
    const r = on(i)
    ;(l.push(`--${t}theme-${o}: ${r.r},${r.g},${r.b}`),
      o.startsWith('on-') || l.push(`--${t}theme-${o}-overlay-multiplier: ${Vu(i) > 0.18 ? n : a}`))
  }
  for (const [o, i] of Object.entries(e.variables)) {
    const r = typeof i == 'string' && i.startsWith('#') ? on(i) : void 0,
      s = r ? `${r.r}, ${r.g}, ${r.b}` : void 0
    l.push(`--${t}${o}: ${s ?? i}`)
  }
  return l
}
function GP(e, t, n) {
  const a = {}
  if (n)
    for (const l of ['lighten', 'darken']) {
      const o = l === 'lighten' ? A1 : E1
      for (const i of ln(n[l], 1)) a[`${e}-${l}-${i}`] = fy(o(on(t), i))
    }
  return a
}
function YP(e, t) {
  if (!t) return {}
  let n = {}
  for (const a of t.colors) {
    const l = e[a]
    l && (n = { ...n, ...GP(a, l, t) })
  }
  return n
}
function qP(e) {
  const t = {}
  for (const n of Object.keys(e)) {
    if (n.startsWith('on-') || e[`on-${n}`]) continue
    const a = `on-${n}`,
      l = on(e[n])
    t[a] = hy(l)
  }
  return t
}
function XP(e, t) {
  if (!t) return e
  const n = `:where(${t})`
  return e === ':root' ? n : `${n} ${e}`
}
function ZP(e, t, n) {
  const a = JP(e, t)
  a && (a.innerHTML = n)
}
function JP(e, t) {
  if (!Ne) return null
  let n = document.getElementById(e)
  return (
    n ||
      ((n = document.createElement('style')),
      (n.id = e),
      (n.type = 'text/css'),
      t && n.setAttribute('nonce', t),
      document.head.appendChild(n)),
    n
  )
}
function QP(e) {
  const t = KP(e),
    n = oe(t.defaultTheme),
    a = ae(t.themes),
    l = oe('light'),
    o = C({
      get() {
        return n.value === 'system' ? l.value : n.value
      },
      set(b) {
        n.value = b
      },
    }),
    i = C(() => {
      const b = {}
      for (const [y, p] of Object.entries(a.value)) {
        const S = { ...p.colors, ...YP(p.colors, t.variations) }
        b[y] = { ...p, colors: { ...S, ...qP(S) } }
      }
      return b
    }),
    r = B(() => i.value[o.value]),
    s = B(() => n.value === 'system'),
    c = C(() => {
      const b = [],
        y = t.unimportant ? '' : ' !important',
        p = t.scoped ? t.prefix : ''
      ;(r.value?.dark && Ba(b, ':root', ['color-scheme: dark'], t.scope),
        Ba(b, ':root', tm(r.value, t.prefix), t.scope))
      for (const [S, k] of Object.entries(i.value))
        Ba(
          b,
          `.${t.prefix}theme--${S}`,
          [`color-scheme: ${k.dark ? 'dark' : 'normal'}`, ...tm(k, t.prefix)],
          t.scope
        )
      if (t.utilities) {
        const S = [],
          k = [],
          _ = new Set(Object.values(i.value).flatMap((P) => Object.keys(P.colors)))
        for (const P of _)
          P.startsWith('on-')
            ? Ba(k, `.${P}`, [`color: rgb(var(--${t.prefix}theme-${P}))${y}`], t.scope)
            : (Ba(
                S,
                `.${p}bg-${P}`,
                [
                  `--${t.prefix}theme-overlay-multiplier: var(--${t.prefix}theme-${P}-overlay-multiplier)`,
                  `background-color: rgb(var(--${t.prefix}theme-${P}))${y}`,
                  `color: rgb(var(--${t.prefix}theme-on-${P}))${y}`,
                ],
                t.scope
              ),
              Ba(k, `.${p}text-${P}`, [`color: rgb(var(--${t.prefix}theme-${P}))${y}`], t.scope),
              Ba(
                k,
                `.${p}border-${P}`,
                [`--${t.prefix}border-color: var(--${t.prefix}theme-${P})`],
                t.scope
              ))
        b.push(...S, ...k)
      }
      return b.map((S, k) => (k === 0 ? S : `    ${S}`)).join('')
    }),
    u = B(() => (t.isDisabled ? void 0 : `${t.prefix}theme--${o.value}`)),
    d = B(() => Object.keys(i.value))
  if (zc) {
    let y = function () {
      l.value = b.matches ? 'dark' : 'light'
    }
    const b = window.matchMedia('(prefers-color-scheme: dark)')
    ;(y(),
      b.addEventListener('change', y, { passive: !0 }),
      fc() &&
        bt(() => {
          b.removeEventListener('change', y)
        }))
  }
  function f(b) {
    if (t.isDisabled) return
    const y = b._context.provides.usehead
    if (y) {
      let p = function () {
        return { style: [{ textContent: c.value, id: t.stylesheetId, nonce: t.cspNonce || !1 }] }
      }
      if (y.push) {
        const S = y.push(p)
        Ne &&
          ue(c, () => {
            S.patch(p)
          })
      } else Ne ? (y.addHeadObjs(B(p)), qe(() => y.updateDOM())) : y.addHeadObjs(p())
    } else {
      let p = function () {
        ZP(t.stylesheetId, t.cspNonce, c.value)
      }
      Ne ? ue(c, p, { immediate: !0 }) : p()
    }
  }
  function v(b) {
    ;(b !== 'system' && !d.value.includes(b)) || (o.value = b)
  }
  function g() {
    let b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : d.value
    const y = b.indexOf(o.value),
      p = y === -1 ? 0 : (y + 1) % b.length
    v(b[p])
  }
  function h() {
    let b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ['light', 'dark']
    g(b)
  }
  const m = new Proxy(o, {
    get(b, y) {
      return Reflect.get(b, y)
    },
    set(b, y, p) {
      return (
        y === 'value' && iy(`theme.global.name.value = ${p}`, `theme.change('${p}')`),
        Reflect.set(b, y, p)
      )
    },
  })
  return {
    install: f,
    change: v,
    cycle: g,
    toggle: h,
    isDisabled: t.isDisabled,
    isSystem: s,
    name: o,
    themes: a,
    current: r,
    computedThemes: i,
    prefix: t.prefix,
    themeClasses: u,
    styles: c,
    global: { name: m, current: r },
  }
}
function $e(e) {
  rt('provideTheme')
  const t = Ve(Oo, null)
  if (!t) throw new Error('Could not find Vuetify theme injection')
  const n = B(() => e.theme ?? t.name.value),
    a = B(() => t.themes.value[n.value]),
    l = B(() => (t.isDisabled ? void 0 : `${t.prefix}theme--${n.value}`)),
    o = { ...t, name: n, current: a, themeClasses: l }
  return (Fe(Oo, o), o)
}
function ld() {
  rt('useTheme')
  const e = Ve(Oo, null)
  if (!e) throw new Error('Could not find Vuetify theme injection')
  return e
}
function hn(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'content'
  const n = sr(),
    a = ae()
  if (Ne) {
    const l = new ResizeObserver((o) => {
      ;(e?.(o, l),
        o.length &&
          (t === 'content'
            ? (a.value = o[0].contentRect)
            : (a.value = o[0].target.getBoundingClientRect())))
    })
    ;(dt(() => {
      l.disconnect()
    }),
      ue(
        () => n.el,
        (o, i) => {
          ;(i && (l.unobserve(i), (a.value = void 0)), o && l.observe(o))
        },
        { flush: 'post' }
      ))
  }
  return { resizeRef: n, contentRect: qa(a) }
}
const $o = Symbol.for('vuetify:layout'),
  Vy = Symbol.for('vuetify:layout-item'),
  nm = 1e3,
  Iy = $({ overlaps: { type: Array, default: () => [] }, fullHeight: Boolean }, 'layout'),
  il = $(
    { name: { type: String }, order: { type: [Number, String], default: 0 }, absolute: Boolean },
    'layout-item'
  )
function Ty() {
  const e = Ve($o)
  if (!e) throw new Error('[Vuetify] Could not find injected layout')
  return { getLayoutItem: e.getLayoutItem, mainRect: e.mainRect, mainStyles: e.mainStyles }
}
function rl(e) {
  const t = Ve($o)
  if (!t) throw new Error('[Vuetify] Could not find injected layout')
  const n = e.id ?? `layout-item-${Rt()}`,
    a = rt('useLayoutItem')
  Fe(Vy, { id: n })
  const l = oe(!1)
  ;(kr(() => (l.value = !0)), Cc(() => (l.value = !1)))
  const { layoutItemStyles: o, layoutItemScrimStyles: i } = t.register(a, {
    ...e,
    active: C(() => (l.value ? !1 : e.active.value)),
    id: n,
  })
  return (
    dt(() => t.unregister(n)),
    { layoutItemStyles: o, layoutRect: t.layoutRect, layoutItemScrimStyles: i }
  )
}
const eV = (e, t, n, a) => {
  let l = { top: 0, left: 0, right: 0, bottom: 0 }
  const o = [{ id: '', layer: { ...l } }]
  for (const i of e) {
    const r = t.get(i),
      s = n.get(i),
      c = a.get(i)
    if (!r || !s || !c) continue
    const u = { ...l, [r.value]: parseInt(l[r.value], 10) + (c.value ? parseInt(s.value, 10) : 0) }
    ;(o.push({ id: i, layer: u }), (l = u))
  }
  return o
}
function Ay(e) {
  const t = Ve($o, null),
    n = C(() => (t ? t.rootZIndex.value - 100 : nm)),
    a = ae([]),
    l = it(new Map()),
    o = it(new Map()),
    i = it(new Map()),
    r = it(new Map()),
    s = it(new Map()),
    { resizeRef: c, contentRect: u } = hn(),
    d = C(() => {
      const _ = new Map(),
        P = e.overlaps ?? []
      for (const A of P.filter((D) => D.includes(':'))) {
        const [D, E] = A.split(':')
        if (!a.value.includes(D) || !a.value.includes(E)) continue
        const R = l.get(D),
          V = l.get(E),
          M = o.get(D),
          F = o.get(E)
        !R ||
          !V ||
          !M ||
          !F ||
          (_.set(E, { position: R.value, amount: parseInt(M.value, 10) }),
          _.set(D, { position: V.value, amount: -parseInt(F.value, 10) }))
      }
      return _
    }),
    f = C(() => {
      const _ = [...new Set([...i.values()].map((A) => A.value))].sort((A, D) => A - D),
        P = []
      for (const A of _) {
        const D = a.value.filter((E) => i.get(E)?.value === A)
        P.push(...D)
      }
      return eV(P, l, o, r)
    }),
    v = C(() => !Array.from(s.values()).some((_) => _.value)),
    g = C(() => f.value[f.value.length - 1].layer),
    h = B(() => ({
      '--v-layout-left': fe(g.value.left),
      '--v-layout-right': fe(g.value.right),
      '--v-layout-top': fe(g.value.top),
      '--v-layout-bottom': fe(g.value.bottom),
      ...(v.value ? void 0 : { transition: 'none' }),
    })),
    m = C(() =>
      f.value.slice(1).map((_, P) => {
        let { id: A } = _
        const { layer: D } = f.value[P],
          E = o.get(A),
          R = l.get(A)
        return { id: A, ...D, size: Number(E.value), position: R.value }
      })
    ),
    b = (_) => m.value.find((P) => P.id === _),
    y = rt('createLayout'),
    p = oe(!1)
  ;(pt(() => {
    p.value = !0
  }),
    Fe($o, {
      register: (_, P) => {
        let {
          id: A,
          order: D,
          position: E,
          layoutSize: R,
          elementSize: V,
          active: M,
          disableTransitions: F,
          absolute: G,
        } = P
        ;(i.set(A, D), l.set(A, E), o.set(A, R), r.set(A, M), F && s.set(A, F))
        const te = _l(Vy, y?.vnode).indexOf(_)
        te > -1 ? a.value.splice(te, 0, A) : a.value.push(A)
        const H = C(() => m.value.findIndex((Y) => Y.id === A)),
          O = C(() => n.value + f.value.length * 2 - H.value * 2),
          j = C(() => {
            const Y = E.value === 'left' || E.value === 'right',
              K = E.value === 'right',
              se = E.value === 'bottom',
              de = V.value ?? R.value,
              ye = de === 0 ? '%' : 'px',
              L = {
                [E.value]: 0,
                zIndex: O.value,
                transform: `translate${Y ? 'X' : 'Y'}(${(M.value ? 0 : -(de === 0 ? 100 : de)) * (K || se ? -1 : 1)}${ye})`,
                position: G.value || n.value !== nm ? 'absolute' : 'fixed',
                ...(v.value ? void 0 : { transition: 'none' }),
              }
            if (!p.value) return L
            const q = m.value[H.value],
              le = d.value.get(A)
            return (
              le && (q[le.position] += le.amount),
              {
                ...L,
                height: Y
                  ? `calc(100% - ${q.top}px - ${q.bottom}px)`
                  : V.value
                    ? `${V.value}px`
                    : void 0,
                left: K ? void 0 : `${q.left}px`,
                right: K ? `${q.right}px` : void 0,
                top: E.value !== 'bottom' ? `${q.top}px` : void 0,
                bottom: E.value !== 'top' ? `${q.bottom}px` : void 0,
                width: Y
                  ? V.value
                    ? `${V.value}px`
                    : void 0
                  : `calc(100% - ${q.left}px - ${q.right}px)`,
              }
            )
          }),
          U = C(() => ({ zIndex: O.value - 1 }))
        return { layoutItemStyles: j, layoutItemScrimStyles: U, zIndex: O }
      },
      unregister: (_) => {
        ;(i.delete(_),
          l.delete(_),
          o.delete(_),
          r.delete(_),
          s.delete(_),
          (a.value = a.value.filter((P) => P !== _)))
      },
      mainRect: g,
      mainStyles: h,
      getLayoutItem: b,
      items: m,
      layoutRect: u,
      rootZIndex: n,
    }))
  const S = B(() => ['v-layout', { 'v-layout--full-height': e.fullHeight }]),
    k = B(() => ({
      zIndex: t ? n.value : void 0,
      position: t ? 'relative' : void 0,
      overflow: t ? 'hidden' : void 0,
    }))
  return {
    layoutClasses: S,
    layoutStyles: k,
    getLayoutItem: b,
    items: m,
    layoutRect: u,
    layoutRef: c,
  }
}
function Ey() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
  const { blueprint: t, ...n } = e,
    a = Ot(t, n),
    { aliases: l = {}, components: o = {}, directives: i = {} } = a,
    r = Ya()
  return r.run(() => {
    const s = M1(a.defaults),
      c = BP(a.display, a.ssr),
      u = QP(a.theme),
      d = WP(a.icons),
      f = U1(a.locale),
      v = DP(a.date, f),
      g = OP(a.goTo, f)
    function h(b) {
      for (const p in i) b.directive(p, i[p])
      for (const p in o) b.component(p, o[p])
      for (const p in l) b.component(p, un({ ...l[p], name: p, aliasName: l[p].name }))
      const y = Ya()
      if (
        (y.run(() => {
          u.install(b)
        }),
        b.onUnmount(() => y.stop()),
        b.provide(zl, s),
        b.provide(Iu, c),
        b.provide(Oo, u),
        b.provide(Tu, d),
        b.provide(Wl, f),
        b.provide(Cy, v.options),
        b.provide(Yv, v.instance),
        b.provide(_y, g),
        Ne && a.ssr)
      )
        if (b.$nuxt)
          b.$nuxt.hook('app:suspense:resolve', () => {
            c.update()
          })
        else {
          const { mount: p } = b
          b.mount = function () {
            const S = p(...arguments)
            return (Re(() => c.update()), (b.mount = p), S)
          }
        }
      b.mixin({
        computed: {
          $vuetify() {
            return it({
              defaults: pl.call(this, zl),
              display: pl.call(this, Iu),
              theme: pl.call(this, Oo),
              icons: pl.call(this, Tu),
              locale: pl.call(this, Wl),
              date: pl.call(this, Yv),
            })
          },
        },
      })
    }
    function m() {
      r.stop()
    }
    return {
      install: h,
      unmount: m,
      defaults: s,
      display: c,
      theme: u,
      icons: d,
      locale: f,
      date: v,
      goTo: g,
    }
  })
}
const tV = '3.10.3'
Ey.version = tV
function pl(e) {
  const t = this.$,
    n = t.parent?.provides ?? t.vnode.appContext?.provides
  if (n && e in n) return n[e]
}
const nV = $({ ...be(), ...je(Iy(), ['fullHeight']), ...Be() }, 'VApp'),
  od = J()({
    name: 'VApp',
    props: nV(),
    setup(e, t) {
      let { slots: n } = t
      const a = $e(e),
        {
          layoutClasses: l,
          getLayoutItem: o,
          items: i,
          layoutRef: r,
        } = Ay({ ...e, fullHeight: !0 }),
        { rtlClasses: s } = gt()
      return (
        ne(() =>
          x(
            'div',
            {
              ref: r,
              class: ee(['v-application', a.themeClasses.value, l.value, s.value, e.class]),
              style: ce([e.style]),
            },
            [x('div', { class: 'v-application__wrap' }, [n.default?.()])]
          )
        ),
        { getLayoutItem: o, items: i, theme: a }
      )
    },
  }),
  Ie = $({ tag: { type: [String, Object, Function], default: 'div' } }, 'tag'),
  Dy = $({ text: String, ...be(), ...Ie() }, 'VToolbarTitle'),
  id = J()({
    name: 'VToolbarTitle',
    props: Dy(),
    setup(e, t) {
      let { slots: n } = t
      return (
        ne(() => {
          const a = !!(n.default || n.text || e.text)
          return w(
            e.tag,
            { class: ee(['v-toolbar-title', e.class]), style: ce(e.style) },
            {
              default: () => [
                a &&
                  x('div', { class: 'v-toolbar-title__placeholder' }, [
                    n.text ? n.text() : e.text,
                    n.default?.(),
                  ]),
              ],
            }
          )
        }),
        {}
      )
    },
  }),
  aV = $(
    {
      disabled: Boolean,
      group: Boolean,
      hideOnLeave: Boolean,
      leaveAbsolute: Boolean,
      mode: String,
      origin: String,
    },
    'transition'
  )
function cn(e, t, n) {
  return J()({
    name: e,
    props: aV({ mode: n, origin: t }),
    setup(a, l) {
      let { slots: o } = l
      const i = {
        onBeforeEnter(r) {
          a.origin && (r.style.transformOrigin = a.origin)
        },
        onLeave(r) {
          if (a.leaveAbsolute) {
            const { offsetTop: s, offsetLeft: c, offsetWidth: u, offsetHeight: d } = r
            ;((r._transitionInitialStyles = {
              position: r.style.position,
              top: r.style.top,
              left: r.style.left,
              width: r.style.width,
              height: r.style.height,
            }),
              (r.style.position = 'absolute'),
              (r.style.top = `${s}px`),
              (r.style.left = `${c}px`),
              (r.style.width = `${u}px`),
              (r.style.height = `${d}px`))
          }
          a.hideOnLeave && r.style.setProperty('display', 'none', 'important')
        },
        onAfterLeave(r) {
          if (a.leaveAbsolute && r?._transitionInitialStyles) {
            const { position: s, top: c, left: u, width: d, height: f } = r._transitionInitialStyles
            ;(delete r._transitionInitialStyles,
              (r.style.position = s || ''),
              (r.style.top = c || ''),
              (r.style.left = u || ''),
              (r.style.width = d || ''),
              (r.style.height = f || ''))
          }
        },
      }
      return () => {
        const r = a.group ? Ac : la
        return ut(
          r,
          {
            name: a.disabled ? '' : e,
            css: !a.disabled,
            ...(a.group ? void 0 : { mode: a.mode }),
            ...(a.disabled ? {} : i),
          },
          o.default
        )
      }
    },
  })
}
function Ry(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'in-out'
  return J()({
    name: e,
    props: {
      mode: { type: String, default: n },
      disabled: { type: Boolean, default: On() },
      group: Boolean,
    },
    setup(a, l) {
      let { slots: o } = l
      const i = a.group ? Ac : la
      return () =>
        ut(i, { name: a.disabled ? '' : e, css: !a.disabled, ...(a.disabled ? {} : t) }, o.default)
    },
  })
}
function My() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ''
  const n = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1)
      ? 'width'
      : 'height',
    a = Wt(`offset-${n}`)
  return {
    onBeforeEnter(i) {
      ;((i._parent = i.parentNode),
        (i._initialStyle = {
          transition: i.style.transition,
          overflow: i.style.overflow,
          [n]: i.style[n],
        }))
    },
    onEnter(i) {
      const r = i._initialStyle
      if (!r) return
      ;(i.style.setProperty('transition', 'none', 'important'), (i.style.overflow = 'hidden'))
      const s = `${i[a]}px`
      ;((i.style[n] = '0'),
        i.offsetHeight,
        (i.style.transition = r.transition),
        e && i._parent && i._parent.classList.add(e),
        requestAnimationFrame(() => {
          i.style[n] = s
        }))
    },
    onAfterEnter: o,
    onEnterCancelled: o,
    onLeave(i) {
      ;((i._initialStyle = { transition: '', overflow: i.style.overflow, [n]: i.style[n] }),
        (i.style.overflow = 'hidden'),
        (i.style[n] = `${i[a]}px`),
        i.offsetHeight,
        requestAnimationFrame(() => (i.style[n] = '0')))
    },
    onAfterLeave: l,
    onLeaveCancelled: l,
  }
  function l(i) {
    ;(e && i._parent && i._parent.classList.remove(e), o(i))
  }
  function o(i) {
    if (!i._initialStyle) return
    const r = i._initialStyle[n]
    ;((i.style.overflow = i._initialStyle.overflow),
      r != null && (i.style[n] = r),
      delete i._initialStyle)
  }
}
const lV = $({ target: [Object, Array] }, 'v-dialog-transition'),
  Ds = new WeakMap(),
  $r = J()({
    name: 'VDialogTransition',
    props: lV(),
    setup(e, t) {
      let { slots: n } = t
      const a = {
        onBeforeEnter(l) {
          ;((l.style.pointerEvents = 'none'), (l.style.visibility = 'hidden'))
        },
        async onEnter(l, o) {
          ;(await new Promise((f) => requestAnimationFrame(f)),
            await new Promise((f) => requestAnimationFrame(f)),
            (l.style.visibility = ''))
          const i = lm(e.target, l),
            { x: r, y: s, sx: c, sy: u, speed: d } = i
          if ((Ds.set(l, i), On()))
            Zn(l, [{ opacity: 0 }, {}], { duration: 125 * d, easing: Hv }).finished.then(() => o())
          else {
            const f = Zn(
              l,
              [{ transform: `translate(${r}px, ${s}px) scale(${c}, ${u})`, opacity: 0 }, {}],
              { duration: 225 * d, easing: Hv }
            )
            ;(am(l)?.forEach((v) => {
              Zn(v, [{ opacity: 0 }, { opacity: 0, offset: 0.33 }, {}], {
                duration: 450 * d,
                easing: Mo,
              })
            }),
              f.finished.then(() => o()))
          }
        },
        onAfterEnter(l) {
          l.style.removeProperty('pointer-events')
        },
        onBeforeLeave(l) {
          l.style.pointerEvents = 'none'
        },
        async onLeave(l, o) {
          await new Promise((f) => requestAnimationFrame(f))
          let i
          !Ds.has(l) ||
          Array.isArray(e.target) ||
          e.target.offsetParent ||
          e.target.getClientRects().length
            ? (i = lm(e.target, l))
            : (i = Ds.get(l))
          const { x: r, y: s, sx: c, sy: u, speed: d } = i
          On()
            ? Zn(l, [{}, { opacity: 0 }], { duration: 85 * d, easing: jv }).finished.then(() => o())
            : (Zn(
                l,
                [{}, { transform: `translate(${r}px, ${s}px) scale(${c}, ${u})`, opacity: 0 }],
                { duration: 125 * d, easing: jv }
              ).finished.then(() => o()),
              am(l)?.forEach((v) => {
                Zn(v, [{}, { opacity: 0, offset: 0.2 }, { opacity: 0 }], {
                  duration: 250 * d,
                  easing: Mo,
                })
              }))
        },
        onAfterLeave(l) {
          l.style.removeProperty('pointer-events')
        },
      }
      return () =>
        e.target
          ? w(la, Z({ name: 'dialog-transition' }, a, { css: !1 }), n)
          : w(la, { name: 'dialog-transition' }, n)
    },
  })
function am(e) {
  const t = e.querySelector(':scope > .v-card, :scope > .v-sheet, :scope > .v-list')?.children
  return t && [...t]
}
function lm(e, t) {
  const n = oy(e),
    a = Gc(t),
    [l, o] = getComputedStyle(t)
      .transformOrigin.split(' ')
      .map((b) => parseFloat(b)),
    [i, r] = getComputedStyle(t).getPropertyValue('--v-overlay-anchor-origin').split(' ')
  let s = n.left + n.width / 2
  i === 'left' || r === 'left'
    ? (s -= n.width / 2)
    : (i === 'right' || r === 'right') && (s += n.width / 2)
  let c = n.top + n.height / 2
  i === 'top' || r === 'top'
    ? (c -= n.height / 2)
    : (i === 'bottom' || r === 'bottom') && (c += n.height / 2)
  const u = n.width / a.width,
    d = n.height / a.height,
    f = Math.max(1, u, d),
    v = u / f || 0,
    g = d / f || 0,
    h = (a.width * a.height) / (window.innerWidth * window.innerHeight),
    m = h > 0.12 ? Math.min(1.5, (h - 0.12) * 10 + 1) : 1
  return { x: s - (l + a.left), y: c - (o + a.top), sx: v, sy: g, speed: m }
}
const oV = cn('fab-transition', 'center center', 'out-in'),
  iV = cn('dialog-bottom-transition'),
  rV = cn('dialog-top-transition'),
  Fo = cn('fade-transition'),
  rd = cn('scale-transition'),
  sV = cn('scroll-x-transition'),
  uV = cn('scroll-x-reverse-transition'),
  cV = cn('scroll-y-transition'),
  dV = cn('scroll-y-reverse-transition'),
  fV = cn('slide-x-transition'),
  vV = cn('slide-x-reverse-transition'),
  sd = cn('slide-y-transition'),
  mV = cn('slide-y-reverse-transition'),
  Fr = Ry('expand-transition', My()),
  ud = Ry('expand-x-transition', My('', !0)),
  hV = $(
    {
      defaults: Object,
      disabled: Boolean,
      reset: [Number, String],
      root: [Boolean, String],
      scoped: Boolean,
    },
    'VDefaultsProvider'
  ),
  Ae = J(!1)({
    name: 'VDefaultsProvider',
    props: hV(),
    setup(e, t) {
      let { slots: n } = t
      const { defaults: a, disabled: l, reset: o, root: i, scoped: r } = Yl(e)
      return (lt(a, { reset: o, root: i, scoped: r, disabled: l }), () => n.default?.())
    },
  }),
  ft = $(
    {
      height: [Number, String],
      maxHeight: [Number, String],
      maxWidth: [Number, String],
      minHeight: [Number, String],
      minWidth: [Number, String],
      width: [Number, String],
    },
    'dimension'
  )
function vt(e) {
  return {
    dimensionStyles: C(() => {
      const n = {},
        a = fe(e.height),
        l = fe(e.maxHeight),
        o = fe(e.maxWidth),
        i = fe(e.minHeight),
        r = fe(e.minWidth),
        s = fe(e.width)
      return (
        a != null && (n.height = a),
        l != null && (n.maxHeight = l),
        o != null && (n.maxWidth = o),
        i != null && (n.minHeight = i),
        r != null && (n.minWidth = r),
        s != null && (n.width = s),
        n
      )
    }),
  }
}
function gV(e) {
  return {
    aspectStyles: C(() => {
      const t = Number(e.aspectRatio)
      return t ? { paddingBottom: String((1 / t) * 100) + '%' } : void 0
    }),
  }
}
const By = $(
    { aspectRatio: [String, Number], contentClass: null, inline: Boolean, ...be(), ...ft() },
    'VResponsive'
  ),
  Eu = J()({
    name: 'VResponsive',
    props: By(),
    setup(e, t) {
      let { slots: n } = t
      const { aspectStyles: a } = gV(e),
        { dimensionStyles: l } = vt(e)
      return (
        ne(() =>
          x(
            'div',
            {
              class: ee(['v-responsive', { 'v-responsive--inline': e.inline }, e.class]),
              style: ce([l.value, e.style]),
            },
            [
              x('div', { class: 'v-responsive__sizer', style: ce(a.value) }, null),
              n.additional?.(),
              n.default &&
                x('div', { class: ee(['v-responsive__content', e.contentClass]) }, [n.default()]),
            ]
          )
        ),
        {}
      )
    },
  })
function cd(e) {
  return Kc(() => {
    const { class: t, style: n } = yV(e)
    return { colorClasses: t, colorStyles: n }
  })
}
function Vt(e) {
  const { colorClasses: t, colorStyles: n } = cd(() => ({ text: Ft(e) }))
  return { textColorClasses: t, textColorStyles: n }
}
function He(e) {
  const { colorClasses: t, colorStyles: n } = cd(() => ({ background: Ft(e) }))
  return { backgroundColorClasses: t, backgroundColorStyles: n }
}
function yV(e) {
  const t = Ft(e),
    n = [],
    a = {}
  if (t.background)
    if (_u(t.background)) {
      if (((a.backgroundColor = t.background), !t.text && P1(t.background))) {
        const l = on(t.background)
        if (l.a == null || l.a === 1) {
          const o = hy(l)
          ;((a.color = o), (a.caretColor = o))
        }
      }
    } else n.push(`bg-${t.background}`)
  return (
    t.text &&
      (_u(t.text) ? ((a.color = t.text), (a.caretColor = t.text)) : n.push(`text-${t.text}`)),
    { class: n, style: a }
  )
}
const Je = $(
  { rounded: { type: [Boolean, Number, String], default: void 0 }, tile: Boolean },
  'rounded'
)
function ot(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Wn()
  return {
    roundedClasses: C(() => {
      const a = ct(e) ? e.value : e.rounded,
        l = ct(e) ? !1 : e.tile,
        o = []
      if (l || a === !1) o.push('rounded-0')
      else if (a === !0 || a === '') o.push(`${t}--rounded`)
      else if (typeof a == 'string' || a === 0)
        for (const i of String(a).split(' ')) o.push(`rounded-${i}`)
      return o
    }),
  }
}
const Vn = $(
    { transition: { type: null, default: 'fade-transition', validator: (e) => e !== !0 } },
    'transition'
  ),
  $t = (e, t) => {
    let { slots: n } = t
    const { transition: a, disabled: l, group: o, ...i } = e,
      { component: r = o ? Ac : la, ...s } = Do(a) ? a : {}
    let c
    return (
      Do(a) ? (c = Z(s, s1({ disabled: l, group: o }), i)) : (c = Z({ name: l || !a ? '' : a }, i)),
      ut(r, c, n)
    )
  }
function bV(e, t) {
  if (!jc) return
  const n = t.modifiers || {},
    a = t.value,
    { handler: l, options: o } = typeof a == 'object' ? a : { handler: a, options: {} },
    i = new IntersectionObserver(function () {
      let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
        s = arguments.length > 1 ? arguments[1] : void 0
      const c = e._observe?.[t.instance.$.uid]
      if (!c) return
      const u = r.some((d) => d.isIntersecting)
      ;(l && (!n.quiet || c.init) && (!n.once || u || c.init) && l(u, r, s),
        u && n.once ? Ly(e, t) : (c.init = !0))
    }, o)
  ;((e._observe = Object(e._observe)),
    (e._observe[t.instance.$.uid] = { init: !1, observer: i }),
    i.observe(e))
}
function Ly(e, t) {
  const n = e._observe?.[t.instance.$.uid]
  n && (n.observer.unobserve(e), delete e._observe[t.instance.$.uid])
}
const xn = { mounted: bV, unmounted: Ly },
  Oy = $(
    {
      absolute: Boolean,
      alt: String,
      cover: Boolean,
      color: String,
      draggable: { type: [Boolean, String], default: void 0 },
      eager: Boolean,
      gradient: String,
      lazySrc: String,
      options: {
        type: Object,
        default: () => ({ root: void 0, rootMargin: void 0, threshold: void 0 }),
      },
      sizes: String,
      src: { type: [String, Object], default: '' },
      crossorigin: String,
      referrerpolicy: String,
      srcset: String,
      position: String,
      ...By(),
      ...be(),
      ...Je(),
      ...Vn(),
    },
    'VImg'
  ),
  oa = J()({
    name: 'VImg',
    directives: { vIntersect: xn },
    props: Oy(),
    emits: { loadstart: (e) => !0, load: (e) => !0, error: (e) => !0 },
    setup(e, t) {
      let { emit: n, slots: a } = t
      const { backgroundColorClasses: l, backgroundColorStyles: o } = He(() => e.color),
        { roundedClasses: i } = ot(e),
        r = rt('VImg'),
        s = oe(''),
        c = ae(),
        u = oe(e.eager ? 'loading' : 'idle'),
        d = oe(),
        f = oe(),
        v = C(() =>
          e.src && typeof e.src == 'object'
            ? {
                src: e.src.src,
                srcset: e.srcset || e.src.srcset,
                lazySrc: e.lazySrc || e.src.lazySrc,
                aspect: Number(e.aspectRatio || e.src.aspect || 0),
              }
            : {
                src: e.src,
                srcset: e.srcset,
                lazySrc: e.lazySrc,
                aspect: Number(e.aspectRatio || 0),
              }
        ),
        g = C(() => v.value.aspect || d.value / f.value || 0)
      ;(ue(
        () => e.src,
        () => {
          h(u.value !== 'idle')
        }
      ),
        ue(g, (V, M) => {
          !V && M && c.value && S(c.value)
        }),
        Xl(() => h()))
      function h(V) {
        if (!(e.eager && V) && !(jc && !V && !e.eager)) {
          if (((u.value = 'loading'), v.value.lazySrc)) {
            const M = new Image()
            ;((M.src = v.value.lazySrc), S(M, null))
          }
          v.value.src &&
            Re(() => {
              ;(n('loadstart', c.value?.currentSrc || v.value.src),
                setTimeout(() => {
                  if (!r.isUnmounted)
                    if (c.value?.complete) {
                      if ((c.value.naturalWidth || b(), u.value === 'error')) return
                      ;(g.value || S(c.value, null), u.value === 'loading' && m())
                    } else (g.value || S(c.value), y())
                }))
            })
        }
      }
      function m() {
        r.isUnmounted ||
          (y(), S(c.value), (u.value = 'loaded'), n('load', c.value?.currentSrc || v.value.src))
      }
      function b() {
        r.isUnmounted || ((u.value = 'error'), n('error', c.value?.currentSrc || v.value.src))
      }
      function y() {
        const V = c.value
        V && (s.value = V.currentSrc || V.src)
      }
      let p = -1
      dt(() => {
        clearTimeout(p)
      })
      function S(V) {
        let M = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100
        const F = () => {
          if ((clearTimeout(p), r.isUnmounted)) return
          const { naturalHeight: G, naturalWidth: W } = V
          G || W
            ? ((d.value = W), (f.value = G))
            : !V.complete && u.value === 'loading' && M != null
              ? (p = window.setTimeout(F, M))
              : (V.currentSrc.endsWith('.svg') || V.currentSrc.startsWith('data:image/svg+xml')) &&
                ((d.value = 1), (f.value = 1))
        }
        F()
      }
      const k = B(() => ({ 'v-img__img--cover': e.cover, 'v-img__img--contain': !e.cover })),
        _ = () => {
          if (!v.value.src || u.value === 'idle') return null
          const V = x(
              'img',
              {
                class: ee(['v-img__img', k.value]),
                style: { objectPosition: e.position },
                crossorigin: e.crossorigin,
                src: v.value.src,
                srcset: v.value.srcset,
                alt: e.alt,
                referrerpolicy: e.referrerpolicy,
                draggable: e.draggable,
                sizes: e.sizes,
                ref: c,
                onLoad: m,
                onError: b,
              },
              null
            ),
            M = a.sources?.()
          return w(
            $t,
            { transition: e.transition, appear: !0 },
            {
              default: () => [
                tt(M ? x('picture', { class: 'v-img__picture' }, [M, V]) : V, [
                  [Pn, u.value === 'loaded'],
                ]),
              ],
            }
          )
        },
        P = () =>
          w(
            $t,
            { transition: e.transition },
            {
              default: () => [
                v.value.lazySrc &&
                  u.value !== 'loaded' &&
                  x(
                    'img',
                    {
                      class: ee(['v-img__img', 'v-img__img--preload', k.value]),
                      style: { objectPosition: e.position },
                      crossorigin: e.crossorigin,
                      src: v.value.lazySrc,
                      alt: e.alt,
                      referrerpolicy: e.referrerpolicy,
                      draggable: e.draggable,
                    },
                    null
                  ),
              ],
            }
          ),
        A = () =>
          a.placeholder
            ? w(
                $t,
                { transition: e.transition, appear: !0 },
                {
                  default: () => [
                    (u.value === 'loading' || (u.value === 'error' && !a.error)) &&
                      x('div', { class: 'v-img__placeholder' }, [a.placeholder()]),
                  ],
                }
              )
            : null,
        D = () =>
          a.error
            ? w(
                $t,
                { transition: e.transition, appear: !0 },
                {
                  default: () => [
                    u.value === 'error' && x('div', { class: 'v-img__error' }, [a.error()]),
                  ],
                }
              )
            : null,
        E = () =>
          e.gradient
            ? x(
                'div',
                {
                  class: 'v-img__gradient',
                  style: { backgroundImage: `linear-gradient(${e.gradient})` },
                },
                null
              )
            : null,
        R = oe(!1)
      {
        const V = ue(g, (M) => {
          M &&
            (requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                R.value = !0
              })
            }),
            V())
        })
      }
      return (
        ne(() => {
          const V = Eu.filterProps(e)
          return tt(
            w(
              Eu,
              Z(
                {
                  class: [
                    'v-img',
                    { 'v-img--absolute': e.absolute, 'v-img--booting': !R.value },
                    l.value,
                    i.value,
                    e.class,
                  ],
                  style: [{ width: fe(e.width === 'auto' ? d.value : e.width) }, o.value, e.style],
                },
                V,
                { aspectRatio: g.value, 'aria-label': e.alt, role: e.alt ? 'img' : void 0 }
              ),
              {
                additional: () =>
                  x(he, null, [
                    w(_, null, null),
                    w(P, null, null),
                    w(E, null, null),
                    w(A, null, null),
                    w(D, null, null),
                  ]),
                default: a.default,
              }
            ),
            [[xn, { handler: h, options: e.options }, null, { once: !0 }]]
          )
        }),
        { currentSrc: s, image: c, state: u, naturalWidth: d, naturalHeight: f }
      )
    },
  }),
  Ut = $({ border: [Boolean, Number, String] }, 'border')
function Jt(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Wn()
  return {
    borderClasses: C(() => {
      const a = e.border
      return a === !0 || a === ''
        ? `${t}--border`
        : typeof a == 'string' || a === 0
          ? String(a)
              .split(' ')
              .map((l) => `border-${l}`)
          : []
    }),
  }
}
const yt = $(
  {
    elevation: {
      type: [Number, String],
      validator(e) {
        const t = parseInt(e)
        return !isNaN(t) && t >= 0 && t <= 24
      },
    },
  },
  'elevation'
)
function xt(e) {
  return {
    elevationClasses: B(() => {
      const n = ct(e) ? e.value : e.elevation
      return n == null ? [] : [`elevation-${n}`]
    }),
  }
}
const pV = [null, 'prominent', 'default', 'comfortable', 'compact'],
  $y = $(
    {
      absolute: Boolean,
      collapse: Boolean,
      color: String,
      density: { type: String, default: 'default', validator: (e) => pV.includes(e) },
      extended: { type: Boolean, default: null },
      extensionHeight: { type: [Number, String], default: 48 },
      flat: Boolean,
      floating: Boolean,
      height: { type: [Number, String], default: 64 },
      image: String,
      title: String,
      ...Ut(),
      ...be(),
      ...yt(),
      ...Je(),
      ...Ie({ tag: 'header' }),
      ...Be(),
    },
    'VToolbar'
  ),
  Du = J()({
    name: 'VToolbar',
    props: $y(),
    setup(e, t) {
      let { slots: n } = t
      const { backgroundColorClasses: a, backgroundColorStyles: l } = He(() => e.color),
        { borderClasses: o } = Jt(e),
        { elevationClasses: i } = xt(e),
        { roundedClasses: r } = ot(e),
        { themeClasses: s } = $e(e),
        { rtlClasses: c } = gt(),
        u = oe(e.extended === null ? !!n.extension?.() : e.extended),
        d = C(() =>
          parseInt(
            Number(e.height) +
              (e.density === 'prominent' ? Number(e.height) : 0) -
              (e.density === 'comfortable' ? 8 : 0) -
              (e.density === 'compact' ? 16 : 0),
            10
          )
        ),
        f = C(() =>
          u.value
            ? parseInt(
                Number(e.extensionHeight) +
                  (e.density === 'prominent' ? Number(e.extensionHeight) : 0) -
                  (e.density === 'comfortable' ? 4 : 0) -
                  (e.density === 'compact' ? 8 : 0),
                10
              )
            : 0
        )
      return (
        lt({ VBtn: { variant: 'text' } }),
        ne(() => {
          const v = !!(e.title || n.title),
            g = !!(n.image || e.image),
            h = n.extension?.()
          return (
            (u.value = e.extended === null ? !!h : e.extended),
            w(
              e.tag,
              {
                class: ee([
                  'v-toolbar',
                  {
                    'v-toolbar--absolute': e.absolute,
                    'v-toolbar--collapse': e.collapse,
                    'v-toolbar--flat': e.flat,
                    'v-toolbar--floating': e.floating,
                    [`v-toolbar--density-${e.density}`]: !0,
                  },
                  a.value,
                  o.value,
                  i.value,
                  r.value,
                  s.value,
                  c.value,
                  e.class,
                ]),
                style: ce([l.value, e.style]),
              },
              {
                default: () => [
                  g &&
                    x('div', { key: 'image', class: 'v-toolbar__image' }, [
                      n.image
                        ? w(
                            Ae,
                            {
                              key: 'image-defaults',
                              disabled: !e.image,
                              defaults: { VImg: { cover: !0, src: e.image } },
                            },
                            n.image
                          )
                        : w(oa, { key: 'image-img', cover: !0, src: e.image }, null),
                    ]),
                  w(
                    Ae,
                    { defaults: { VTabs: { height: fe(d.value) } } },
                    {
                      default: () => [
                        x('div', { class: 'v-toolbar__content', style: { height: fe(d.value) } }, [
                          n.prepend && x('div', { class: 'v-toolbar__prepend' }, [n.prepend?.()]),
                          v && w(id, { key: 'title', text: e.title }, { text: n.title }),
                          n.default?.(),
                          n.append && x('div', { class: 'v-toolbar__append' }, [n.append?.()]),
                        ]),
                      ],
                    }
                  ),
                  w(
                    Ae,
                    { defaults: { VTabs: { height: fe(f.value) } } },
                    {
                      default: () => [
                        w(Fr, null, {
                          default: () => [
                            u.value &&
                              x(
                                'div',
                                { class: 'v-toolbar__extension', style: { height: fe(f.value) } },
                                [h]
                              ),
                          ],
                        }),
                      ],
                    }
                  ),
                ],
              }
            )
          )
        }),
        { contentHeight: d, extensionHeight: f }
      )
    },
  }),
  SV = $(
    { scrollTarget: { type: String }, scrollThreshold: { type: [String, Number], default: 300 } },
    'scroll'
  )
function wV(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
  const { canScroll: n } = t
  let a = 0,
    l = 0
  const o = ae(null),
    i = oe(0),
    r = oe(0),
    s = oe(0),
    c = oe(!1),
    u = oe(!1),
    d = C(() => Number(e.scrollThreshold)),
    f = C(() => Ge((d.value - i.value) / d.value || 0)),
    v = () => {
      const g = o.value
      if (!g || (n && !n.value)) return
      ;((a = i.value), (i.value = 'window' in g ? g.pageYOffset : g.scrollTop))
      const h = g instanceof Window ? document.documentElement.scrollHeight : g.scrollHeight
      if (l !== h) {
        l = h
        return
      }
      ;((u.value = i.value < a), (s.value = Math.abs(i.value - d.value)))
    }
  return (
    ue(u, () => {
      r.value = r.value || i.value
    }),
    ue(c, () => {
      r.value = 0
    }),
    pt(() => {
      ue(
        () => e.scrollTarget,
        (g) => {
          const h = g ? document.querySelector(g) : window
          h &&
            h !== o.value &&
            (o.value?.removeEventListener('scroll', v),
            (o.value = h),
            o.value.addEventListener('scroll', v, { passive: !0 }))
        },
        { immediate: !0 }
      )
    }),
    dt(() => {
      o.value?.removeEventListener('scroll', v)
    }),
    n && ue(n, v, { immediate: !0 }),
    {
      scrollThreshold: d,
      currentScroll: i,
      currentThreshold: s,
      isScrollActive: c,
      scrollRatio: f,
      isScrollingUp: u,
      savedScroll: r,
    }
  )
}
function sl() {
  const e = oe(!1)
  return (
    pt(() => {
      window.requestAnimationFrame(() => {
        e.value = !0
      })
    }),
    {
      ssrBootStyles: B(() => (e.value ? void 0 : { transition: 'none !important' })),
      isBooted: qa(e),
    }
  )
}
const kV = $(
    {
      scrollBehavior: String,
      modelValue: { type: Boolean, default: !0 },
      location: { type: String, default: 'top', validator: (e) => ['top', 'bottom'].includes(e) },
      ...$y(),
      ...il(),
      ...SV(),
      height: { type: [Number, String], default: 64 },
    },
    'VAppBar'
  ),
  CV = J()({
    name: 'VAppBar',
    props: kV(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = ae(),
        l = we(e, 'modelValue'),
        o = C(() => {
          const y = new Set(e.scrollBehavior?.split(' ') ?? [])
          return {
            hide: y.has('hide'),
            fullyHide: y.has('fully-hide'),
            inverted: y.has('inverted'),
            collapse: y.has('collapse'),
            elevate: y.has('elevate'),
            fadeImage: y.has('fade-image'),
          }
        }),
        i = C(() => {
          const y = o.value
          return (
            y.hide ||
            y.fullyHide ||
            y.inverted ||
            y.collapse ||
            y.elevate ||
            y.fadeImage ||
            !l.value
          )
        }),
        {
          currentScroll: r,
          scrollThreshold: s,
          isScrollingUp: c,
          scrollRatio: u,
        } = wV(e, { canScroll: i }),
        d = B(() => o.value.hide || o.value.fullyHide),
        f = C(
          () => e.collapse || (o.value.collapse && (o.value.inverted ? u.value > 0 : u.value === 0))
        ),
        v = C(
          () =>
            e.flat ||
            (o.value.fullyHide && !l.value) ||
            (o.value.elevate && (o.value.inverted ? r.value > 0 : r.value === 0))
        ),
        g = C(() => (o.value.fadeImage ? (o.value.inverted ? 1 - u.value : u.value) : void 0)),
        h = C(() => {
          if (o.value.hide && o.value.inverted) return 0
          const y = a.value?.contentHeight ?? 0,
            p = a.value?.extensionHeight ?? 0
          return d.value ? (r.value < s.value || o.value.fullyHide ? y + p : y) : y + p
        })
      Et(
        () => !!e.scrollBehavior,
        () => {
          qe(() => {
            d.value
              ? o.value.inverted
                ? (l.value = r.value > s.value)
                : (l.value = c.value || r.value < s.value)
              : (l.value = !0)
          })
        }
      )
      const { ssrBootStyles: m } = sl(),
        { layoutItemStyles: b } = rl({
          id: e.name,
          order: C(() => parseInt(e.order, 10)),
          position: B(() => e.location),
          layoutSize: h,
          elementSize: oe(void 0),
          active: l,
          absolute: B(() => e.absolute),
        })
      return (
        ne(() => {
          const y = Du.filterProps(e)
          return w(
            Du,
            Z(
              {
                ref: a,
                class: ['v-app-bar', { 'v-app-bar--bottom': e.location === 'bottom' }, e.class],
                style: [
                  { ...b.value, '--v-toolbar-image-opacity': g.value, height: void 0, ...m.value },
                  e.style,
                ],
              },
              y,
              { collapse: f.value, flat: v.value }
            ),
            n
          )
        }),
        {}
      )
    },
  }),
  xV = [null, 'default', 'comfortable', 'compact'],
  St = $(
    { density: { type: String, default: 'default', validator: (e) => xV.includes(e) } },
    'density'
  )
function Ht(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Wn()
  return { densityClasses: B(() => `${t}--density-${e.density}`) }
}
const _V = ['elevated', 'flat', 'tonal', 'outlined', 'text', 'plain']
function Ta(e, t) {
  return x(he, null, [
    e && x('span', { key: 'overlay', class: ee(`${t}__overlay`) }, null),
    x('span', { key: 'underlay', class: ee(`${t}__underlay`) }, null),
  ])
}
const yn = $(
  {
    color: String,
    variant: { type: String, default: 'elevated', validator: (e) => _V.includes(e) },
  },
  'variant'
)
function ul(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Wn()
  const n = B(() => {
      const { variant: o } = Ft(e)
      return `${t}--variant-${o}`
    }),
    { colorClasses: a, colorStyles: l } = cd(() => {
      const { variant: o, color: i } = Ft(e)
      return { [['elevated', 'flat'].includes(o) ? 'background' : 'text']: i }
    })
  return { colorClasses: a, colorStyles: l, variantClasses: n }
}
const Fy = $(
    {
      baseColor: String,
      divided: Boolean,
      direction: { type: String, default: 'horizontal' },
      ...Ut(),
      ...be(),
      ...St(),
      ...yt(),
      ...Je(),
      ...Ie(),
      ...Be(),
      ...yn(),
    },
    'VBtnGroup'
  ),
  Ru = J()({
    name: 'VBtnGroup',
    props: Fy(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: a } = $e(e),
        { densityClasses: l } = Ht(e),
        { borderClasses: o } = Jt(e),
        { elevationClasses: i } = xt(e),
        { roundedClasses: r } = ot(e)
      ;(lt({
        VBtn: {
          height: B(() => (e.direction === 'horizontal' ? 'auto' : null)),
          baseColor: B(() => e.baseColor),
          color: B(() => e.color),
          density: B(() => e.density),
          flat: !0,
          variant: B(() => e.variant),
        },
      }),
        ne(() =>
          w(
            e.tag,
            {
              class: ee([
                'v-btn-group',
                `v-btn-group--${e.direction}`,
                { 'v-btn-group--divided': e.divided },
                a.value,
                o.value,
                l.value,
                i.value,
                r.value,
                e.class,
              ]),
              style: ce(e.style),
            },
            n
          )
        ))
    },
  }),
  cl = $(
    {
      modelValue: { type: null, default: void 0 },
      multiple: Boolean,
      mandatory: [Boolean, String],
      max: Number,
      selectedClass: String,
      disabled: Boolean,
    },
    'group'
  ),
  dl = $({ value: null, disabled: Boolean, selectedClass: String }, 'group-item')
function fl(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0
  const a = rt('useGroupItem')
  if (!a)
    throw new Error(
      '[Vuetify] useGroupItem composable must be used inside a component setup function'
    )
  const l = Rt()
  Fe(Symbol.for(`${t.description}:id`), l)
  const o = Ve(t, null)
  if (!o) {
    if (!n) return o
    throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${t.description}`)
  }
  const i = B(() => e.value),
    r = C(() => !!(o.disabled.value || e.disabled))
  ;(o.register({ id: l, value: i, disabled: r }, a),
    dt(() => {
      o.unregister(l)
    }))
  const s = C(() => o.isSelected(l)),
    c = C(() => o.items.value[0].id === l),
    u = C(() => o.items.value[o.items.value.length - 1].id === l),
    d = C(() => s.value && [o.selectedClass.value, e.selectedClass])
  return (
    ue(
      s,
      (f) => {
        a.emit('group:selected', { value: f })
      },
      { flush: 'sync' }
    ),
    {
      id: l,
      isSelected: s,
      isFirst: c,
      isLast: u,
      toggle: () => o.select(l, !s.value),
      select: (f) => o.select(l, f),
      selectedClass: d,
      value: i,
      disabled: r,
      group: o,
    }
  )
}
function Aa(e, t) {
  let n = !1
  const a = it([]),
    l = we(
      e,
      'modelValue',
      [],
      (f) => (f === void 0 ? [] : Ny(a, f === null ? [null] : nt(f))),
      (f) => {
        const v = VV(a, f)
        return e.multiple ? v : v[0]
      }
    ),
    o = rt('useGroup')
  function i(f, v) {
    const g = f,
      h = Symbol.for(`${t.description}:id`),
      b = _l(h, o?.vnode).indexOf(v)
    ;(Ke(g.value) === void 0 && ((g.value = b), (g.useIndexAsValue = !0)),
      b > -1 ? a.splice(b, 0, g) : a.push(g))
  }
  function r(f) {
    if (n) return
    s()
    const v = a.findIndex((g) => g.id === f)
    a.splice(v, 1)
  }
  function s() {
    const f = a.find((v) => !v.disabled)
    f && e.mandatory === 'force' && !l.value.length && (l.value = [f.id])
  }
  ;(pt(() => {
    s()
  }),
    dt(() => {
      n = !0
    }),
    xr(() => {
      for (let f = 0; f < a.length; f++) a[f].useIndexAsValue && (a[f].value = f)
    }))
  function c(f, v) {
    const g = a.find((h) => h.id === f)
    if (!(v && g?.disabled))
      if (e.multiple) {
        const h = l.value.slice(),
          m = h.findIndex((y) => y === f),
          b = ~m
        if (
          ((v = v ?? !b),
          (b && e.mandatory && h.length <= 1) || (!b && e.max != null && h.length + 1 > e.max))
        )
          return
        ;(m < 0 && v ? h.push(f) : m >= 0 && !v && h.splice(m, 1), (l.value = h))
      } else {
        const h = l.value.includes(f)
        if ((e.mandatory && h) || (!h && !v)) return
        l.value = (v ?? !h) ? [f] : []
      }
  }
  function u(f) {
    if ((e.multiple, l.value.length)) {
      const v = l.value[0],
        g = a.findIndex((b) => b.id === v)
      let h = (g + f) % a.length,
        m = a[h]
      for (; m.disabled && h !== g; ) ((h = (h + f) % a.length), (m = a[h]))
      if (m.disabled) return
      l.value = [a[h].id]
    } else {
      const v = a.find((g) => !g.disabled)
      v && (l.value = [v.id])
    }
  }
  const d = {
    register: i,
    unregister: r,
    selected: l,
    select: c,
    disabled: B(() => e.disabled),
    prev: () => u(a.length - 1),
    next: () => u(1),
    isSelected: (f) => l.value.includes(f),
    selectedClass: B(() => e.selectedClass),
    items: B(() => a),
    getItemIndex: (f) => PV(a, f),
  }
  return (Fe(t, d), d)
}
function PV(e, t) {
  const n = Ny(e, [t])
  return n.length ? e.findIndex((a) => a.id === n[0]) : -1
}
function Ny(e, t) {
  const n = []
  return (
    t.forEach((a) => {
      const l = e.find((i) => kt(a, i.value)),
        o = e[a]
      l?.value !== void 0 ? n.push(l.id) : o?.useIndexAsValue && n.push(o.id)
    }),
    n
  )
}
function VV(e, t) {
  const n = []
  return (
    t.forEach((a) => {
      const l = e.findIndex((o) => o.id === a)
      if (~l) {
        const o = e[l]
        n.push(o.value !== void 0 ? o.value : l)
      }
    }),
    n
  )
}
const dd = Symbol.for('vuetify:v-btn-toggle'),
  IV = $({ ...Fy(), ...cl() }, 'VBtnToggle'),
  TV = J()({
    name: 'VBtnToggle',
    props: IV(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { isSelected: a, next: l, prev: o, select: i, selected: r } = Aa(e, dd)
      return (
        ne(() => {
          const s = Ru.filterProps(e)
          return w(Ru, Z({ class: ['v-btn-toggle', e.class] }, s, { style: e.style }), {
            default: () => [
              n.default?.({ isSelected: a, next: l, prev: o, select: i, selected: r }),
            ],
          })
        }),
        { next: l, prev: o, select: i }
      )
    },
  }),
  AV = ['x-small', 'small', 'default', 'large', 'x-large'],
  Un = $({ size: { type: [String, Number], default: 'default' } }, 'size')
function Zl(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Wn()
  return Kc(() => {
    const n = e.size
    let a, l
    return (
      rr(AV, n) ? (a = `${t}--size-${n}`) : n && (l = { width: fe(n), height: fe(n) }),
      { sizeClasses: a, sizeStyles: l }
    )
  })
}
const EV = $(
    {
      color: String,
      disabled: Boolean,
      start: Boolean,
      end: Boolean,
      icon: Se,
      opacity: [String, Number],
      ...be(),
      ...Un(),
      ...Ie({ tag: 'i' }),
      ...Be(),
    },
    'VIcon'
  ),
  Le = J()({
    name: 'VIcon',
    props: EV(),
    setup(e, t) {
      let { attrs: n, slots: a } = t
      const l = oe(),
        { themeClasses: o } = ld(),
        { iconData: i } = UP(() => l.value || e.icon),
        { sizeClasses: r } = Zl(e),
        { textColorClasses: s, textColorStyles: c } = Vt(() => e.color)
      return (
        ne(() => {
          const u = a.default?.()
          u &&
            (l.value = Qg(u).filter(
              (f) => f.type === Ca && f.children && typeof f.children == 'string'
            )[0]?.children)
          const d = !!(n.onClick || n.onClickOnce)
          return w(
            i.value.component,
            {
              tag: e.tag,
              icon: i.value.icon,
              class: ee([
                'v-icon',
                'notranslate',
                o.value,
                r.value,
                s.value,
                {
                  'v-icon--clickable': d,
                  'v-icon--disabled': e.disabled,
                  'v-icon--start': e.start,
                  'v-icon--end': e.end,
                },
                e.class,
              ]),
              style: ce([
                { '--v-icon-opacity': e.opacity },
                r.value ? void 0 : { fontSize: fe(e.size), height: fe(e.size), width: fe(e.size) },
                c.value,
                e.style,
              ]),
              role: d ? 'button' : void 0,
              'aria-hidden': !d,
              tabindex: d ? (e.disabled ? -1 : 0) : void 0,
            },
            { default: () => [u] }
          )
        }),
        {}
      )
    },
  })
function oi(e, t) {
  const n = ae(),
    a = oe(!1)
  if (jc) {
    const l = new IntersectionObserver((o) => {
      a.value = !!o.find((i) => i.isIntersecting)
    }, t)
    ;(bt(() => {
      l.disconnect()
    }),
      ue(
        n,
        (o, i) => {
          ;(i && (l.unobserve(i), (a.value = !1)), o && l.observe(o))
        },
        { flush: 'post' }
      ))
  }
  return { intersectionRef: n, isIntersecting: a }
}
const DV = $(
    {
      bgColor: String,
      color: String,
      indeterminate: [Boolean, String],
      modelValue: { type: [Number, String], default: 0 },
      rotate: { type: [Number, String], default: 0 },
      width: { type: [Number, String], default: 4 },
      ...be(),
      ...Un(),
      ...Ie({ tag: 'div' }),
      ...Be(),
    },
    'VProgressCircular'
  ),
  Ja = J()({
    name: 'VProgressCircular',
    props: DV(),
    setup(e, t) {
      let { slots: n } = t
      const a = 20,
        l = 2 * Math.PI * a,
        o = ae(),
        { themeClasses: i } = $e(e),
        { sizeClasses: r, sizeStyles: s } = Zl(e),
        { textColorClasses: c, textColorStyles: u } = Vt(() => e.color),
        { textColorClasses: d, textColorStyles: f } = Vt(() => e.bgColor),
        { intersectionRef: v, isIntersecting: g } = oi(),
        { resizeRef: h, contentRect: m } = hn(),
        b = B(() => Ge(parseFloat(e.modelValue), 0, 100)),
        y = B(() => Number(e.width)),
        p = B(() => (s.value ? Number(e.size) : m.value ? m.value.width : Math.max(y.value, 32))),
        S = B(() => (a / (1 - y.value / p.value)) * 2),
        k = B(() => (y.value / p.value) * S.value),
        _ = B(() => fe(((100 - b.value) / 100) * l))
      return (
        qe(() => {
          ;((v.value = o.value), (h.value = o.value))
        }),
        ne(() =>
          w(
            e.tag,
            {
              ref: o,
              class: ee([
                'v-progress-circular',
                {
                  'v-progress-circular--indeterminate': !!e.indeterminate,
                  'v-progress-circular--visible': g.value,
                  'v-progress-circular--disable-shrink':
                    e.indeterminate && (e.indeterminate === 'disable-shrink' || On()),
                },
                i.value,
                r.value,
                c.value,
                e.class,
              ]),
              style: ce([s.value, u.value, e.style]),
              role: 'progressbar',
              'aria-valuemin': '0',
              'aria-valuemax': '100',
              'aria-valuenow': e.indeterminate ? void 0 : b.value,
            },
            {
              default: () => [
                x(
                  'svg',
                  {
                    style: { transform: `rotate(calc(-90deg + ${Number(e.rotate)}deg))` },
                    xmlns: 'http://www.w3.org/2000/svg',
                    viewBox: `0 0 ${S.value} ${S.value}`,
                  },
                  [
                    x(
                      'circle',
                      {
                        class: ee(['v-progress-circular__underlay', d.value]),
                        style: ce(f.value),
                        fill: 'transparent',
                        cx: '50%',
                        cy: '50%',
                        r: a,
                        'stroke-width': k.value,
                        'stroke-dasharray': l,
                        'stroke-dashoffset': 0,
                      },
                      null
                    ),
                    x(
                      'circle',
                      {
                        class: 'v-progress-circular__overlay',
                        fill: 'transparent',
                        cx: '50%',
                        cy: '50%',
                        r: a,
                        'stroke-width': k.value,
                        'stroke-dasharray': l,
                        'stroke-dashoffset': _.value,
                      },
                      null
                    ),
                  ]
                ),
                n.default &&
                  x('div', { class: 'v-progress-circular__content' }, [
                    n.default({ value: b.value }),
                  ]),
              ],
            }
          )
        ),
        {}
      )
    },
  }),
  om = { center: 'center', top: 'bottom', bottom: 'top', left: 'right', right: 'left' },
  fa = $({ location: String }, 'location')
function vl(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1,
    n = arguments.length > 2 ? arguments[2] : void 0
  const { isRtl: a } = gt()
  return {
    locationStyles: C(() => {
      if (!e.location) return {}
      const { side: o, align: i } = Cu(
        e.location.split(' ').length > 1 ? e.location : `${e.location} center`,
        a.value
      )
      function r(c) {
        return n ? n(c) : 0
      }
      const s = {}
      return (
        o !== 'center' && (t ? (s[om[o]] = `calc(100% - ${r(o)}px)`) : (s[o] = 0)),
        i !== 'center'
          ? t
            ? (s[om[i]] = `calc(100% - ${r(i)}px)`)
            : (s[i] = 0)
          : (o === 'center'
              ? (s.top = s.left = '50%')
              : (s[{ top: 'left', bottom: 'left', left: 'top', right: 'top' }[o]] = '50%'),
            (s.transform = {
              top: 'translateX(-50%)',
              bottom: 'translateX(-50%)',
              left: 'translateY(-50%)',
              right: 'translateY(-50%)',
              center: 'translate(-50%, -50%)',
            }[o])),
        s
      )
    }),
  }
}
const RV = $(
  {
    chunkCount: { type: [Number, String], default: null },
    chunkWidth: { type: [Number, String], default: null },
    chunkGap: { type: [Number, String], default: 4 },
  },
  'chunks'
)
function MV(e, t) {
  const n = B(() => !!e.chunkCount || !!e.chunkWidth),
    a = C(() => {
      const r = Ft(t)
      if (!r) return 0
      if (!e.chunkCount) return Number(e.chunkWidth)
      const s = Number(e.chunkCount)
      return (r - Number(e.chunkGap) * (s - 1)) / s
    }),
    l = B(() => Number(e.chunkGap)),
    o = C(() => {
      if (!n.value) return {}
      const r = fe(l.value),
        s = fe(a.value)
      return {
        maskRepeat: 'repeat-x',
        maskImage: `linear-gradient(90deg, #000, #000 ${s}, transparent ${s}, transparent)`,
        maskSize: `calc(${s} + ${r}) 100%`,
      }
    })
  function i(r) {
    const s = Ft(t)
    if (!s) return r
    const c = (100 * l.value) / s,
      u = (100 * (a.value + l.value)) / s,
      d = Math.floor((r + c) / u)
    return Ge(0, d * u - c / 2, 100)
  }
  return { hasChunks: n, chunksMaskStyles: o, snapValueToChunk: i }
}
const BV = $(
    {
      absolute: Boolean,
      active: { type: Boolean, default: !0 },
      bgColor: String,
      bgOpacity: [Number, String],
      bufferValue: { type: [Number, String], default: 0 },
      bufferColor: String,
      bufferOpacity: [Number, String],
      clickable: Boolean,
      color: String,
      height: { type: [Number, String], default: 4 },
      indeterminate: Boolean,
      max: { type: [Number, String], default: 100 },
      modelValue: { type: [Number, String], default: 0 },
      opacity: [Number, String],
      reverse: Boolean,
      stream: Boolean,
      striped: Boolean,
      roundedBar: Boolean,
      ...RV(),
      ...be(),
      ...fa({ location: 'top' }),
      ...Je(),
      ...Ie(),
      ...Be(),
    },
    'VProgressLinear'
  ),
  Nr = J()({
    name: 'VProgressLinear',
    props: BV(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = ae(),
        l = we(e, 'modelValue'),
        { isRtl: o, rtlClasses: i } = gt(),
        { themeClasses: r } = $e(e),
        { locationStyles: s } = vl(e),
        { textColorClasses: c, textColorStyles: u } = Vt(() => e.color),
        { backgroundColorClasses: d, backgroundColorStyles: f } = He(() => e.bgColor || e.color),
        { backgroundColorClasses: v, backgroundColorStyles: g } = He(
          () => e.bufferColor || e.bgColor || e.color
        ),
        { backgroundColorClasses: h, backgroundColorStyles: m } = He(() => e.color),
        { roundedClasses: b } = ot(e),
        { intersectionRef: y, isIntersecting: p } = oi(),
        S = C(() => parseFloat(e.max)),
        k = C(() => parseFloat(e.height)),
        _ = C(() => Ge((parseFloat(e.bufferValue) / S.value) * 100, 0, 100)),
        P = C(() => Ge((parseFloat(l.value) / S.value) * 100, 0, 100)),
        A = C(() => o.value !== e.reverse),
        D = C(() => (e.indeterminate ? 'fade-transition' : 'slide-x-transition')),
        E = oe(0),
        { hasChunks: R, chunksMaskStyles: V, snapValueToChunk: M } = MV(e, E)
      Et(R, () => {
        const { resizeRef: te } = hn((H) => (E.value = H[0].contentRect.width))
        qe(() => (te.value = a.value))
      })
      const F = C(() => (R.value ? M(_.value) : _.value)),
        G = C(() => (R.value ? M(P.value) : P.value))
      function W(te) {
        if (!y.value) return
        const { left: H, right: O, width: j } = y.value.getBoundingClientRect(),
          U = A.value ? j - te.clientX + (O - j) : te.clientX - H
        l.value = Math.round((U / j) * S.value)
      }
      return (
        qe(() => {
          y.value = a.value
        }),
        ne(() =>
          w(
            e.tag,
            {
              ref: a,
              class: ee([
                'v-progress-linear',
                {
                  'v-progress-linear--absolute': e.absolute,
                  'v-progress-linear--active': e.active && p.value,
                  'v-progress-linear--reverse': A.value,
                  'v-progress-linear--rounded': e.rounded,
                  'v-progress-linear--rounded-bar': e.roundedBar,
                  'v-progress-linear--striped': e.striped,
                  'v-progress-linear--clickable': e.clickable,
                },
                b.value,
                r.value,
                i.value,
                e.class,
              ]),
              style: ce([
                {
                  bottom: e.location === 'bottom' ? 0 : void 0,
                  top: e.location === 'top' ? 0 : void 0,
                  height: e.active ? fe(k.value) : 0,
                  '--v-progress-linear-height': fe(k.value),
                  ...(e.absolute ? s.value : {}),
                },
                V.value,
                e.style,
              ]),
              role: 'progressbar',
              'aria-hidden': e.active ? 'false' : 'true',
              'aria-valuemin': '0',
              'aria-valuemax': e.max,
              'aria-valuenow': e.indeterminate ? void 0 : Math.min(parseFloat(l.value), S.value),
              onClick: e.clickable && W,
            },
            {
              default: () => [
                e.stream &&
                  x(
                    'div',
                    {
                      key: 'stream',
                      class: ee(['v-progress-linear__stream', c.value]),
                      style: {
                        ...u.value,
                        [A.value ? 'left' : 'right']: fe(-k.value),
                        borderTop: `${fe(k.value / 2)} dotted`,
                        opacity: parseFloat(e.bufferOpacity),
                        top: `calc(50% - ${fe(k.value / 4)})`,
                        width: fe(100 - _.value, '%'),
                        '--v-progress-linear-stream-to': fe(k.value * (A.value ? 1 : -1)),
                      },
                    },
                    null
                  ),
                x(
                  'div',
                  {
                    class: ee(['v-progress-linear__background', d.value]),
                    style: ce([
                      f.value,
                      { opacity: parseFloat(e.bgOpacity), width: e.stream ? 0 : void 0 },
                    ]),
                  },
                  null
                ),
                x(
                  'div',
                  {
                    class: ee(['v-progress-linear__buffer', v.value]),
                    style: ce([
                      g.value,
                      { opacity: parseFloat(e.bufferOpacity), width: fe(F.value, '%') },
                    ]),
                  },
                  null
                ),
                w(
                  la,
                  { name: D.value },
                  {
                    default: () => [
                      e.indeterminate
                        ? x('div', { class: 'v-progress-linear__indeterminate' }, [
                            ['long', 'short'].map((te) =>
                              x(
                                'div',
                                {
                                  key: te,
                                  class: ee(['v-progress-linear__indeterminate', te, h.value]),
                                  style: ce(m.value),
                                },
                                null
                              )
                            ),
                          ])
                        : x(
                            'div',
                            {
                              class: ee(['v-progress-linear__determinate', h.value]),
                              style: ce([m.value, { width: fe(G.value, '%') }]),
                            },
                            null
                          ),
                    ],
                  }
                ),
                n.default &&
                  x('div', { class: 'v-progress-linear__content' }, [
                    n.default({ value: P.value, buffer: _.value }),
                  ]),
              ],
            }
          )
        ),
        {}
      )
    },
  }),
  Hr = $({ loading: [Boolean, String] }, 'loader')
function ii(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Wn()
  return { loaderClasses: B(() => ({ [`${t}--loading`]: e.loading })) }
}
function ri(e, t) {
  let { slots: n } = t
  return x('div', { class: ee(`${e.name}__loader`) }, [
    n.default?.({ color: e.color, isActive: e.active }) ||
      w(
        Nr,
        { absolute: e.absolute, active: e.active, color: e.color, height: '2', indeterminate: !0 },
        null
      ),
  ])
}
const LV = ['static', 'relative', 'fixed', 'absolute', 'sticky'],
  Jl = $({ position: { type: String, validator: (e) => LV.includes(e) } }, 'position')
function Ql(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Wn()
  return { positionClasses: B(() => (e.position ? `${t}--${e.position}` : void 0)) }
}
function OV() {
  const e = rt('useRoute')
  return C(() => e?.proxy?.$route)
}
function Hy() {
  return rt('useRouter')?.proxy?.$router
}
function si(e, t) {
  const n = wh('RouterLink'),
    a = B(() => !!(e.href || e.to)),
    l = C(() => a?.value || Vv(t, 'click') || Vv(e, 'click'))
  if (typeof n == 'string' || !('useLink' in n)) {
    const d = B(() => e.href)
    return {
      isLink: a,
      isRouterLink: B(() => !1),
      isClickable: l,
      href: d,
      linkProps: it({ href: d }),
    }
  }
  const o = n.useLink({ to: B(() => e.to || ''), replace: B(() => e.replace) }),
    i = C(() => (e.to ? o : void 0)),
    r = OV(),
    s = C(() =>
      i.value
        ? e.exact
          ? r.value
            ? i.value.isExactActive?.value && kt(i.value.route.value.query, r.value.query)
            : (i.value.isExactActive?.value ?? !1)
          : (i.value.isActive?.value ?? !1)
        : !1
    ),
    c = C(() => (e.to ? i.value?.route.value.href : e.href)),
    u = B(() => !!e.to)
  return {
    isLink: a,
    isRouterLink: u,
    isClickable: l,
    isActive: s,
    route: i.value?.route,
    navigate: i.value?.navigate,
    href: c,
    linkProps: it({
      href: c,
      'aria-current': B(() => (s.value ? 'page' : void 0)),
      'aria-disabled': B(() => (e.disabled && a.value ? 'true' : void 0)),
      tabindex: B(() => (e.disabled && a.value ? '-1' : void 0)),
    }),
  }
}
const ui = $({ href: String, replace: Boolean, to: [String, Object], exact: Boolean }, 'router')
let Rs = !1
function $V(e, t) {
  let n = !1,
    a,
    l
  Ne &&
    e?.beforeEach &&
    (Re(() => {
      ;(window.addEventListener('popstate', o),
        (a = e.beforeEach((i, r, s) => {
          ;(Rs ? (n ? t(s) : s()) : setTimeout(() => (n ? t(s) : s())), (Rs = !0))
        })),
        (l = e?.afterEach(() => {
          Rs = !1
        })))
    }),
    bt(() => {
      ;(window.removeEventListener('popstate', o), a?.(), l?.())
    }))
  function o(i) {
    i.state?.replaced || ((n = !0), setTimeout(() => (n = !1)))
  }
}
function FV(e, t) {
  ue(
    () => e.isActive?.value,
    (n) => {
      e.isLink.value &&
        n != null &&
        t &&
        Re(() => {
          t(n)
        })
    },
    { immediate: !0 }
  )
}
const Mu = Symbol('rippleStop'),
  NV = 80
function im(e, t) {
  ;((e.style.transform = t), (e.style.webkitTransform = t))
}
function Bu(e) {
  return e.constructor.name === 'TouchEvent'
}
function jy(e) {
  return e.constructor.name === 'KeyboardEvent'
}
const HV = function (e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
      a = 0,
      l = 0
    if (!jy(e)) {
      const d = t.getBoundingClientRect(),
        f = Bu(e) ? e.touches[e.touches.length - 1] : e
      ;((a = f.clientX - d.left), (l = f.clientY - d.top))
    }
    let o = 0,
      i = 0.3
    t._ripple?.circle
      ? ((i = 0.15),
        (o = t.clientWidth / 2),
        (o = n.center ? o : o + Math.sqrt((a - o) ** 2 + (l - o) ** 2) / 4))
      : (o = Math.sqrt(t.clientWidth ** 2 + t.clientHeight ** 2) / 2)
    const r = `${(t.clientWidth - o * 2) / 2}px`,
      s = `${(t.clientHeight - o * 2) / 2}px`,
      c = n.center ? r : `${a - o}px`,
      u = n.center ? s : `${l - o}px`
    return { radius: o, scale: i, x: c, y: u, centerX: r, centerY: s }
  },
  hr = {
    show(e, t) {
      let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
      if (!t?._ripple?.enabled) return
      const a = document.createElement('span'),
        l = document.createElement('span')
      ;(a.appendChild(l),
        (a.className = 'v-ripple__container'),
        n.class && (a.className += ` ${n.class}`))
      const { radius: o, scale: i, x: r, y: s, centerX: c, centerY: u } = HV(e, t, n),
        d = `${o * 2}px`
      ;((l.className = 'v-ripple__animation'),
        (l.style.width = d),
        (l.style.height = d),
        t.appendChild(a))
      const f = window.getComputedStyle(t)
      ;(f &&
        f.position === 'static' &&
        ((t.style.position = 'relative'), (t.dataset.previousPosition = 'static')),
        l.classList.add('v-ripple__animation--enter'),
        l.classList.add('v-ripple__animation--visible'),
        im(l, `translate(${r}, ${s}) scale3d(${i},${i},${i})`),
        (l.dataset.activated = String(performance.now())),
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            ;(l.classList.remove('v-ripple__animation--enter'),
              l.classList.add('v-ripple__animation--in'),
              im(l, `translate(${c}, ${u}) scale3d(1,1,1)`))
          })
        }))
    },
    hide(e) {
      if (!e?._ripple?.enabled) return
      const t = e.getElementsByClassName('v-ripple__animation')
      if (t.length === 0) return
      const n = Array.from(t).findLast((o) => !o.dataset.isHiding)
      if (n) n.dataset.isHiding = 'true'
      else return
      const a = performance.now() - Number(n.dataset.activated),
        l = Math.max(250 - a, 0)
      setTimeout(() => {
        ;(n.classList.remove('v-ripple__animation--in'),
          n.classList.add('v-ripple__animation--out'),
          setTimeout(() => {
            ;(e.getElementsByClassName('v-ripple__animation').length === 1 &&
              e.dataset.previousPosition &&
              ((e.style.position = e.dataset.previousPosition), delete e.dataset.previousPosition),
              n.parentNode?.parentNode === e && e.removeChild(n.parentNode))
          }, 300))
      }, l)
    },
  }
function zy(e) {
  return typeof e > 'u' || !!e
}
function No(e) {
  const t = {},
    n = e.currentTarget
  if (!(!n?._ripple || n._ripple.touched || e[Mu])) {
    if (((e[Mu] = !0), Bu(e))) ((n._ripple.touched = !0), (n._ripple.isTouch = !0))
    else if (n._ripple.isTouch) return
    if (
      ((t.center = n._ripple.centered || jy(e)),
      n._ripple.class && (t.class = n._ripple.class),
      Bu(e))
    ) {
      if (n._ripple.showTimerCommit) return
      ;((n._ripple.showTimerCommit = () => {
        hr.show(e, n, t)
      }),
        (n._ripple.showTimer = window.setTimeout(() => {
          n?._ripple?.showTimerCommit &&
            (n._ripple.showTimerCommit(), (n._ripple.showTimerCommit = null))
        }, NV)))
    } else hr.show(e, n, t)
  }
}
function rm(e) {
  e[Mu] = !0
}
function an(e) {
  const t = e.currentTarget
  if (t?._ripple) {
    if (
      (window.clearTimeout(t._ripple.showTimer), e.type === 'touchend' && t._ripple.showTimerCommit)
    ) {
      ;(t._ripple.showTimerCommit(),
        (t._ripple.showTimerCommit = null),
        (t._ripple.showTimer = window.setTimeout(() => {
          an(e)
        })))
      return
    }
    ;(window.setTimeout(() => {
      t._ripple && (t._ripple.touched = !1)
    }),
      hr.hide(t))
  }
}
function Wy(e) {
  const t = e.currentTarget
  t?._ripple &&
    (t._ripple.showTimerCommit && (t._ripple.showTimerCommit = null),
    window.clearTimeout(t._ripple.showTimer))
}
let Ho = !1
function sm(e, t) {
  !Ho && t.includes(e.key) && ((Ho = !0), No(e))
}
function Uy(e) {
  ;((Ho = !1), an(e))
}
function Ky(e) {
  Ho && ((Ho = !1), an(e))
}
function Gy(e, t, n) {
  const { value: a, modifiers: l } = t,
    o = zy(a)
  ;(o || hr.hide(e),
    (e._ripple = e._ripple ?? {}),
    (e._ripple.enabled = o),
    (e._ripple.centered = l.center),
    (e._ripple.circle = l.circle))
  const i = Do(a) ? a : {}
  i.class && (e._ripple.class = i.class)
  const r = i.keys ?? ['Enter', 'Space']
  if (((e._ripple.keyDownHandler = (s) => sm(s, r)), o && !n)) {
    if (l.stop) {
      ;(e.addEventListener('touchstart', rm, { passive: !0 }), e.addEventListener('mousedown', rm))
      return
    }
    ;(e.addEventListener('touchstart', No, { passive: !0 }),
      e.addEventListener('touchend', an, { passive: !0 }),
      e.addEventListener('touchmove', Wy, { passive: !0 }),
      e.addEventListener('touchcancel', an),
      e.addEventListener('mousedown', No),
      e.addEventListener('mouseup', an),
      e.addEventListener('mouseleave', an),
      e.addEventListener('keydown', (s) => sm(s, r)),
      e.addEventListener('keyup', Uy),
      e.addEventListener('blur', Ky),
      e.addEventListener('dragstart', an, { passive: !0 }))
  } else !o && n && Yy(e)
}
function Yy(e) {
  ;(e.removeEventListener('mousedown', No),
    e.removeEventListener('touchstart', No),
    e.removeEventListener('touchend', an),
    e.removeEventListener('touchmove', Wy),
    e.removeEventListener('touchcancel', an),
    e.removeEventListener('mouseup', an),
    e.removeEventListener('mouseleave', an),
    e._ripple?.keyDownHandler && e.removeEventListener('keydown', e._ripple.keyDownHandler),
    e.removeEventListener('keyup', Uy),
    e.removeEventListener('dragstart', an),
    e.removeEventListener('blur', Ky))
}
function jV(e, t) {
  Gy(e, t, !1)
}
function zV(e) {
  ;(Yy(e), delete e._ripple)
}
function WV(e, t) {
  if (t.value === t.oldValue) return
  const n = zy(t.oldValue)
  Gy(e, t, n)
}
const Nt = { mounted: jV, unmounted: zV, updated: WV },
  jr = $(
    {
      active: { type: Boolean, default: void 0 },
      activeColor: String,
      baseColor: String,
      symbol: { type: null, default: dd },
      flat: Boolean,
      icon: [Boolean, String, Function, Object],
      prependIcon: Se,
      appendIcon: Se,
      block: Boolean,
      readonly: Boolean,
      slim: Boolean,
      stacked: Boolean,
      spaced: String,
      ripple: { type: [Boolean, Object], default: !0 },
      text: { type: [String, Number, Boolean], default: void 0 },
      ...Ut(),
      ...be(),
      ...St(),
      ...ft(),
      ...yt(),
      ...dl(),
      ...Hr(),
      ...fa(),
      ...Jl(),
      ...Je(),
      ...ui(),
      ...Un(),
      ...Ie({ tag: 'button' }),
      ...Be(),
      ...yn({ variant: 'elevated' }),
    },
    'VBtn'
  ),
  Me = J()({
    name: 'VBtn',
    props: jr(),
    emits: { 'group:selected': (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: a } = t
      const { themeClasses: l } = $e(e),
        { borderClasses: o } = Jt(e),
        { densityClasses: i } = Ht(e),
        { dimensionStyles: r } = vt(e),
        { elevationClasses: s } = xt(e),
        { loaderClasses: c } = ii(e),
        { locationStyles: u } = vl(e),
        { positionClasses: d } = Ql(e),
        { roundedClasses: f } = ot(e),
        { sizeClasses: v, sizeStyles: g } = Zl(e),
        h = fl(e, e.symbol, !1),
        m = si(e, n),
        b = C(() =>
          e.active !== void 0
            ? e.active
            : m.isRouterLink.value
              ? m.isActive?.value
              : h?.isSelected.value
        ),
        y = B(() => (b.value ? (e.activeColor ?? e.color) : e.color)),
        p = C(() => ({
          color:
            (h?.isSelected.value && (!m.isLink.value || m.isActive?.value)) ||
            !h ||
            m.isActive?.value
              ? (y.value ?? e.baseColor)
              : e.baseColor,
          variant: e.variant,
        })),
        { colorClasses: S, colorStyles: k, variantClasses: _ } = ul(p),
        P = C(() => h?.disabled.value || e.disabled),
        A = B(() => e.variant === 'elevated' && !(e.disabled || e.flat || e.border)),
        D = C(() => {
          if (!(e.value === void 0 || typeof e.value == 'symbol'))
            return Object(e.value) === e.value ? JSON.stringify(e.value, null, 0) : e.value
        })
      function E(R) {
        P.value ||
          (m.isLink.value &&
            (R.metaKey || R.ctrlKey || R.shiftKey || R.button !== 0 || n.target === '_blank')) ||
          (m.isLink.value ? m.navigate?.(R) : h?.toggle())
      }
      return (
        FV(m, h?.select),
        ne(() => {
          const R = m.isLink.value ? 'a' : e.tag,
            V = !!(e.prependIcon || a.prepend),
            M = !!(e.appendIcon || a.append),
            F = !!(e.icon && e.icon !== !0)
          return tt(
            w(
              R,
              Z(m.linkProps, {
                type: R === 'a' ? void 0 : 'button',
                class: [
                  'v-btn',
                  h?.selectedClass.value,
                  {
                    'v-btn--active': b.value,
                    'v-btn--block': e.block,
                    'v-btn--disabled': P.value,
                    'v-btn--elevated': A.value,
                    'v-btn--flat': e.flat,
                    'v-btn--icon': !!e.icon,
                    'v-btn--loading': e.loading,
                    'v-btn--readonly': e.readonly,
                    'v-btn--slim': e.slim,
                    'v-btn--stacked': e.stacked,
                  },
                  e.spaced ? ['v-btn--spaced', `v-btn--spaced-${e.spaced}`] : [],
                  l.value,
                  o.value,
                  S.value,
                  i.value,
                  s.value,
                  c.value,
                  d.value,
                  f.value,
                  v.value,
                  _.value,
                  e.class,
                ],
                style: [k.value, r.value, u.value, g.value, e.style],
                'aria-busy': e.loading ? !0 : void 0,
                disabled: (P.value && R !== 'a') || void 0,
                tabindex: e.loading || e.readonly ? -1 : void 0,
                onClick: E,
                value: D.value,
              }),
              {
                default: () => [
                  Ta(!0, 'v-btn'),
                  !e.icon &&
                    V &&
                    x('span', { key: 'prepend', class: 'v-btn__prepend' }, [
                      a.prepend
                        ? w(
                            Ae,
                            {
                              key: 'prepend-defaults',
                              disabled: !e.prependIcon,
                              defaults: { VIcon: { icon: e.prependIcon } },
                            },
                            a.prepend
                          )
                        : w(Le, { key: 'prepend-icon', icon: e.prependIcon }, null),
                    ]),
                  x('span', { class: 'v-btn__content', 'data-no-activator': '' }, [
                    !a.default && F
                      ? w(Le, { key: 'content-icon', icon: e.icon }, null)
                      : w(
                          Ae,
                          {
                            key: 'content-defaults',
                            disabled: !F,
                            defaults: { VIcon: { icon: e.icon } },
                          },
                          { default: () => [a.default?.() ?? Bn(e.text)] }
                        ),
                  ]),
                  !e.icon &&
                    M &&
                    x('span', { key: 'append', class: 'v-btn__append' }, [
                      a.append
                        ? w(
                            Ae,
                            {
                              key: 'append-defaults',
                              disabled: !e.appendIcon,
                              defaults: { VIcon: { icon: e.appendIcon } },
                            },
                            a.append
                          )
                        : w(Le, { key: 'append-icon', icon: e.appendIcon }, null),
                    ]),
                  !!e.loading &&
                    x('span', { key: 'loader', class: 'v-btn__loader' }, [
                      a.loader?.() ??
                        w(
                          Ja,
                          {
                            color: typeof e.loading == 'boolean' ? void 0 : e.loading,
                            indeterminate: !0,
                            width: '2',
                          },
                          null
                        ),
                    ]),
                ],
              }
            ),
            [[Nt, !P.value && e.ripple, '', { center: !!e.icon }]]
          )
        }),
        { group: h }
      )
    },
  }),
  UV = $({ ...je(jr({ icon: '$menu', variant: 'text' }), ['spaced']) }, 'VAppBarNavIcon'),
  KV = J()({
    name: 'VAppBarNavIcon',
    props: UV(),
    setup(e, t) {
      let { slots: n } = t
      return (ne(() => w(Me, Z(e, { class: ['v-app-bar-nav-icon'] }), n)), {})
    },
  }),
  GV = J()({
    name: 'VAppBarTitle',
    props: Dy(),
    setup(e, t) {
      let { slots: n } = t
      return (ne(() => w(id, Z(e, { class: 'v-app-bar-title' }), n)), {})
    },
  }),
  qy = da('v-alert-title'),
  YV = $(
    {
      iconSize: [Number, String],
      iconSizes: {
        type: Array,
        default: () => [
          ['x-small', 10],
          ['small', 16],
          ['default', 24],
          ['large', 28],
          ['x-large', 32],
        ],
      },
    },
    'iconSize'
  )
function qV(e, t) {
  return {
    iconSize: C(() => {
      const a = new Map(e.iconSizes),
        l = e.iconSize ?? t() ?? 'default'
      return a.has(l) ? a.get(l) : l
    }),
  }
}
const XV = ['success', 'info', 'warning', 'error'],
  ZV = $(
    {
      border: {
        type: [Boolean, String],
        validator: (e) => typeof e == 'boolean' || ['top', 'end', 'bottom', 'start'].includes(e),
      },
      borderColor: String,
      closable: Boolean,
      closeIcon: { type: Se, default: '$close' },
      closeLabel: { type: String, default: '$vuetify.close' },
      icon: { type: [Boolean, String, Function, Object], default: null },
      modelValue: { type: Boolean, default: !0 },
      prominent: Boolean,
      title: String,
      text: String,
      type: { type: String, validator: (e) => XV.includes(e) },
      ...be(),
      ...St(),
      ...ft(),
      ...yt(),
      ...YV(),
      ...fa(),
      ...Jl(),
      ...Je(),
      ...Ie(),
      ...Be(),
      ...yn({ variant: 'flat' }),
    },
    'VAlert'
  ),
  JV = J()({
    name: 'VAlert',
    props: ZV(),
    emits: { 'click:close': (e) => !0, 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { emit: n, slots: a } = t
      const l = we(e, 'modelValue'),
        o = B(() => {
          if (e.icon !== !1) return e.type ? (e.icon ?? `$${e.type}`) : e.icon
        }),
        { iconSize: i } = qV(e, () => (e.prominent ? 44 : void 0)),
        { themeClasses: r } = $e(e),
        {
          colorClasses: s,
          colorStyles: c,
          variantClasses: u,
        } = ul(() => ({ color: e.color ?? e.type, variant: e.variant })),
        { densityClasses: d } = Ht(e),
        { dimensionStyles: f } = vt(e),
        { elevationClasses: v } = xt(e),
        { locationStyles: g } = vl(e),
        { positionClasses: h } = Ql(e),
        { roundedClasses: m } = ot(e),
        { textColorClasses: b, textColorStyles: y } = Vt(() => e.borderColor),
        { t: p } = ze(),
        S = B(() => ({
          'aria-label': p(e.closeLabel),
          onClick(k) {
            ;((l.value = !1), n('click:close', k))
          },
        }))
      return () => {
        const k = !!(a.prepend || o.value),
          _ = !!(a.title || e.title),
          P = !!(a.close || e.closable),
          A = {
            density: e.density,
            icon: o.value,
            size: e.iconSize || e.prominent ? i.value : void 0,
          }
        return (
          l.value &&
          w(
            e.tag,
            {
              class: ee([
                'v-alert',
                e.border && {
                  'v-alert--border': !!e.border,
                  [`v-alert--border-${e.border === !0 ? 'start' : e.border}`]: !0,
                },
                { 'v-alert--prominent': e.prominent },
                r.value,
                s.value,
                d.value,
                v.value,
                h.value,
                m.value,
                u.value,
                e.class,
              ]),
              style: ce([c.value, f.value, g.value, e.style]),
              role: 'alert',
            },
            {
              default: () => [
                Ta(!1, 'v-alert'),
                e.border &&
                  x(
                    'div',
                    { key: 'border', class: ee(['v-alert__border', b.value]), style: ce(y.value) },
                    null
                  ),
                k &&
                  x('div', { key: 'prepend', class: 'v-alert__prepend' }, [
                    a.prepend
                      ? w(
                          Ae,
                          {
                            key: 'prepend-defaults',
                            disabled: !o.value,
                            defaults: { VIcon: { ...A } },
                          },
                          a.prepend
                        )
                      : w(Le, Z({ key: 'prepend-icon' }, A), null),
                  ]),
                x('div', { class: 'v-alert__content' }, [
                  _ && w(qy, { key: 'title' }, { default: () => [a.title?.() ?? e.title] }),
                  a.text?.() ?? e.text,
                  a.default?.(),
                ]),
                a.append && x('div', { key: 'append', class: 'v-alert__append' }, [a.append()]),
                P &&
                  x('div', { key: 'close', class: 'v-alert__close' }, [
                    a.close
                      ? w(
                          Ae,
                          {
                            key: 'close-defaults',
                            defaults: {
                              VBtn: { icon: e.closeIcon, size: 'x-small', variant: 'text' },
                            },
                          },
                          { default: () => [a.close?.({ props: S.value })] }
                        )
                      : w(
                          Me,
                          Z(
                            {
                              key: 'close-btn',
                              icon: e.closeIcon,
                              size: 'x-small',
                              variant: 'text',
                            },
                            S.value
                          ),
                          null
                        ),
                  ]),
              ],
            }
          )
        )
      }
    },
  }),
  QV = $(
    {
      start: Boolean,
      end: Boolean,
      icon: Se,
      image: String,
      text: String,
      ...Ut(),
      ...be(),
      ...St(),
      ...Je(),
      ...Un(),
      ...Ie(),
      ...Be(),
      ...yn({ variant: 'flat' }),
    },
    'VAvatar'
  ),
  sn = J()({
    name: 'VAvatar',
    props: QV(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: a } = $e(e),
        { borderClasses: l } = Jt(e),
        { colorClasses: o, colorStyles: i, variantClasses: r } = ul(e),
        { densityClasses: s } = Ht(e),
        { roundedClasses: c } = ot(e),
        { sizeClasses: u, sizeStyles: d } = Zl(e)
      return (
        ne(() =>
          w(
            e.tag,
            {
              class: ee([
                'v-avatar',
                { 'v-avatar--start': e.start, 'v-avatar--end': e.end },
                a.value,
                l.value,
                o.value,
                s.value,
                c.value,
                u.value,
                r.value,
                e.class,
              ]),
              style: ce([i.value, d.value, e.style]),
            },
            {
              default: () => [
                n.default
                  ? w(
                      Ae,
                      {
                        key: 'content-defaults',
                        defaults: { VImg: { cover: !0, src: e.image }, VIcon: { icon: e.icon } },
                      },
                      { default: () => [n.default()] }
                    )
                  : e.image
                    ? w(oa, { key: 'image', src: e.image, alt: '', cover: !0 }, null)
                    : e.icon
                      ? w(Le, { key: 'icon', icon: e.icon }, null)
                      : e.text,
                Ta(!1, 'v-avatar'),
              ],
            }
          )
        ),
        {}
      )
    },
  }),
  eI = $({ text: String, onClick: Pt(), ...be(), ...Be() }, 'VLabel'),
  eo = J()({
    name: 'VLabel',
    props: eI(),
    setup(e, t) {
      let { slots: n } = t
      return (
        ne(() =>
          x(
            'label',
            {
              class: ee(['v-label', { 'v-label--clickable': !!e.onClick }, e.class]),
              style: ce(e.style),
              onClick: e.onClick,
            },
            [e.text, n.default?.()]
          )
        ),
        {}
      )
    },
  }),
  Xy = Symbol.for('vuetify:selection-control-group'),
  fd = $(
    {
      color: String,
      disabled: { type: Boolean, default: null },
      defaultsTarget: String,
      error: Boolean,
      id: String,
      inline: Boolean,
      falseIcon: Se,
      trueIcon: Se,
      ripple: { type: [Boolean, Object], default: !0 },
      multiple: { type: Boolean, default: null },
      name: String,
      readonly: { type: Boolean, default: null },
      modelValue: null,
      type: String,
      valueComparator: { type: Function, default: kt },
      ...be(),
      ...St(),
      ...Be(),
    },
    'SelectionControlGroup'
  ),
  tI = $({ ...fd({ defaultsTarget: 'VSelectionControl' }) }, 'VSelectionControlGroup'),
  Zy = J()({
    name: 'VSelectionControlGroup',
    props: tI(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = we(e, 'modelValue'),
        l = Rt(),
        o = B(() => e.id || `v-selection-control-group-${l}`),
        i = B(() => e.name || o.value),
        r = new Set()
      return (
        Fe(Xy, {
          modelValue: a,
          forceUpdate: () => {
            r.forEach((s) => s())
          },
          onForceUpdate: (s) => {
            ;(r.add(s),
              bt(() => {
                r.delete(s)
              }))
          },
        }),
        lt({
          [e.defaultsTarget]: {
            color: B(() => e.color),
            disabled: B(() => e.disabled),
            density: B(() => e.density),
            error: B(() => e.error),
            inline: B(() => e.inline),
            modelValue: a,
            multiple: B(() => !!e.multiple || (e.multiple == null && Array.isArray(a.value))),
            name: i,
            falseIcon: B(() => e.falseIcon),
            trueIcon: B(() => e.trueIcon),
            readonly: B(() => e.readonly),
            ripple: B(() => e.ripple),
            type: B(() => e.type),
            valueComparator: B(() => e.valueComparator),
          },
        }),
        ne(() =>
          x(
            'div',
            {
              class: ee([
                'v-selection-control-group',
                { 'v-selection-control-group--inline': e.inline },
                e.class,
              ]),
              style: ce(e.style),
              role: e.type === 'radio' ? 'radiogroup' : void 0,
            },
            [n.default?.()]
          )
        ),
        {}
      )
    },
  }),
  zr = $(
    {
      label: String,
      baseColor: String,
      trueValue: null,
      falseValue: null,
      value: null,
      ...be(),
      ...fd(),
    },
    'VSelectionControl'
  )
function nI(e) {
  const t = Ve(Xy, void 0),
    { densityClasses: n } = Ht(e),
    a = we(e, 'modelValue'),
    l = C(() => (e.trueValue !== void 0 ? e.trueValue : e.value !== void 0 ? e.value : !0)),
    o = C(() => (e.falseValue !== void 0 ? e.falseValue : !1)),
    i = C(() => !!e.multiple || (e.multiple == null && Array.isArray(a.value))),
    r = C({
      get() {
        const v = t ? t.modelValue.value : a.value
        return i.value
          ? nt(v).some((g) => e.valueComparator(g, l.value))
          : e.valueComparator(v, l.value)
      },
      set(v) {
        if (e.readonly) return
        const g = v ? l.value : o.value
        let h = g
        ;(i.value &&
          (h = v ? [...nt(a.value), g] : nt(a.value).filter((m) => !e.valueComparator(m, l.value))),
          t ? (t.modelValue.value = h) : (a.value = h))
      },
    }),
    { textColorClasses: s, textColorStyles: c } = Vt(() => {
      if (!(e.error || e.disabled)) return r.value ? e.color : e.baseColor
    }),
    { backgroundColorClasses: u, backgroundColorStyles: d } = He(() =>
      r.value && !e.error && !e.disabled ? e.color : e.baseColor
    ),
    f = C(() => (r.value ? e.trueIcon : e.falseIcon))
  return {
    group: t,
    densityClasses: n,
    trueValue: l,
    falseValue: o,
    model: r,
    textColorClasses: s,
    textColorStyles: c,
    backgroundColorClasses: u,
    backgroundColorStyles: d,
    icon: f,
  }
}
const Pa = J()({
    name: 'VSelectionControl',
    directives: { vRipple: Nt },
    inheritAttrs: !1,
    props: zr(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: a } = t
      const {
          group: l,
          densityClasses: o,
          icon: i,
          model: r,
          textColorClasses: s,
          textColorStyles: c,
          backgroundColorClasses: u,
          backgroundColorStyles: d,
          trueValue: f,
        } = nI(e),
        v = Rt(),
        g = oe(!1),
        h = oe(!1),
        m = ae(),
        b = B(() => e.id || `input-${v}`),
        y = B(() => !e.disabled && !e.readonly)
      l?.onForceUpdate(() => {
        m.value && (m.value.checked = r.value)
      })
      function p(P) {
        y.value && ((g.value = !0), Hl(P.target, ':focus-visible') !== !1 && (h.value = !0))
      }
      function S() {
        ;((g.value = !1), (h.value = !1))
      }
      function k(P) {
        P.stopPropagation()
      }
      function _(P) {
        if (!y.value) {
          m.value && (m.value.checked = r.value)
          return
        }
        ;(e.readonly && l && Re(() => l.forceUpdate()), (r.value = P.target.checked))
      }
      return (
        ne(() => {
          const P = a.label ? a.label({ label: e.label, props: { for: b.value } }) : e.label,
            [A, D] = Ia(n),
            E = x(
              'input',
              Z(
                {
                  ref: m,
                  checked: r.value,
                  disabled: !!e.disabled,
                  id: b.value,
                  onBlur: S,
                  onFocus: p,
                  onInput: _,
                  'aria-disabled': !!e.disabled,
                  'aria-label': e.label,
                  type: e.type,
                  value: f.value,
                  name: e.name,
                  'aria-checked': e.type === 'checkbox' ? r.value : void 0,
                },
                D
              ),
              null
            )
          return x(
            'div',
            Z(
              {
                class: [
                  'v-selection-control',
                  {
                    'v-selection-control--dirty': r.value,
                    'v-selection-control--disabled': e.disabled,
                    'v-selection-control--error': e.error,
                    'v-selection-control--focused': g.value,
                    'v-selection-control--focus-visible': h.value,
                    'v-selection-control--inline': e.inline,
                  },
                  o.value,
                  e.class,
                ],
              },
              A,
              { style: e.style }
            ),
            [
              x(
                'div',
                { class: ee(['v-selection-control__wrapper', s.value]), style: ce(c.value) },
                [
                  a.default?.({ backgroundColorClasses: u, backgroundColorStyles: d }),
                  tt(
                    x('div', { class: ee(['v-selection-control__input']) }, [
                      a.input?.({
                        model: r,
                        textColorClasses: s,
                        textColorStyles: c,
                        backgroundColorClasses: u,
                        backgroundColorStyles: d,
                        inputNode: E,
                        icon: i.value,
                        props: { onFocus: p, onBlur: S, id: b.value },
                      }) ??
                        x(he, null, [i.value && w(Le, { key: 'icon', icon: i.value }, null), E]),
                    ]),
                    [[Nt, !e.disabled && !e.readonly && e.ripple, null, { center: !0, circle: !0 }]]
                  ),
                ]
              ),
              P && w(eo, { for: b.value, onClick: k }, { default: () => [P] }),
            ]
          )
        }),
        { isFocused: g, input: m }
      )
    },
  }),
  Jy = $(
    {
      indeterminate: Boolean,
      indeterminateIcon: { type: Se, default: '$checkboxIndeterminate' },
      ...zr({ falseIcon: '$checkboxOff', trueIcon: '$checkboxOn' }),
    },
    'VCheckboxBtn'
  ),
  Fn = J()({
    name: 'VCheckboxBtn',
    props: Jy(),
    emits: { 'update:modelValue': (e) => !0, 'update:indeterminate': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = we(e, 'indeterminate'),
        l = we(e, 'modelValue')
      function o(s) {
        a.value && (a.value = !1)
      }
      const i = B(() => (a.value ? e.indeterminateIcon : e.falseIcon)),
        r = B(() => (a.value ? e.indeterminateIcon : e.trueIcon))
      return (
        ne(() => {
          const s = je(Pa.filterProps(e), ['modelValue'])
          return w(
            Pa,
            Z(s, {
              modelValue: l.value,
              'onUpdate:modelValue': [(c) => (l.value = c), o],
              class: ['v-checkbox-btn', e.class],
              style: e.style,
              type: 'checkbox',
              falseIcon: i.value,
              trueIcon: r.value,
              'aria-checked': a.value ? 'mixed' : void 0,
            }),
            n
          )
        }),
        {}
      )
    },
  })
function Qy(e) {
  const { t } = ze()
  function n(a) {
    let { name: l, color: o, ...i } = a
    const r = {
        prepend: 'prependAction',
        prependInner: 'prependAction',
        append: 'appendAction',
        appendInner: 'appendAction',
        clear: 'clear',
      }[l],
      s = e[`onClick:${l}`]
    function c(d) {
      ;(d.key !== 'Enter' && d.key !== ' ') ||
        (d.preventDefault(), d.stopPropagation(), ti(s, new PointerEvent('click', d)))
    }
    const u = s && r ? t(`$vuetify.input.${r}`, e.label ?? '') : void 0
    return w(
      Le,
      Z({ icon: e[`${l}Icon`], 'aria-label': u, onClick: s, onKeydown: c, color: o }, i),
      null
    )
  }
  return { InputIcon: n }
}
const aI = $(
    {
      active: Boolean,
      color: String,
      messages: { type: [Array, String], default: () => [] },
      ...be(),
      ...Vn({ transition: { component: sd, leaveAbsolute: !0, group: !0 } }),
    },
    'VMessages'
  ),
  eb = J()({
    name: 'VMessages',
    props: aI(),
    setup(e, t) {
      let { slots: n } = t
      const a = C(() => nt(e.messages)),
        { textColorClasses: l, textColorStyles: o } = Vt(() => e.color)
      return (
        ne(() =>
          w(
            $t,
            {
              transition: e.transition,
              tag: 'div',
              class: ee(['v-messages', l.value, e.class]),
              style: ce([o.value, e.style]),
            },
            {
              default: () => [
                e.active &&
                  a.value.map((i, r) =>
                    x('div', { class: 'v-messages__message', key: `${r}-${a.value}` }, [
                      n.message ? n.message({ message: i }) : i,
                    ])
                  ),
              ],
            }
          )
        ),
        {}
      )
    },
  }),
  ci = $({ focused: Boolean, 'onUpdate:focused': Pt() }, 'focus')
function va(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Wn()
  const n = we(e, 'focused'),
    a = B(() => ({ [`${t}--focused`]: n.value }))
  function l() {
    n.value = !0
  }
  function o() {
    n.value = !1
  }
  return { focusClasses: a, isFocused: n, focus: l, blur: o }
}
const tb = Symbol.for('vuetify:form'),
  lI = $(
    {
      disabled: Boolean,
      fastFail: Boolean,
      readonly: Boolean,
      modelValue: { type: Boolean, default: null },
      validateOn: { type: String, default: 'input' },
    },
    'form'
  )
function oI(e) {
  const t = we(e, 'modelValue'),
    n = B(() => e.disabled),
    a = B(() => e.readonly),
    l = oe(!1),
    o = ae([]),
    i = ae([])
  async function r() {
    const u = []
    let d = !0
    ;((i.value = []), (l.value = !0))
    for (const f of o.value) {
      const v = await f.validate()
      if ((v.length > 0 && ((d = !1), u.push({ id: f.id, errorMessages: v })), !d && e.fastFail))
        break
    }
    return ((i.value = u), (l.value = !1), { valid: d, errors: i.value })
  }
  function s() {
    o.value.forEach((u) => u.reset())
  }
  function c() {
    o.value.forEach((u) => u.resetValidation())
  }
  return (
    ue(
      o,
      () => {
        let u = 0,
          d = 0
        const f = []
        for (const v of o.value)
          v.isValid === !1
            ? (d++, f.push({ id: v.id, errorMessages: v.errorMessages }))
            : v.isValid === !0 && u++
        ;((i.value = f), (t.value = d > 0 ? !1 : u === o.value.length ? !0 : null))
      },
      { deep: !0, flush: 'post' }
    ),
    Fe(tb, {
      register: (u) => {
        let { id: d, vm: f, validate: v, reset: g, resetValidation: h } = u
        ;(o.value.some((m) => m.id === d),
          o.value.push({
            id: d,
            validate: v,
            reset: g,
            resetValidation: h,
            vm: Qm(f),
            isValid: null,
            errorMessages: [],
          }))
      },
      unregister: (u) => {
        o.value = o.value.filter((d) => d.id !== u)
      },
      update: (u, d, f) => {
        const v = o.value.find((g) => g.id === u)
        v && ((v.isValid = d), (v.errorMessages = f))
      },
      isDisabled: n,
      isReadonly: a,
      isValidating: l,
      isValid: t,
      items: o,
      validateOn: B(() => e.validateOn),
    }),
    {
      errors: i,
      isDisabled: n,
      isReadonly: a,
      isValidating: l,
      isValid: t,
      items: o,
      validate: r,
      reset: s,
      resetValidation: c,
    }
  )
}
function to(e) {
  const t = Ve(tb, null)
  return {
    ...t,
    isReadonly: C(() => !!(e?.readonly ?? t?.isReadonly.value)),
    isDisabled: C(() => !!(e?.disabled ?? t?.isDisabled.value)),
  }
}
const iI = Symbol.for('vuetify:rules')
function rI(e) {
  const t = Ve(iI, null)
  if (!e) {
    if (!t) throw new Error('Could not find Vuetify rules injection')
    return t.aliases
  }
  return t?.resolve(e) ?? B(e)
}
const nb = $(
  {
    disabled: { type: Boolean, default: null },
    error: Boolean,
    errorMessages: { type: [Array, String], default: () => [] },
    maxErrors: { type: [Number, String], default: 1 },
    name: String,
    label: String,
    readonly: { type: Boolean, default: null },
    rules: { type: Array, default: () => [] },
    modelValue: null,
    validateOn: String,
    validationValue: null,
    ...ci(),
  },
  'validation'
)
function ab(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Wn(),
    n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Rt()
  const a = we(e, 'modelValue'),
    l = C(() => (e.validationValue === void 0 ? a.value : e.validationValue)),
    o = to(e),
    i = rI(() => e.rules),
    r = ae([]),
    s = oe(!0),
    c = C(
      () =>
        !!(nt(a.value === '' ? null : a.value).length || nt(l.value === '' ? null : l.value).length)
    ),
    u = C(() =>
      e.errorMessages?.length
        ? nt(e.errorMessages)
            .concat(r.value)
            .slice(0, Math.max(0, Number(e.maxErrors)))
        : r.value
    ),
    d = C(() => {
      let S = (e.validateOn ?? o.validateOn?.value) || 'input'
      ;(S === 'lazy' && (S = 'input lazy'), S === 'eager' && (S = 'input eager'))
      const k = new Set(S?.split(' ') ?? [])
      return {
        input: k.has('input'),
        blur: k.has('blur') || k.has('input') || k.has('invalid-input'),
        invalidInput: k.has('invalid-input'),
        lazy: k.has('lazy'),
        eager: k.has('eager'),
      }
    }),
    f = C(() =>
      e.error || e.errorMessages?.length
        ? !1
        : e.rules.length
          ? s.value
            ? r.value.length || d.value.lazy
              ? null
              : !0
            : !r.value.length
          : !0
    ),
    v = oe(!1),
    g = C(() => ({
      [`${t}--error`]: f.value === !1,
      [`${t}--dirty`]: c.value,
      [`${t}--disabled`]: o.isDisabled.value,
      [`${t}--readonly`]: o.isReadonly.value,
    })),
    h = rt('validation'),
    m = C(() => e.name ?? Ke(n))
  ;(Xl(() => {
    o.register?.({ id: m.value, vm: h, validate: p, reset: b, resetValidation: y })
  }),
    dt(() => {
      o.unregister?.(m.value)
    }),
    pt(async () => {
      ;(d.value.lazy || (await p(!d.value.eager)), o.update?.(m.value, f.value, u.value))
    }),
    Et(
      () => d.value.input || (d.value.invalidInput && f.value === !1),
      () => {
        ue(l, () => {
          if (l.value != null) p()
          else if (e.focused) {
            const S = ue(
              () => e.focused,
              (k) => {
                ;(k || p(), S())
              }
            )
          }
        })
      }
    ),
    Et(
      () => d.value.blur,
      () => {
        ue(
          () => e.focused,
          (S) => {
            S || p()
          }
        )
      }
    ),
    ue([f, u], () => {
      o.update?.(m.value, f.value, u.value)
    }))
  async function b() {
    ;((a.value = null), await Re(), await y())
  }
  async function y() {
    ;((s.value = !0), d.value.lazy ? (r.value = []) : await p(!d.value.eager))
  }
  async function p() {
    let S = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1
    const k = []
    v.value = !0
    for (const _ of i.value) {
      if (k.length >= Number(e.maxErrors ?? 1)) break
      const A = await (typeof _ == 'function' ? _ : () => _)(l.value)
      if (A !== !0) {
        if (A !== !1 && typeof A != 'string') {
          console.warn(
            `${A} is not a valid value. Rule functions must return boolean true or a string.`
          )
          continue
        }
        k.push(A || '')
      }
    }
    return ((r.value = k), (v.value = !1), (s.value = S), r.value)
  }
  return {
    errorMessages: u,
    isDirty: c,
    isDisabled: o.isDisabled,
    isReadonly: o.isReadonly,
    isPristine: s,
    isValid: f,
    isValidating: v,
    reset: b,
    resetValidation: y,
    validate: p,
    validationClasses: g,
  }
}
const ma = $(
    {
      id: String,
      appendIcon: Se,
      baseColor: String,
      centerAffix: { type: Boolean, default: !0 },
      color: String,
      glow: Boolean,
      iconColor: [Boolean, String],
      prependIcon: Se,
      hideDetails: [Boolean, String],
      hideSpinButtons: Boolean,
      hint: String,
      persistentHint: Boolean,
      messages: { type: [Array, String], default: () => [] },
      direction: {
        type: String,
        default: 'horizontal',
        validator: (e) => ['horizontal', 'vertical'].includes(e),
      },
      'onClick:prepend': Pt(),
      'onClick:append': Pt(),
      ...be(),
      ...St(),
      ...Zt(ft(), ['maxWidth', 'minWidth', 'width']),
      ...Be(),
      ...nb(),
    },
    'VInput'
  ),
  Dt = J()({
    name: 'VInput',
    props: { ...ma() },
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: a, emit: l } = t
      const { densityClasses: o } = Ht(e),
        { dimensionStyles: i } = vt(e),
        { themeClasses: r } = $e(e),
        { rtlClasses: s } = gt(),
        { InputIcon: c } = Qy(e),
        u = Rt(),
        d = C(() => e.id || `input-${u}`),
        {
          errorMessages: f,
          isDirty: v,
          isDisabled: g,
          isReadonly: h,
          isPristine: m,
          isValid: b,
          isValidating: y,
          reset: p,
          resetValidation: S,
          validate: k,
          validationClasses: _,
        } = ab(e, 'v-input', d),
        P = C(() =>
          e.errorMessages?.length || (!m.value && f.value.length)
            ? f.value
            : e.hint && (e.persistentHint || e.focused)
              ? e.hint
              : e.messages
        ),
        A = B(() => P.value.length > 0),
        D = B(() => !e.hideDetails || (e.hideDetails === 'auto' && (A.value || !!a.details))),
        E = C(() => (D.value ? `${d.value}-messages` : void 0)),
        R = C(() => ({
          id: d,
          messagesId: E,
          isDirty: v,
          isDisabled: g,
          isReadonly: h,
          isPristine: m,
          isValid: b,
          isValidating: y,
          hasDetails: D,
          reset: p,
          resetValidation: S,
          validate: k,
        })),
        V = B(() => (e.error || e.disabled ? void 0 : e.focused ? e.color : e.baseColor)),
        M = B(() => {
          if (e.iconColor) return e.iconColor === !0 ? V.value : e.iconColor
        })
      return (
        ne(() => {
          const F = !!(a.prepend || e.prependIcon),
            G = !!(a.append || e.appendIcon)
          return x(
            'div',
            {
              class: ee([
                'v-input',
                `v-input--${e.direction}`,
                {
                  'v-input--center-affix': e.centerAffix,
                  'v-input--focused': e.focused,
                  'v-input--glow': e.glow,
                  'v-input--hide-spin-buttons': e.hideSpinButtons,
                },
                o.value,
                r.value,
                s.value,
                _.value,
                e.class,
              ]),
              style: ce([i.value, e.style]),
            },
            [
              F &&
                x('div', { key: 'prepend', class: 'v-input__prepend' }, [
                  a.prepend?.(R.value),
                  e.prependIcon &&
                    w(c, { key: 'prepend-icon', name: 'prepend', color: M.value }, null),
                ]),
              a.default && x('div', { class: 'v-input__control' }, [a.default?.(R.value)]),
              G &&
                x('div', { key: 'append', class: 'v-input__append' }, [
                  e.appendIcon &&
                    w(c, { key: 'append-icon', name: 'append', color: M.value }, null),
                  a.append?.(R.value),
                ]),
              D.value &&
                x(
                  'div',
                  { id: E.value, class: 'v-input__details', role: 'alert', 'aria-live': 'polite' },
                  [
                    w(eb, { active: A.value, messages: P.value }, { message: a.message }),
                    a.details?.(R.value),
                  ]
                ),
            ]
          )
        }),
        { reset: p, resetValidation: S, validate: k, isValid: b, errorMessages: f }
      )
    },
  }),
  Ms = Symbol('Forwarded refs')
function Bs(e, t) {
  let n = e
  for (; n; ) {
    const a = Reflect.getOwnPropertyDescriptor(n, t)
    if (a) return a
    n = Object.getPrototypeOf(n)
  }
}
function _t(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++)
    n[a - 1] = arguments[a]
  return (
    (e[Ms] = n),
    new Proxy(e, {
      get(l, o) {
        if (Reflect.has(l, o)) return Reflect.get(l, o)
        if (!(typeof o == 'symbol' || o.startsWith('$') || o.startsWith('__'))) {
          for (const i of n)
            if (i.value && Reflect.has(i.value, o)) {
              const r = Reflect.get(i.value, o)
              return typeof r == 'function' ? r.bind(i.value) : r
            }
        }
      },
      has(l, o) {
        if (Reflect.has(l, o)) return !0
        if (typeof o == 'symbol' || o.startsWith('$') || o.startsWith('__')) return !1
        for (const i of n) if (i.value && Reflect.has(i.value, o)) return !0
        return !1
      },
      set(l, o, i) {
        if (Reflect.has(l, o)) return Reflect.set(l, o, i)
        if (typeof o == 'symbol' || o.startsWith('$') || o.startsWith('__')) return !1
        for (const r of n) if (r.value && Reflect.has(r.value, o)) return Reflect.set(r.value, o, i)
        return !1
      },
      getOwnPropertyDescriptor(l, o) {
        const i = Reflect.getOwnPropertyDescriptor(l, o)
        if (i) return i
        if (!(typeof o == 'symbol' || o.startsWith('$') || o.startsWith('__'))) {
          for (const r of n) {
            if (!r.value) continue
            const s = Bs(r.value, o) ?? ('_' in r.value ? Bs(r.value._?.setupState, o) : void 0)
            if (s) return s
          }
          for (const r of n) {
            const s = r.value && r.value[Ms]
            if (!s) continue
            const c = s.slice()
            for (; c.length; ) {
              const u = c.shift(),
                d = Bs(u.value, o)
              if (d) return d
              const f = u.value && u.value[Ms]
              f && c.push(...f)
            }
          }
        }
      },
    })
  )
}
const sI = $({ ...ma(), ...je(Jy(), ['inline']) }, 'VCheckbox'),
  uI = J()({
    name: 'VCheckbox',
    inheritAttrs: !1,
    props: sI(),
    emits: { 'update:modelValue': (e) => !0, 'update:focused': (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: a } = t
      const l = we(e, 'modelValue'),
        { isFocused: o, focus: i, blur: r } = va(e),
        s = ae(),
        c = Rt()
      return (
        ne(() => {
          const [u, d] = Ia(n),
            f = Dt.filterProps(e),
            v = Fn.filterProps(e)
          return w(
            Dt,
            Z({ ref: s, class: ['v-checkbox', e.class] }, u, f, {
              modelValue: l.value,
              'onUpdate:modelValue': (g) => (l.value = g),
              id: e.id || `checkbox-${c}`,
              focused: o.value,
              style: e.style,
            }),
            {
              ...a,
              default: (g) => {
                let { id: h, messagesId: m, isDisabled: b, isReadonly: y, isValid: p } = g
                return w(
                  Fn,
                  Z(
                    v,
                    {
                      id: h.value,
                      'aria-describedby': m.value,
                      disabled: b.value,
                      readonly: y.value,
                    },
                    d,
                    {
                      error: p.value === !1,
                      modelValue: l.value,
                      'onUpdate:modelValue': (S) => (l.value = S),
                      onFocus: i,
                      onBlur: r,
                    }
                  ),
                  a
                )
              },
            }
          )
        }),
        _t({}, s)
      )
    },
  })
function cI(e) {
  let { selectedElement: t, containerElement: n, isRtl: a, isHorizontal: l } = e
  const o = jo(l, n),
    i = lb(l, a, n),
    r = jo(l, t),
    s = ob(l, t),
    c = r * 0.4
  return i > s ? s - c : i + o < s + r ? s - o + r + c : i
}
function dI(e) {
  let { selectedElement: t, containerElement: n, isHorizontal: a } = e
  const l = jo(a, n),
    o = ob(a, t),
    i = jo(a, t)
  return o - l / 2 + i / 2
}
function um(e, t) {
  return t?.[e ? 'scrollWidth' : 'scrollHeight'] || 0
}
function fI(e, t) {
  return t?.[e ? 'clientWidth' : 'clientHeight'] || 0
}
function lb(e, t, n) {
  if (!n) return 0
  const { scrollLeft: a, offsetWidth: l, scrollWidth: o } = n
  return e ? (t ? o - l + a : a) : n.scrollTop
}
function jo(e, t) {
  return t?.[e ? 'offsetWidth' : 'offsetHeight'] || 0
}
function ob(e, t) {
  return t?.[e ? 'offsetLeft' : 'offsetTop'] || 0
}
const ib = Symbol.for('vuetify:v-slide-group'),
  vd = $(
    {
      centerActive: Boolean,
      contentClass: null,
      direction: { type: String, default: 'horizontal' },
      symbol: { type: null, default: ib },
      nextIcon: { type: Se, default: '$next' },
      prevIcon: { type: Se, default: '$prev' },
      showArrows: {
        type: [Boolean, String],
        validator: (e) => typeof e == 'boolean' || ['always', 'desktop', 'mobile'].includes(e),
      },
      ...be(),
      ...ol({ mobile: null }),
      ...Ie(),
      ...cl({ selectedClass: 'v-slide-group-item--active' }),
    },
    'VSlideGroup'
  ),
  zo = J()({
    name: 'VSlideGroup',
    props: vd(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { isRtl: a } = gt(),
        { displayClasses: l, mobile: o } = gn(e),
        i = Aa(e, e.symbol),
        r = oe(!1),
        s = oe(0),
        c = oe(0),
        u = oe(0),
        d = C(() => e.direction === 'horizontal'),
        { resizeRef: f, contentRect: v } = hn(),
        { resizeRef: g, contentRect: h } = hn(),
        m = $P(),
        b = C(() => ({ container: f.el, duration: 200, easing: 'easeOutQuart' })),
        y = C(() =>
          i.selected.value.length
            ? i.items.value.findIndex((Y) => Y.id === i.selected.value[0])
            : -1
        ),
        p = C(() =>
          i.selected.value.length
            ? i.items.value.findIndex((Y) => Y.id === i.selected.value[i.selected.value.length - 1])
            : -1
        )
      if (Ne) {
        let Y = -1
        ue(
          () => [i.selected.value, v.value, h.value, d.value],
          () => {
            ;(cancelAnimationFrame(Y),
              (Y = requestAnimationFrame(() => {
                if (v.value && h.value) {
                  const K = d.value ? 'width' : 'height'
                  ;((c.value = v.value[K]),
                    (u.value = h.value[K]),
                    (r.value = c.value + 1 < u.value))
                }
                if (y.value >= 0 && g.el) {
                  const K = g.el.children[p.value]
                  k(K, e.centerActive)
                }
              })))
          }
        )
      }
      const S = oe(!1)
      function k(Y, K) {
        let se = 0
        ;(K
          ? (se = dI({ containerElement: f.el, isHorizontal: d.value, selectedElement: Y }))
          : (se = cI({
              containerElement: f.el,
              isHorizontal: d.value,
              isRtl: a.value,
              selectedElement: Y,
            })),
          _(se))
      }
      function _(Y) {
        if (!Ne || !f.el) return
        const K = jo(d.value, f.el),
          se = lb(d.value, a.value, f.el)
        if (!(um(d.value, f.el) <= K || Math.abs(Y - se) < 16)) {
          if (d.value && a.value && f.el) {
            const { scrollWidth: ye, offsetWidth: L } = f.el
            Y = ye - L - Y
          }
          d.value ? m.horizontal(Y, b.value) : m(Y, b.value)
        }
      }
      function P(Y) {
        const { scrollTop: K, scrollLeft: se } = Y.target
        s.value = d.value ? se : K
      }
      function A(Y) {
        if (((S.value = !0), !(!r.value || !g.el))) {
          for (const K of Y.composedPath())
            for (const se of g.el.children)
              if (se === K) {
                k(se)
                return
              }
        }
      }
      function D(Y) {
        S.value = !1
      }
      let E = !1
      function R(Y) {
        ;(!E && !S.value && !(Y.relatedTarget && g.el?.contains(Y.relatedTarget)) && G(), (E = !1))
      }
      function V() {
        E = !0
      }
      function M(Y) {
        if (!g.el) return
        function K(se) {
          ;(Y.preventDefault(), G(se))
        }
        ;(d.value
          ? Y.key === 'ArrowRight'
            ? K(a.value ? 'prev' : 'next')
            : Y.key === 'ArrowLeft' && K(a.value ? 'next' : 'prev')
          : Y.key === 'ArrowDown'
            ? K('next')
            : Y.key === 'ArrowUp' && K('prev'),
          Y.key === 'Home' ? K('first') : Y.key === 'End' && K('last'))
      }
      function F(Y, K) {
        if (!Y) return
        let se = Y
        do se = se?.[K === 'next' ? 'nextElementSibling' : 'previousElementSibling']
        while (se?.hasAttribute('disabled'))
        return se
      }
      function G(Y) {
        if (!g.el) return
        let K
        if (!Y) K = Ro(g.el)[0]
        else if (Y === 'next') {
          if (((K = F(g.el.querySelector(':focus'), Y)), !K)) return G('first')
        } else if (Y === 'prev') {
          if (((K = F(g.el.querySelector(':focus'), Y)), !K)) return G('last')
        } else
          Y === 'first'
            ? ((K = g.el.firstElementChild), K?.hasAttribute('disabled') && (K = F(K, 'next')))
            : Y === 'last' &&
              ((K = g.el.lastElementChild), K?.hasAttribute('disabled') && (K = F(K, 'prev')))
        K && K.focus({ preventScroll: !0 })
      }
      function W(Y) {
        const K = d.value && a.value ? -1 : 1,
          se = (Y === 'prev' ? -K : K) * c.value
        let de = s.value + se
        if (d.value && a.value && f.el) {
          const { scrollWidth: ye, offsetWidth: L } = f.el
          de += ye - L
        }
        _(de)
      }
      const te = C(() => ({
          next: i.next,
          prev: i.prev,
          select: i.select,
          isSelected: i.isSelected,
        })),
        H = C(() => r.value || Math.abs(s.value) > 0),
        O = C(() => {
          switch (e.showArrows) {
            case 'always':
              return !0
            case 'desktop':
              return !o.value
            case !0:
              return H.value
            case 'mobile':
              return o.value || H.value
            default:
              return !o.value && H.value
          }
        }),
        j = C(() => Math.abs(s.value) > 1),
        U = C(() => {
          if (!f.value || !H.value) return !1
          const Y = um(d.value, f.el),
            K = fI(d.value, f.el)
          return Y - K - Math.abs(s.value) > 1
        })
      return (
        ne(() =>
          w(
            e.tag,
            {
              class: ee([
                'v-slide-group',
                {
                  'v-slide-group--vertical': !d.value,
                  'v-slide-group--has-affixes': O.value,
                  'v-slide-group--is-overflowing': r.value,
                },
                l.value,
                e.class,
              ]),
              style: ce(e.style),
              tabindex: S.value || i.selected.value.length ? -1 : 0,
              onFocus: R,
            },
            {
              default: () => [
                O.value &&
                  x(
                    'div',
                    {
                      key: 'prev',
                      class: ee([
                        'v-slide-group__prev',
                        { 'v-slide-group__prev--disabled': !j.value },
                      ]),
                      onMousedown: V,
                      onClick: () => j.value && W('prev'),
                    },
                    [
                      n.prev?.(te.value) ??
                        w(Fo, null, {
                          default: () => [w(Le, { icon: a.value ? e.nextIcon : e.prevIcon }, null)],
                        }),
                    ]
                  ),
                x(
                  'div',
                  {
                    key: 'container',
                    ref: f,
                    class: ee(['v-slide-group__container', e.contentClass]),
                    onScroll: P,
                  },
                  [
                    x(
                      'div',
                      {
                        ref: g,
                        class: 'v-slide-group__content',
                        onFocusin: A,
                        onFocusout: D,
                        onKeydown: M,
                      },
                      [n.default?.(te.value)]
                    ),
                  ]
                ),
                O.value &&
                  x(
                    'div',
                    {
                      key: 'next',
                      class: ee([
                        'v-slide-group__next',
                        { 'v-slide-group__next--disabled': !U.value },
                      ]),
                      onMousedown: V,
                      onClick: () => U.value && W('next'),
                    },
                    [
                      n.next?.(te.value) ??
                        w(Fo, null, {
                          default: () => [w(Le, { icon: a.value ? e.prevIcon : e.nextIcon }, null)],
                        }),
                    ]
                  ),
              ],
            }
          )
        ),
        { selected: i.selected, scrollTo: W, scrollOffset: s, focus: G, hasPrev: j, hasNext: U }
      )
    },
  }),
  rb = Symbol.for('vuetify:v-chip-group'),
  vI = $(
    {
      baseColor: String,
      column: Boolean,
      filter: Boolean,
      valueComparator: { type: Function, default: kt },
      ...vd(),
      ...be(),
      ...cl({ selectedClass: 'v-chip--selected' }),
      ...Ie(),
      ...Be(),
      ...yn({ variant: 'tonal' }),
    },
    'VChipGroup'
  ),
  mI = J()({
    name: 'VChipGroup',
    props: vI(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: a } = $e(e),
        { isSelected: l, select: o, next: i, prev: r, selected: s } = Aa(e, rb)
      return (
        lt({
          VChip: {
            baseColor: B(() => e.baseColor),
            color: B(() => e.color),
            disabled: B(() => e.disabled),
            filter: B(() => e.filter),
            variant: B(() => e.variant),
          },
        }),
        ne(() => {
          const c = zo.filterProps(e)
          return w(
            zo,
            Z(c, {
              class: ['v-chip-group', { 'v-chip-group--column': e.column }, a.value, e.class],
              style: e.style,
            }),
            {
              default: () => [
                n.default?.({ isSelected: l, select: o, next: i, prev: r, selected: s.value }),
              ],
            }
          )
        }),
        {}
      )
    },
  }),
  hI = $(
    {
      activeClass: String,
      appendAvatar: String,
      appendIcon: Se,
      baseColor: String,
      closable: Boolean,
      closeIcon: { type: Se, default: '$delete' },
      closeLabel: { type: String, default: '$vuetify.close' },
      draggable: Boolean,
      filter: Boolean,
      filterIcon: { type: Se, default: '$complete' },
      label: Boolean,
      link: { type: Boolean, default: void 0 },
      pill: Boolean,
      prependAvatar: String,
      prependIcon: Se,
      ripple: { type: [Boolean, Object], default: !0 },
      text: { type: [String, Number, Boolean], default: void 0 },
      modelValue: { type: Boolean, default: !0 },
      onClick: Pt(),
      onClickOnce: Pt(),
      ...Ut(),
      ...be(),
      ...St(),
      ...yt(),
      ...dl(),
      ...Je(),
      ...ui(),
      ...Un(),
      ...Ie({ tag: 'span' }),
      ...Be(),
      ...yn({ variant: 'tonal' }),
    },
    'VChip'
  ),
  no = J()({
    name: 'VChip',
    directives: { vRipple: Nt },
    props: hI(),
    emits: {
      'click:close': (e) => !0,
      'update:modelValue': (e) => !0,
      'group:selected': (e) => !0,
      click: (e) => !0,
    },
    setup(e, t) {
      let { attrs: n, emit: a, slots: l } = t
      const { t: o } = ze(),
        { borderClasses: i } = Jt(e),
        { densityClasses: r } = Ht(e),
        { elevationClasses: s } = xt(e),
        { roundedClasses: c } = ot(e),
        { sizeClasses: u } = Zl(e),
        { themeClasses: d } = $e(e),
        f = we(e, 'modelValue'),
        v = fl(e, rb, !1),
        g = si(e, n),
        h = B(() => e.link !== !1 && g.isLink.value),
        m = C(() => !e.disabled && e.link !== !1 && (!!v || e.link || g.isClickable.value)),
        b = B(() => ({
          'aria-label': o(e.closeLabel),
          disabled: e.disabled,
          onClick(P) {
            ;(P.preventDefault(), P.stopPropagation(), (f.value = !1), a('click:close', P))
          },
        })),
        {
          colorClasses: y,
          colorStyles: p,
          variantClasses: S,
        } = ul(() => ({
          color: !v || v.isSelected.value ? (e.color ?? e.baseColor) : e.baseColor,
          variant: e.variant,
        }))
      function k(P) {
        ;(a('click', P), m.value && (g.navigate?.(P), v?.toggle()))
      }
      function _(P) {
        ;(P.key === 'Enter' || P.key === ' ') && (P.preventDefault(), k(P))
      }
      return () => {
        const P = g.isLink.value ? 'a' : e.tag,
          A = !!(e.appendIcon || e.appendAvatar),
          D = !!(A || l.append),
          E = !!(l.close || e.closable),
          R = !!(l.filter || e.filter) && v,
          V = !!(e.prependIcon || e.prependAvatar),
          M = !!(V || l.prepend)
        return (
          f.value &&
          tt(
            w(
              P,
              Z(g.linkProps, {
                class: [
                  'v-chip',
                  {
                    'v-chip--disabled': e.disabled,
                    'v-chip--label': e.label,
                    'v-chip--link': m.value,
                    'v-chip--filter': R,
                    'v-chip--pill': e.pill,
                    [`${e.activeClass}`]: e.activeClass && g.isActive?.value,
                  },
                  d.value,
                  i.value,
                  y.value,
                  r.value,
                  s.value,
                  c.value,
                  u.value,
                  S.value,
                  v?.selectedClass.value,
                  e.class,
                ],
                style: [p.value, e.style],
                disabled: e.disabled || void 0,
                draggable: e.draggable,
                tabindex: m.value ? 0 : void 0,
                onClick: k,
                onKeydown: m.value && !h.value && _,
              }),
              {
                default: () => [
                  Ta(m.value, 'v-chip'),
                  R &&
                    w(
                      ud,
                      { key: 'filter' },
                      {
                        default: () => [
                          tt(
                            x('div', { class: 'v-chip__filter' }, [
                              l.filter
                                ? w(
                                    Ae,
                                    {
                                      key: 'filter-defaults',
                                      disabled: !e.filterIcon,
                                      defaults: { VIcon: { icon: e.filterIcon } },
                                    },
                                    l.filter
                                  )
                                : w(Le, { key: 'filter-icon', icon: e.filterIcon }, null),
                            ]),
                            [[Pn, v.isSelected.value]]
                          ),
                        ],
                      }
                    ),
                  M &&
                    x('div', { key: 'prepend', class: 'v-chip__prepend' }, [
                      l.prepend
                        ? w(
                            Ae,
                            {
                              key: 'prepend-defaults',
                              disabled: !V,
                              defaults: {
                                VAvatar: { image: e.prependAvatar, start: !0 },
                                VIcon: { icon: e.prependIcon, start: !0 },
                              },
                            },
                            l.prepend
                          )
                        : x(he, null, [
                            e.prependIcon &&
                              w(Le, { key: 'prepend-icon', icon: e.prependIcon, start: !0 }, null),
                            e.prependAvatar &&
                              w(
                                sn,
                                { key: 'prepend-avatar', image: e.prependAvatar, start: !0 },
                                null
                              ),
                          ]),
                    ]),
                  x('div', { class: 'v-chip__content', 'data-no-activator': '' }, [
                    l.default?.({
                      isSelected: v?.isSelected.value,
                      selectedClass: v?.selectedClass.value,
                      select: v?.select,
                      toggle: v?.toggle,
                      value: v?.value.value,
                      disabled: e.disabled,
                    }) ?? Bn(e.text),
                  ]),
                  D &&
                    x('div', { key: 'append', class: 'v-chip__append' }, [
                      l.append
                        ? w(
                            Ae,
                            {
                              key: 'append-defaults',
                              disabled: !A,
                              defaults: {
                                VAvatar: { end: !0, image: e.appendAvatar },
                                VIcon: { end: !0, icon: e.appendIcon },
                              },
                            },
                            l.append
                          )
                        : x(he, null, [
                            e.appendIcon &&
                              w(Le, { key: 'append-icon', end: !0, icon: e.appendIcon }, null),
                            e.appendAvatar &&
                              w(sn, { key: 'append-avatar', end: !0, image: e.appendAvatar }, null),
                          ]),
                    ]),
                  E &&
                    x(
                      'button',
                      Z(
                        {
                          key: 'close',
                          class: 'v-chip__close',
                          type: 'button',
                          'data-testid': 'close-chip',
                        },
                        b.value
                      ),
                      [
                        l.close
                          ? w(
                              Ae,
                              {
                                key: 'close-defaults',
                                defaults: { VIcon: { icon: e.closeIcon, size: 'x-small' } },
                              },
                              l.close
                            )
                          : w(Le, { key: 'close-icon', icon: e.closeIcon, size: 'x-small' }, null),
                      ]
                    ),
                ],
              }
            ),
            [[Nt, m.value && e.ripple, null]]
          )
        )
      }
    },
  }),
  gI = $(
    {
      color: String,
      inset: Boolean,
      length: [Number, String],
      opacity: [Number, String],
      thickness: [Number, String],
      vertical: Boolean,
      ...be(),
      ...Be(),
    },
    'VDivider'
  ),
  rn = J()({
    name: 'VDivider',
    props: gI(),
    setup(e, t) {
      let { attrs: n, slots: a } = t
      const { themeClasses: l } = $e(e),
        { textColorClasses: o, textColorStyles: i } = Vt(() => e.color),
        r = C(() => {
          const s = {}
          return (
            e.length && (s[e.vertical ? 'height' : 'width'] = fe(e.length)),
            e.thickness &&
              (s[e.vertical ? 'borderRightWidth' : 'borderTopWidth'] = fe(e.thickness)),
            s
          )
        })
      return (
        ne(() => {
          const s = x(
            'hr',
            {
              class: ee([
                { 'v-divider': !0, 'v-divider--inset': e.inset, 'v-divider--vertical': e.vertical },
                l.value,
                o.value,
                e.class,
              ]),
              style: ce([r.value, i.value, { '--v-border-opacity': e.opacity }, e.style]),
              'aria-orientation':
                !n.role || n.role === 'separator'
                  ? e.vertical
                    ? 'vertical'
                    : 'horizontal'
                  : void 0,
              role: `${n.role || 'separator'}`,
            },
            null
          )
          return a.default
            ? x(
                'div',
                {
                  class: ee([
                    'v-divider__wrapper',
                    {
                      'v-divider__wrapper--vertical': e.vertical,
                      'v-divider__wrapper--inset': e.inset,
                    },
                  ]),
                },
                [s, x('div', { class: 'v-divider__content' }, [a.default()]), s]
              )
            : s
        }),
        {}
      )
    },
  }),
  Lu = Symbol.for('vuetify:list')
function sb() {
  let { filterable: e } =
    arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { filterable: !1 }
  const t = Ve(Lu, { filterable: !1, hasPrepend: oe(!1), updateHasPrepend: () => null }),
    n = {
      filterable: t.filterable || e,
      hasPrepend: oe(!1),
      updateHasPrepend: (a) => {
        a && (n.hasPrepend.value = a)
      },
    }
  return (Fe(Lu, n), t)
}
function ub() {
  return Ve(Lu, null)
}
const md = (e) => {
    const t = {
      activate: (n) => {
        let { id: a, value: l, activated: o } = n
        return (
          (a = _e(a)),
          (e && !l && o.size === 1 && o.has(a)) || (l ? o.add(a) : o.delete(a)),
          o
        )
      },
      in: (n, a, l) => {
        let o = new Set()
        if (n != null)
          for (const i of nt(n))
            o = t.activate({ id: i, value: !0, activated: new Set(o), children: a, parents: l })
        return o
      },
      out: (n) => Array.from(n),
    }
    return t
  },
  cb = (e) => {
    const t = md(e)
    return {
      activate: (a) => {
        let { activated: l, id: o, ...i } = a
        o = _e(o)
        const r = l.has(o) ? new Set([o]) : new Set()
        return t.activate({ ...i, id: o, activated: r })
      },
      in: (a, l, o) => {
        let i = new Set()
        if (a != null) {
          const r = nt(a)
          r.length && (i = t.in(r.slice(0, 1), l, o))
        }
        return i
      },
      out: (a, l, o) => t.out(a, l, o),
    }
  },
  yI = (e) => {
    const t = md(e)
    return {
      activate: (a) => {
        let { id: l, activated: o, children: i, ...r } = a
        return ((l = _e(l)), i.has(l) ? o : t.activate({ id: l, activated: o, children: i, ...r }))
      },
      in: t.in,
      out: t.out,
    }
  },
  bI = (e) => {
    const t = cb(e)
    return {
      activate: (a) => {
        let { id: l, activated: o, children: i, ...r } = a
        return ((l = _e(l)), i.has(l) ? o : t.activate({ id: l, activated: o, children: i, ...r }))
      },
      in: t.in,
      out: t.out,
    }
  },
  pI = {
    open: (e) => {
      let { id: t, value: n, opened: a, parents: l } = e
      if (n) {
        const o = new Set()
        o.add(t)
        let i = l.get(t)
        for (; i != null; ) (o.add(i), (i = l.get(i)))
        return o
      } else return (a.delete(t), a)
    },
    select: () => null,
  },
  db = {
    open: (e) => {
      let { id: t, value: n, opened: a, parents: l } = e
      if (n) {
        let o = l.get(t)
        for (a.add(t); o != null && o !== t; ) (a.add(o), (o = l.get(o)))
        return a
      } else a.delete(t)
      return a
    },
    select: () => null,
  },
  SI = {
    open: db.open,
    select: (e) => {
      let { id: t, value: n, opened: a, parents: l } = e
      if (!n) return a
      const o = []
      let i = l.get(t)
      for (; i != null; ) (o.push(i), (i = l.get(i)))
      return new Set(o)
    },
  },
  hd = (e) => {
    const t = {
      select: (n) => {
        let { id: a, value: l, selected: o } = n
        if (((a = _e(a)), e && !l)) {
          const i = Array.from(o.entries()).reduce((r, s) => {
            let [c, u] = s
            return (u === 'on' && r.push(c), r)
          }, [])
          if (i.length === 1 && i[0] === a) return o
        }
        return (o.set(a, l ? 'on' : 'off'), o)
      },
      in: (n, a, l, o) => {
        const i = new Map()
        for (const r of n || [])
          t.select({ id: r, value: !0, selected: i, children: a, parents: l, disabled: o })
        return i
      },
      out: (n) => {
        const a = []
        for (const [l, o] of n.entries()) o === 'on' && a.push(l)
        return a
      },
    }
    return t
  },
  fb = (e) => {
    const t = hd(e)
    return {
      select: (a) => {
        let { selected: l, id: o, ...i } = a
        o = _e(o)
        const r = l.has(o) ? new Map([[o, l.get(o)]]) : new Map()
        return t.select({ ...i, id: o, selected: r })
      },
      in: (a, l, o, i) => (a?.length ? t.in(a.slice(0, 1), l, o, i) : new Map()),
      out: (a, l, o) => t.out(a, l, o),
    }
  },
  wI = (e) => {
    const t = hd(e)
    return {
      select: (a) => {
        let { id: l, selected: o, children: i, ...r } = a
        return ((l = _e(l)), i.has(l) ? o : t.select({ id: l, selected: o, children: i, ...r }))
      },
      in: t.in,
      out: t.out,
    }
  },
  kI = (e) => {
    const t = fb(e)
    return {
      select: (a) => {
        let { id: l, selected: o, children: i, ...r } = a
        return ((l = _e(l)), i.has(l) ? o : t.select({ id: l, selected: o, children: i, ...r }))
      },
      in: t.in,
      out: t.out,
    }
  },
  vb = (e) => {
    const t = {
      select: (n) => {
        let { id: a, value: l, selected: o, children: i, parents: r, disabled: s } = n
        a = _e(a)
        const c = new Map(o),
          u = [a]
        for (; u.length; ) {
          const f = u.shift()
          ;(s.has(f) || o.set(_e(f), l ? 'on' : 'off'), i.has(f) && u.push(...i.get(f)))
        }
        let d = _e(r.get(a))
        for (; d; ) {
          let f = !0,
            v = !0
          for (const g of i.get(d)) {
            const h = _e(g)
            if (
              !s.has(h) &&
              (o.get(h) !== 'on' && (f = !1), o.has(h) && o.get(h) !== 'off' && (v = !1), !f && !v)
            )
              break
          }
          ;(o.set(d, f ? 'on' : v ? 'off' : 'indeterminate'), (d = _e(r.get(d))))
        }
        return e &&
          !l &&
          Array.from(o.entries()).reduce((v, g) => {
            let [h, m] = g
            return (m === 'on' && v.push(h), v)
          }, []).length === 0
          ? c
          : o
      },
      in: (n, a, l, o) => {
        let i = new Map()
        for (const r of n || [])
          i = t.select({ id: r, value: !0, selected: i, children: a, parents: l, disabled: o })
        return i
      },
      out: (n, a) => {
        const l = []
        for (const [o, i] of n.entries()) i === 'on' && !a.has(o) && l.push(o)
        return l
      },
    }
    return t
  },
  CI = (e) => {
    const t = vb(e)
    return {
      select: t.select,
      in: t.in,
      out: (a, l, o) => {
        const i = []
        for (const [r, s] of a.entries())
          if (s === 'on') {
            if (o.has(r)) {
              const c = o.get(r)
              if (a.get(c) === 'on') continue
            }
            i.push(r)
          }
        return i
      },
    }
  },
  Wo = Symbol.for('vuetify:nested'),
  mb = {
    id: oe(),
    root: {
      register: () => null,
      unregister: () => null,
      children: ae(new Map()),
      parents: ae(new Map()),
      disabled: ae(new Set()),
      open: () => null,
      openOnSelect: () => null,
      activate: () => null,
      select: () => null,
      activatable: ae(!1),
      selectable: ae(!1),
      opened: ae(new Set()),
      activated: ae(new Set()),
      selected: ae(new Map()),
      selectedValues: ae([]),
      getPath: () => [],
    },
  },
  xI = $(
    {
      activatable: Boolean,
      selectable: Boolean,
      activeStrategy: [String, Function, Object],
      selectStrategy: [String, Function, Object],
      openStrategy: [String, Object],
      opened: null,
      activated: null,
      selected: null,
      mandatory: Boolean,
    },
    'nested'
  ),
  _I = (e) => {
    let t = !1
    const n = oe(new Map()),
      a = oe(new Map()),
      l = oe(new Set()),
      o = we(
        e,
        'opened',
        e.opened,
        (h) => new Set(Array.isArray(h) ? h.map((m) => _e(m)) : h),
        (h) => [...h.values()]
      ),
      i = C(() => {
        if (typeof e.activeStrategy == 'object') return e.activeStrategy
        if (typeof e.activeStrategy == 'function') return e.activeStrategy(e.mandatory)
        switch (e.activeStrategy) {
          case 'leaf':
            return yI(e.mandatory)
          case 'single-leaf':
            return bI(e.mandatory)
          case 'independent':
            return md(e.mandatory)
          case 'single-independent':
          default:
            return cb(e.mandatory)
        }
      }),
      r = C(() => {
        if (typeof e.selectStrategy == 'object') return e.selectStrategy
        if (typeof e.selectStrategy == 'function') return e.selectStrategy(e.mandatory)
        switch (e.selectStrategy) {
          case 'single-leaf':
            return kI(e.mandatory)
          case 'leaf':
            return wI(e.mandatory)
          case 'independent':
            return hd(e.mandatory)
          case 'single-independent':
            return fb(e.mandatory)
          case 'trunk':
            return CI(e.mandatory)
          case 'classic':
          default:
            return vb(e.mandatory)
        }
      }),
      s = C(() => {
        if (typeof e.openStrategy == 'object') return e.openStrategy
        switch (e.openStrategy) {
          case 'list':
            return SI
          case 'single':
            return pI
          case 'multiple':
          default:
            return db
        }
      }),
      c = we(
        e,
        'activated',
        e.activated,
        (h) => i.value.in(h, n.value, a.value),
        (h) => i.value.out(h, n.value, a.value)
      ),
      u = we(
        e,
        'selected',
        e.selected,
        (h) => r.value.in(h, n.value, a.value, l.value),
        (h) => r.value.out(h, n.value, a.value)
      )
    dt(() => {
      t = !0
    })
    function d(h) {
      const m = []
      let b = _e(h)
      for (; b !== void 0; ) (m.unshift(b), (b = a.value.get(b)))
      return m
    }
    const f = rt('nested'),
      v = new Set(),
      g = {
        id: oe(),
        root: {
          opened: o,
          activatable: B(() => e.activatable),
          selectable: B(() => e.selectable),
          activated: c,
          selected: u,
          selectedValues: C(() => {
            const h = []
            for (const [m, b] of u.value.entries()) b === 'on' && h.push(m)
            return h
          }),
          register: (h, m, b, y) => {
            if (v.has(h)) {
              ;(d(h).map(String).join(' -> '), d(m).concat(h).map(String).join(' -> '))
              return
            } else v.add(h)
            ;(m && h !== m && a.value.set(h, m),
              b && l.value.add(h),
              y && n.value.set(h, []),
              m != null && n.value.set(m, [...(n.value.get(m) || []), h]))
          },
          unregister: (h) => {
            if (t) return
            ;(v.delete(h), n.value.delete(h), l.value.delete(h))
            const m = a.value.get(h)
            if (m) {
              const b = n.value.get(m) ?? []
              n.value.set(
                m,
                b.filter((y) => y !== h)
              )
            }
            a.value.delete(h)
          },
          open: (h, m, b) => {
            f.emit('click:open', { id: h, value: m, path: d(h), event: b })
            const y = s.value.open({
              id: h,
              value: m,
              opened: new Set(o.value),
              children: n.value,
              parents: a.value,
              event: b,
            })
            y && (o.value = y)
          },
          openOnSelect: (h, m, b) => {
            const y = s.value.select({
              id: h,
              value: m,
              selected: new Map(u.value),
              opened: new Set(o.value),
              children: n.value,
              parents: a.value,
              event: b,
            })
            y && (o.value = y)
          },
          select: (h, m, b) => {
            f.emit('click:select', { id: h, value: m, path: d(h), event: b })
            const y = r.value.select({
              id: h,
              value: m,
              selected: new Map(u.value),
              children: n.value,
              parents: a.value,
              disabled: l.value,
              event: b,
            })
            ;(y && (u.value = y), g.root.openOnSelect(h, m, b))
          },
          activate: (h, m, b) => {
            if (!e.activatable) return g.root.select(h, !0, b)
            f.emit('click:activate', { id: h, value: m, path: d(h), event: b })
            const y = i.value.activate({
              id: h,
              value: m,
              activated: new Set(c.value),
              children: n.value,
              parents: a.value,
              event: b,
            })
            if (y.size !== c.value.size) c.value = y
            else {
              for (const p of y)
                if (!c.value.has(p)) {
                  c.value = y
                  return
                }
              for (const p of c.value)
                if (!y.has(p)) {
                  c.value = y
                  return
                }
            }
          },
          children: n,
          parents: a,
          disabled: l,
          getPath: d,
        },
      }
    return (Fe(Wo, g), g.root)
  },
  hb = (e, t, n) => {
    const a = Ve(Wo, mb),
      l = Symbol('nested item'),
      o = C(() => {
        const r = _e(Ft(e))
        return r !== void 0 ? r : l
      }),
      i = {
        ...a,
        id: o,
        open: (r, s) => a.root.open(o.value, r, s),
        openOnSelect: (r, s) => a.root.openOnSelect(o.value, r, s),
        isOpen: C(() => a.root.opened.value.has(o.value)),
        parent: C(() => a.root.parents.value.get(o.value)),
        activate: (r, s) => a.root.activate(o.value, r, s),
        isActivated: C(() => a.root.activated.value.has(o.value)),
        select: (r, s) => a.root.select(o.value, r, s),
        isSelected: C(() => a.root.selected.value.get(o.value) === 'on'),
        isIndeterminate: C(() => a.root.selected.value.get(o.value) === 'indeterminate'),
        isLeaf: C(() => !a.root.children.value.get(o.value)),
        isGroupActivator: a.isGroupActivator,
      }
    return (
      Xl(() => {
        a.isGroupActivator || a.root.register(o.value, a.id.value, Ft(t), n)
      }),
      dt(() => {
        a.isGroupActivator || a.root.unregister(o.value)
      }),
      n && Fe(Wo, i),
      i
    )
  },
  PI = () => {
    const e = Ve(Wo, mb)
    Fe(Wo, { ...e, isGroupActivator: !0 })
  },
  VI = un({
    name: 'VListGroupActivator',
    setup(e, t) {
      let { slots: n } = t
      return (PI(), () => n.default?.())
    },
  }),
  gb = $(
    {
      activeColor: String,
      baseColor: String,
      color: String,
      collapseIcon: { type: Se, default: '$collapse' },
      disabled: Boolean,
      expandIcon: { type: Se, default: '$expand' },
      rawId: [String, Number],
      prependIcon: Se,
      appendIcon: Se,
      fluid: Boolean,
      subgroup: Boolean,
      title: String,
      value: null,
      ...be(),
      ...Ie(),
    },
    'VListGroup'
  ),
  Uo = J()({
    name: 'VListGroup',
    props: gb(),
    setup(e, t) {
      let { slots: n } = t
      const {
          isOpen: a,
          open: l,
          id: o,
        } = hb(
          () => e.value,
          () => e.disabled,
          !0
        ),
        i = C(() => `v-list-group--id-${String(e.rawId ?? o.value)}`),
        r = ub(),
        { isBooted: s } = sl()
      function c(v) {
        ;['INPUT', 'TEXTAREA'].includes(v.target?.tagName) || l(!a.value, v)
      }
      const u = C(() => ({ onClick: c, class: 'v-list-group__header', id: i.value })),
        d = C(() => (a.value ? e.collapseIcon : e.expandIcon)),
        f = C(() => ({
          VListItem: {
            activeColor: e.activeColor,
            baseColor: e.baseColor,
            color: e.color,
            prependIcon: e.prependIcon || (e.subgroup && d.value),
            appendIcon: e.appendIcon || (!e.subgroup && d.value),
            title: e.title,
            value: e.value,
          },
        }))
      return (
        ne(() =>
          w(
            e.tag,
            {
              class: ee([
                'v-list-group',
                {
                  'v-list-group--prepend': r?.hasPrepend.value,
                  'v-list-group--fluid': e.fluid,
                  'v-list-group--subgroup': e.subgroup,
                  'v-list-group--open': a.value,
                },
                e.class,
              ]),
              style: ce(e.style),
            },
            {
              default: () => [
                n.activator &&
                  w(
                    Ae,
                    { defaults: f.value },
                    {
                      default: () => [
                        w(VI, null, {
                          default: () => [n.activator({ props: u.value, isOpen: a.value })],
                        }),
                      ],
                    }
                  ),
                w(
                  $t,
                  { transition: { component: Fr }, disabled: !s.value },
                  {
                    default: () => [
                      tt(
                        x(
                          'div',
                          {
                            class: 'v-list-group__items',
                            role: 'group',
                            'aria-labelledby': i.value,
                          },
                          [n.default?.()]
                        ),
                        [[Pn, a.value]]
                      ),
                    ],
                  }
                ),
              ],
            }
          )
        ),
        { isOpen: a }
      )
    },
  }),
  II = $({ opacity: [Number, String], ...be(), ...Ie() }, 'VListItemSubtitle'),
  yb = J()({
    name: 'VListItemSubtitle',
    props: II(),
    setup(e, t) {
      let { slots: n } = t
      return (
        ne(() =>
          w(
            e.tag,
            {
              class: ee(['v-list-item-subtitle', e.class]),
              style: ce([{ '--v-list-item-subtitle-opacity': e.opacity }, e.style]),
            },
            n
          )
        ),
        {}
      )
    },
  }),
  bb = da('v-list-item-title'),
  pb = $(
    {
      active: { type: Boolean, default: void 0 },
      activeClass: String,
      activeColor: String,
      appendAvatar: String,
      appendIcon: Se,
      baseColor: String,
      disabled: Boolean,
      lines: [Boolean, String],
      link: { type: Boolean, default: void 0 },
      nav: Boolean,
      prependAvatar: String,
      prependIcon: Se,
      ripple: { type: [Boolean, Object], default: !0 },
      slim: Boolean,
      subtitle: { type: [String, Number, Boolean], default: void 0 },
      title: { type: [String, Number, Boolean], default: void 0 },
      value: null,
      onClick: Pt(),
      onClickOnce: Pt(),
      ...Ut(),
      ...be(),
      ...St(),
      ...ft(),
      ...yt(),
      ...Je(),
      ...ui(),
      ...Ie(),
      ...Be(),
      ...yn({ variant: 'text' }),
    },
    'VListItem'
  ),
  _n = J()({
    name: 'VListItem',
    directives: { vRipple: Nt },
    props: pb(),
    emits: { click: (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: a, emit: l } = t
      const o = si(e, n),
        i = C(() => (e.value === void 0 ? o.href.value : e.value)),
        {
          activate: r,
          isActivated: s,
          select: c,
          isOpen: u,
          isSelected: d,
          isIndeterminate: f,
          isGroupActivator: v,
          root: g,
          parent: h,
          openOnSelect: m,
          id: b,
        } = hb(i, () => e.disabled, !1),
        y = ub(),
        p = C(
          () =>
            e.active !== !1 &&
            (e.active || o.isActive?.value || (g.activatable.value ? s.value : d.value))
        ),
        S = B(() => e.link !== !1 && o.isLink.value),
        k = C(() => !!y && (g.selectable.value || g.activatable.value || e.value != null)),
        _ = C(() => !e.disabled && e.link !== !1 && (e.link || o.isClickable.value || k.value)),
        P = C(() => (y ? (k.value ? 'option' : 'listitem') : void 0)),
        A = C(() => {
          if (k.value) return g.activatable.value ? s.value : g.selectable.value ? d.value : p.value
        }),
        D = B(() => e.rounded || e.nav),
        E = B(() => e.color ?? e.activeColor),
        R = B(() => ({
          color: p.value ? (E.value ?? e.baseColor) : e.baseColor,
          variant: e.variant,
        }))
      ;(ue(
        () => o.isActive?.value,
        (L) => {
          L && V()
        }
      ),
        Xl(() => {
          o.isActive?.value && V()
        }))
      function V() {
        ;(h.value != null && g.open(h.value, !0), m(!0))
      }
      const { themeClasses: M } = $e(e),
        { borderClasses: F } = Jt(e),
        { colorClasses: G, colorStyles: W, variantClasses: te } = ul(R),
        { densityClasses: H } = Ht(e),
        { dimensionStyles: O } = vt(e),
        { elevationClasses: j } = xt(e),
        { roundedClasses: U } = ot(D),
        Y = B(() => (e.lines ? `v-list-item--${e.lines}-line` : void 0)),
        K = B(() =>
          e.ripple !== void 0 && e.ripple && y?.filterable ? { keys: ['Enter'] } : e.ripple
        ),
        se = C(() => ({
          isActive: p.value,
          select: c,
          isOpen: u.value,
          isSelected: d.value,
          isIndeterminate: f.value,
        }))
      function de(L) {
        ;(l('click', L),
          !['INPUT', 'TEXTAREA'].includes(L.target?.tagName) &&
            _.value &&
            (o.navigate?.(L),
            !v &&
              (g.activatable.value
                ? r(!s.value, L)
                : (g.selectable.value || (e.value != null && !S.value)) && c(!d.value, L))))
      }
      function ye(L) {
        const q = L.target
        ;['INPUT', 'TEXTAREA'].includes(q.tagName) ||
          ((L.key === 'Enter' || (L.key === ' ' && !y?.filterable)) &&
            (L.preventDefault(),
            L.stopPropagation(),
            L.target.dispatchEvent(new MouseEvent('click', L))))
      }
      return (
        ne(() => {
          const L = S.value ? 'a' : e.tag,
            q = a.title || e.title != null,
            le = a.subtitle || e.subtitle != null,
            ie = !!(e.appendAvatar || e.appendIcon),
            Ce = !!(ie || a.append),
            pe = !!(e.prependAvatar || e.prependIcon),
            I = !!(pe || a.prepend)
          return (
            y?.updateHasPrepend(I),
            e.activeColor && iy('active-color', ['color', 'base-color']),
            tt(
              w(
                L,
                Z(o.linkProps, {
                  class: [
                    'v-list-item',
                    {
                      'v-list-item--active': p.value,
                      'v-list-item--disabled': e.disabled,
                      'v-list-item--link': _.value,
                      'v-list-item--nav': e.nav,
                      'v-list-item--prepend': !I && y?.hasPrepend.value,
                      'v-list-item--slim': e.slim,
                      [`${e.activeClass}`]: e.activeClass && p.value,
                    },
                    M.value,
                    F.value,
                    G.value,
                    H.value,
                    j.value,
                    Y.value,
                    U.value,
                    te.value,
                    e.class,
                  ],
                  style: [W.value, O.value, e.style],
                  tabindex: _.value ? (y ? -2 : 0) : void 0,
                  'aria-selected': A.value,
                  role: P.value,
                  onClick: de,
                  onKeydown: _.value && !S.value && ye,
                }),
                {
                  default: () => [
                    Ta(_.value || p.value, 'v-list-item'),
                    I &&
                      x('div', { key: 'prepend', class: 'v-list-item__prepend' }, [
                        a.prepend
                          ? w(
                              Ae,
                              {
                                key: 'prepend-defaults',
                                disabled: !pe,
                                defaults: {
                                  VAvatar: { density: e.density, image: e.prependAvatar },
                                  VIcon: { density: e.density, icon: e.prependIcon },
                                  VListItemAction: { start: !0 },
                                },
                              },
                              { default: () => [a.prepend?.(se.value)] }
                            )
                          : x(he, null, [
                              e.prependAvatar &&
                                w(
                                  sn,
                                  {
                                    key: 'prepend-avatar',
                                    density: e.density,
                                    image: e.prependAvatar,
                                  },
                                  null
                                ),
                              e.prependIcon &&
                                w(
                                  Le,
                                  { key: 'prepend-icon', density: e.density, icon: e.prependIcon },
                                  null
                                ),
                            ]),
                        x('div', { class: 'v-list-item__spacer' }, null),
                      ]),
                    x('div', { class: 'v-list-item__content', 'data-no-activator': '' }, [
                      q &&
                        w(
                          bb,
                          { key: 'title' },
                          { default: () => [a.title?.({ title: e.title }) ?? Bn(e.title)] }
                        ),
                      le &&
                        w(
                          yb,
                          { key: 'subtitle' },
                          {
                            default: () => [
                              a.subtitle?.({ subtitle: e.subtitle }) ?? Bn(e.subtitle),
                            ],
                          }
                        ),
                      a.default?.(se.value),
                    ]),
                    Ce &&
                      x('div', { key: 'append', class: 'v-list-item__append' }, [
                        a.append
                          ? w(
                              Ae,
                              {
                                key: 'append-defaults',
                                disabled: !ie,
                                defaults: {
                                  VAvatar: { density: e.density, image: e.appendAvatar },
                                  VIcon: { density: e.density, icon: e.appendIcon },
                                  VListItemAction: { end: !0 },
                                },
                              },
                              { default: () => [a.append?.(se.value)] }
                            )
                          : x(he, null, [
                              e.appendIcon &&
                                w(
                                  Le,
                                  { key: 'append-icon', density: e.density, icon: e.appendIcon },
                                  null
                                ),
                              e.appendAvatar &&
                                w(
                                  sn,
                                  {
                                    key: 'append-avatar',
                                    density: e.density,
                                    image: e.appendAvatar,
                                  },
                                  null
                                ),
                            ]),
                        x('div', { class: 'v-list-item__spacer' }, null),
                      ]),
                  ],
                }
              ),
              [[Nt, _.value && K.value]]
            )
          )
        }),
        {
          activate: r,
          isActivated: s,
          isGroupActivator: v,
          isSelected: d,
          list: y,
          select: c,
          root: g,
          id: b,
          link: o,
        }
      )
    },
  }),
  TI = $(
    { color: String, inset: Boolean, sticky: Boolean, title: String, ...be(), ...Ie() },
    'VListSubheader'
  ),
  ao = J()({
    name: 'VListSubheader',
    props: TI(),
    setup(e, t) {
      let { slots: n } = t
      const { textColorClasses: a, textColorStyles: l } = Vt(() => e.color)
      return (
        ne(() => {
          const o = !!(n.default || e.title)
          return w(
            e.tag,
            {
              class: ee([
                'v-list-subheader',
                { 'v-list-subheader--inset': e.inset, 'v-list-subheader--sticky': e.sticky },
                a.value,
                e.class,
              ]),
              style: ce([{ textColorStyles: l }, e.style]),
            },
            {
              default: () => [
                o && x('div', { class: 'v-list-subheader__text' }, [n.default?.() ?? e.title]),
              ],
            }
          )
        }),
        {}
      )
    },
  }),
  AI = $({ items: Array, returnObject: Boolean }, 'VListChildren'),
  Sb = J()({
    name: 'VListChildren',
    props: AI(),
    setup(e, t) {
      let { slots: n } = t
      return (
        sb(),
        () =>
          n.default?.() ??
          e.items?.map((a) => {
            let { children: l, props: o, type: i, raw: r } = a
            if (i === 'divider') return n.divider?.({ props: o }) ?? w(rn, o, null)
            if (i === 'subheader') return n.subheader?.({ props: o }) ?? w(ao, o, null)
            const s = {
                subtitle: n.subtitle ? (u) => n.subtitle?.({ ...u, item: r }) : void 0,
                prepend: n.prepend ? (u) => n.prepend?.({ ...u, item: r }) : void 0,
                append: n.append ? (u) => n.append?.({ ...u, item: r }) : void 0,
                title: n.title ? (u) => n.title?.({ ...u, item: r }) : void 0,
              },
              c = Uo.filterProps(o)
            return l
              ? w(Uo, Z(c, { value: e.returnObject ? r : o?.value, rawId: o?.value }), {
                  activator: (u) => {
                    let { props: d } = u
                    const f = Z(o, d, { value: e.returnObject ? r : o.value })
                    return n.header ? n.header({ props: f }) : w(_n, f, s)
                  },
                  default: () => w(Sb, { items: l, returnObject: e.returnObject }, n),
                })
              : n.item
                ? n.item({ props: o })
                : w(_n, Z(o, { value: e.returnObject ? r : o.value }), s)
          })
      )
    },
  }),
  wb = $(
    {
      items: { type: Array, default: () => [] },
      itemTitle: { type: [String, Array, Function], default: 'title' },
      itemValue: { type: [String, Array, Function], default: 'value' },
      itemChildren: { type: [Boolean, String, Array, Function], default: 'children' },
      itemProps: { type: [Boolean, String, Array, Function], default: 'props' },
      itemType: { type: [Boolean, String, Array, Function], default: 'type' },
      returnObject: Boolean,
      valueComparator: Function,
    },
    'list-items'
  ),
  EI = new Set(['item', 'divider', 'subheader'])
function Sn(e, t) {
  const n = st(t, e.itemTitle, t),
    a = st(t, e.itemValue, n),
    l = st(t, e.itemChildren),
    o =
      e.itemProps === !0
        ? typeof t == 'object' && t != null && !Array.isArray(t)
          ? 'children' in t
            ? je(t, ['children'])
            : t
          : void 0
        : st(t, e.itemProps)
  let i = st(t, e.itemType, 'item')
  EI.has(i) || (i = 'item')
  const r = { title: n, value: a, ...o }
  return {
    type: i,
    title: String(r.title ?? ''),
    value: r.value,
    props: r,
    children: i === 'item' && Array.isArray(l) ? kb(e, l) : void 0,
    raw: t,
  }
}
Sn.neededProps = ['itemTitle', 'itemValue', 'itemChildren', 'itemProps', 'itemType']
function kb(e, t) {
  const n = Zt(e, Sn.neededProps),
    a = []
  for (const l of t) a.push(Sn(n, l))
  return a
}
function gd(e) {
  const t = C(() => kb(e, e.items)),
    n = C(() => t.value.some((r) => r.value === null)),
    a = oe(new Map()),
    l = oe([])
  qe(() => {
    const r = t.value,
      s = new Map(),
      c = []
    for (let u = 0; u < r.length; u++) {
      const d = r[u]
      if (ku(d.value) || d.value === null) {
        let f = s.get(d.value)
        ;(f || ((f = []), s.set(d.value, f)), f.push(d))
      } else c.push(d)
    }
    ;((a.value = s), (l.value = c))
  })
  function o(r) {
    const s = a.value,
      c = t.value,
      u = l.value,
      d = n.value,
      f = e.returnObject,
      v = !!e.valueComparator,
      g = e.valueComparator || kt,
      h = Zt(e, Sn.neededProps),
      m = []
    e: for (const b of r) {
      if (!d && b === null) continue
      if (f && typeof b == 'string') {
        m.push(Sn(h, b))
        continue
      }
      const y = s.get(b)
      if (v || !y) {
        for (const p of v ? c : u)
          if (g(b, p.value)) {
            m.push(p)
            continue e
          }
        m.push(Sn(h, b))
        continue
      }
      m.push(...y)
    }
    return m
  }
  function i(r) {
    return e.returnObject
      ? r.map((s) => {
          let { raw: c } = s
          return c
        })
      : r.map((s) => {
          let { value: c } = s
          return c
        })
  }
  return { items: t, transformIn: o, transformOut: i }
}
const DI = new Set(['item', 'divider', 'subheader'])
function RI(e, t) {
  const n = ku(t) ? t : st(t, e.itemTitle),
    a = ku(t) ? t : st(t, e.itemValue, void 0),
    l = st(t, e.itemChildren),
    o = e.itemProps === !0 ? je(t, ['children']) : st(t, e.itemProps)
  let i = st(t, e.itemType, 'item')
  DI.has(i) || (i = 'item')
  const r = { title: n, value: a, ...o }
  return {
    type: i,
    title: r.title,
    value: r.value,
    props: r,
    children: i === 'item' && l ? Cb(e, l) : void 0,
    raw: t,
  }
}
function Cb(e, t) {
  const n = []
  for (const a of t) n.push(RI(e, a))
  return n
}
function xb(e) {
  return { items: C(() => Cb(e, e.items)) }
}
const _b = $(
    {
      baseColor: String,
      activeColor: String,
      activeClass: String,
      bgColor: String,
      disabled: Boolean,
      filterable: Boolean,
      expandIcon: Se,
      collapseIcon: Se,
      lines: { type: [Boolean, String], default: 'one' },
      slim: Boolean,
      nav: Boolean,
      'onClick:open': Pt(),
      'onClick:select': Pt(),
      'onUpdate:opened': Pt(),
      ...xI({ selectStrategy: 'single-leaf', openStrategy: 'list' }),
      ...Ut(),
      ...be(),
      ...St(),
      ...ft(),
      ...yt(),
      ...wb(),
      ...Je(),
      ...Ie(),
      ...Be(),
      ...yn({ variant: 'text' }),
    },
    'VList'
  ),
  Ul = J()({
    name: 'VList',
    props: _b(),
    emits: {
      'update:selected': (e) => !0,
      'update:activated': (e) => !0,
      'update:opened': (e) => !0,
      'click:open': (e) => !0,
      'click:activate': (e) => !0,
      'click:select': (e) => !0,
    },
    setup(e, t) {
      let { slots: n } = t
      const { items: a } = xb(e),
        { themeClasses: l } = $e(e),
        { backgroundColorClasses: o, backgroundColorStyles: i } = He(() => e.bgColor),
        { borderClasses: r } = Jt(e),
        { densityClasses: s } = Ht(e),
        { dimensionStyles: c } = vt(e),
        { elevationClasses: u } = xt(e),
        { roundedClasses: d } = ot(e),
        { children: f, open: v, parents: g, select: h, getPath: m } = _I(e),
        b = B(() => (e.lines ? `v-list--${e.lines}-line` : void 0)),
        y = B(() => e.activeColor),
        p = B(() => e.baseColor),
        S = B(() => e.color),
        k = B(() => e.selectable || e.activatable)
      ;(sb({ filterable: e.filterable }),
        lt({
          VListGroup: {
            activeColor: y,
            baseColor: p,
            color: S,
            expandIcon: B(() => e.expandIcon),
            collapseIcon: B(() => e.collapseIcon),
          },
          VListItem: {
            activeClass: B(() => e.activeClass),
            activeColor: y,
            baseColor: p,
            color: S,
            density: B(() => e.density),
            disabled: B(() => e.disabled),
            lines: B(() => e.lines),
            nav: B(() => e.nav),
            slim: B(() => e.slim),
            variant: B(() => e.variant),
          },
        }))
      const _ = oe(!1),
        P = ae()
      function A(F) {
        _.value = !0
      }
      function D(F) {
        _.value = !1
      }
      function E(F) {
        !_.value && !(F.relatedTarget && P.value?.contains(F.relatedTarget)) && M()
      }
      function R(F) {
        const G = F.target
        if (
          !(
            !P.value ||
            (G.tagName === 'INPUT' && ['Home', 'End'].includes(F.key)) ||
            G.tagName === 'TEXTAREA'
          )
        ) {
          if (F.key === 'ArrowDown') M('next')
          else if (F.key === 'ArrowUp') M('prev')
          else if (F.key === 'Home') M('first')
          else if (F.key === 'End') M('last')
          else return
          F.preventDefault()
        }
      }
      function V(F) {
        _.value = !0
      }
      function M(F) {
        if (P.value) return Ua(P.value, F)
      }
      return (
        ne(() =>
          w(
            e.tag,
            {
              ref: P,
              class: ee([
                'v-list',
                { 'v-list--disabled': e.disabled, 'v-list--nav': e.nav, 'v-list--slim': e.slim },
                l.value,
                o.value,
                r.value,
                s.value,
                u.value,
                b.value,
                d.value,
                e.class,
              ]),
              style: ce([i.value, c.value, e.style]),
              tabindex: e.disabled ? -1 : 0,
              role: k.value ? 'listbox' : 'list',
              'aria-activedescendant': void 0,
              onFocusin: A,
              onFocusout: D,
              onFocus: E,
              onKeydown: R,
              onMousedown: V,
            },
            { default: () => [w(Sb, { items: a.value, returnObject: e.returnObject }, n)] }
          )
        ),
        { open: v, select: h, focus: M, children: f, parents: g, getPath: m }
      )
    },
  }),
  MI = da('v-list-img'),
  BI = $({ start: Boolean, end: Boolean, ...be(), ...Ie() }, 'VListItemAction'),
  yd = J()({
    name: 'VListItemAction',
    props: BI(),
    setup(e, t) {
      let { slots: n } = t
      return (
        ne(() =>
          w(
            e.tag,
            {
              class: ee([
                'v-list-item-action',
                { 'v-list-item-action--start': e.start, 'v-list-item-action--end': e.end },
                e.class,
              ]),
              style: ce(e.style),
            },
            n
          )
        ),
        {}
      )
    },
  }),
  LI = $({ start: Boolean, end: Boolean, ...be(), ...Ie() }, 'VListItemMedia'),
  OI = J()({
    name: 'VListItemMedia',
    props: LI(),
    setup(e, t) {
      let { slots: n } = t
      return (
        ne(() =>
          w(
            e.tag,
            {
              class: ee([
                'v-list-item-media',
                { 'v-list-item-media--start': e.start, 'v-list-item-media--end': e.end },
                e.class,
              ]),
              style: ce(e.style),
            },
            n
          )
        ),
        {}
      )
    },
  })
function Ls(e, t) {
  return { x: e.x + t.x, y: e.y + t.y }
}
function $I(e, t) {
  return { x: e.x - t.x, y: e.y - t.y }
}
function cm(e, t) {
  if (e.side === 'top' || e.side === 'bottom') {
    const { side: n, align: a } = e,
      l = a === 'left' ? 0 : a === 'center' ? t.width / 2 : a === 'right' ? t.width : a,
      o = n === 'top' ? 0 : n === 'bottom' ? t.height : n
    return Ls({ x: l, y: o }, t)
  } else if (e.side === 'left' || e.side === 'right') {
    const { side: n, align: a } = e,
      l = n === 'left' ? 0 : n === 'right' ? t.width : n,
      o = a === 'top' ? 0 : a === 'center' ? t.height / 2 : a === 'bottom' ? t.height : a
    return Ls({ x: l, y: o }, t)
  }
  return Ls({ x: t.width / 2, y: t.height / 2 }, t)
}
const Pb = { static: HI, connected: zI },
  FI = $(
    {
      locationStrategy: {
        type: [String, Function],
        default: 'static',
        validator: (e) => typeof e == 'function' || e in Pb,
      },
      location: { type: String, default: 'bottom' },
      origin: { type: String, default: 'auto' },
      offset: [Number, String, Array],
      stickToTarget: Boolean,
    },
    'VOverlay-location-strategies'
  )
function NI(e, t) {
  const n = ae({}),
    a = ae()
  Ne &&
    Et(
      () => !!(t.isActive.value && e.locationStrategy),
      (r) => {
        ;(ue(() => e.locationStrategy, r),
          bt(() => {
            ;(window.removeEventListener('resize', l),
              visualViewport?.removeEventListener('resize', o),
              visualViewport?.removeEventListener('scroll', i),
              (a.value = void 0))
          }),
          window.addEventListener('resize', l, { passive: !0 }),
          visualViewport?.addEventListener('resize', o, { passive: !0 }),
          visualViewport?.addEventListener('scroll', i, { passive: !0 }),
          typeof e.locationStrategy == 'function'
            ? (a.value = e.locationStrategy(t, e, n)?.updateLocation)
            : (a.value = Pb[e.locationStrategy](t, e, n)?.updateLocation))
      }
    )
  function l(r) {
    a.value?.(r)
  }
  function o(r) {
    a.value?.(r)
  }
  function i(r) {
    a.value?.(r)
  }
  return { contentStyles: n, updateLocation: a }
}
function HI() {}
function jI(e, t) {
  const n = Gc(e)
  return (
    t ? (n.x += parseFloat(e.style.right || 0)) : (n.x -= parseFloat(e.style.left || 0)),
    (n.y -= parseFloat(e.style.top || 0)),
    n
  )
}
function zI(e, t, n) {
  ;(Array.isArray(e.target.value) || H1(e.target.value)) &&
    Object.assign(n.value, { position: 'fixed', top: 0, [e.isRtl.value ? 'right' : 'left']: 0 })
  const { preferredAnchor: l, preferredOrigin: o } = Kc(() => {
      const b = Cu(t.location, e.isRtl.value),
        y = t.origin === 'overlap' ? b : t.origin === 'auto' ? Is(b) : Cu(t.origin, e.isRtl.value)
      return b.side === y.side && b.align === Ts(y).align
        ? { preferredAnchor: Iv(b), preferredOrigin: Iv(y) }
        : { preferredAnchor: b, preferredOrigin: y }
    }),
    [i, r, s, c] = ['minWidth', 'minHeight', 'maxWidth', 'maxHeight'].map((b) =>
      C(() => {
        const y = parseFloat(t[b])
        return isNaN(y) ? 1 / 0 : y
      })
    ),
    u = C(() => {
      if (Array.isArray(t.offset)) return t.offset
      if (typeof t.offset == 'string') {
        const b = t.offset.split(' ').map(parseFloat)
        return (b.length < 2 && b.push(0), b)
      }
      return typeof t.offset == 'number' ? [t.offset, 0] : [0, 0]
    })
  let d = !1,
    f = -1
  const v = new ey(4),
    g = new ResizeObserver(() => {
      if (!d) return
      if (
        (requestAnimationFrame((y) => {
          ;(y !== f && v.clear(),
            requestAnimationFrame((p) => {
              f = p
            }))
        }),
        v.isFull)
      ) {
        const y = v.values()
        if (kt(y.at(-1), y.at(-3)) && !kt(y.at(-1), y.at(-2))) return
      }
      const b = m()
      b && v.push(b.flipped)
    })
  let h = new Mn({ x: 0, y: 0, width: 0, height: 0 })
  ;(ue(
    e.target,
    (b, y) => {
      ;(y && !Array.isArray(y) && g.unobserve(y),
        Array.isArray(b) ? kt(b, y) || m() : b && g.observe(b))
    },
    { immediate: !0 }
  ),
    ue(
      e.contentEl,
      (b, y) => {
        ;(y && g.unobserve(y), b && g.observe(b))
      },
      { immediate: !0 }
    ),
    bt(() => {
      g.disconnect()
    }))
  function m() {
    if (((d = !1), requestAnimationFrame(() => (d = !0)), !e.target.value || !e.contentEl.value))
      return
    ;(Array.isArray(e.target.value) ||
      e.target.value.offsetParent ||
      e.target.value.getClientRects().length) &&
      (h = oy(e.target.value))
    const b = jI(e.contentEl.value, e.isRtl.value),
      y = dr(e.contentEl.value),
      p = 12
    y.length ||
      (y.push(document.documentElement),
      (e.contentEl.value.style.top && e.contentEl.value.style.left) ||
        ((b.x -= parseFloat(
          document.documentElement.style.getPropertyValue('--v-body-scroll-x') || 0
        )),
        (b.y -= parseFloat(
          document.documentElement.style.getPropertyValue('--v-body-scroll-y') || 0
        ))))
    const S = y.reduce(
      (M, F) => {
        const G = c1(F)
        return M
          ? new Mn({
              x: Math.max(M.left, G.left),
              y: Math.max(M.top, G.top),
              width: Math.min(M.right, G.right) - Math.max(M.left, G.left),
              height: Math.min(M.bottom, G.bottom) - Math.max(M.top, G.top),
            })
          : G
      },
      void 0
    )
    ;((S.x += p), (S.y += p), (S.width -= p * 2), (S.height -= p * 2))
    let k = { anchor: l.value, origin: o.value }
    function _(M) {
      const F = new Mn(b),
        G = cm(M.anchor, h),
        W = cm(M.origin, F)
      let { x: te, y: H } = $I(G, W)
      switch (M.anchor.side) {
        case 'top':
          H -= u.value[0]
          break
        case 'bottom':
          H += u.value[0]
          break
        case 'left':
          te -= u.value[0]
          break
        case 'right':
          te += u.value[0]
          break
      }
      switch (M.anchor.align) {
        case 'top':
          H -= u.value[1]
          break
        case 'bottom':
          H += u.value[1]
          break
        case 'left':
          te -= u.value[1]
          break
        case 'right':
          te += u.value[1]
          break
      }
      return (
        (F.x += te),
        (F.y += H),
        (F.width = Math.min(F.width, s.value)),
        (F.height = Math.min(F.height, c.value)),
        { overflows: Av(F, S), x: te, y: H }
      )
    }
    let P = 0,
      A = 0
    const D = { x: 0, y: 0 },
      E = { x: !1, y: !1 }
    let R = -1
    for (; !(R++ > 10); ) {
      const { x: M, y: F, overflows: G } = _(k)
      ;((P += M), (A += F), (b.x += M), (b.y += F))
      {
        const W = Tv(k.anchor),
          te = G.x.before || G.x.after,
          H = G.y.before || G.y.after
        let O = !1
        if (
          (['x', 'y'].forEach((j) => {
            if ((j === 'x' && te && !E.x) || (j === 'y' && H && !E.y)) {
              const U = { anchor: { ...k.anchor }, origin: { ...k.origin } },
                Y = j === 'x' ? (W === 'y' ? Ts : Is) : W === 'y' ? Is : Ts
              ;((U.anchor = Y(U.anchor)), (U.origin = Y(U.origin)))
              const { overflows: K } = _(U)
              ;((K[j].before <= G[j].before && K[j].after <= G[j].after) ||
                K[j].before + K[j].after < (G[j].before + G[j].after) / 2) &&
                ((k = U), (O = E[j] = !0))
            }
          }),
          O)
        )
          continue
      }
      ;(G.x.before && (t.stickToTarget || (P += G.x.before), (b.x += G.x.before)),
        G.x.after && (t.stickToTarget || (P -= G.x.after), (b.x -= G.x.after)),
        G.y.before && (t.stickToTarget || (A += G.y.before), (b.y += G.y.before)),
        G.y.after && (t.stickToTarget || (A -= G.y.after), (b.y -= G.y.after)))
      {
        const W = Av(b, S)
        ;((D.x = S.width - W.x.before - W.x.after),
          (D.y = S.height - W.y.before - W.y.after),
          t.stickToTarget || (P += W.x.before),
          (b.x += W.x.before),
          t.stickToTarget || (A += W.y.before),
          (b.y += W.y.before))
      }
      break
    }
    const V = Tv(k.anchor)
    return (
      Object.assign(n.value, {
        '--v-overlay-anchor-origin': `${k.anchor.side} ${k.anchor.align}`,
        transformOrigin: `${k.origin.side} ${k.origin.align}`,
        top: fe(Os(A)),
        left: e.isRtl.value ? void 0 : fe(Os(P)),
        right: e.isRtl.value ? fe(Os(-P)) : void 0,
        minWidth: fe(V === 'y' ? Math.min(i.value, h.width) : i.value),
        maxWidth: fe(dm(Ge(D.x, i.value === 1 / 0 ? 0 : i.value, s.value))),
        maxHeight: fe(dm(Ge(D.y, r.value === 1 / 0 ? 0 : r.value, c.value))),
      }),
      { available: D, contentBox: b, flipped: E }
    )
  }
  return (
    ue(
      () => [l.value, o.value, t.offset, t.minWidth, t.minHeight, t.maxWidth, t.maxHeight],
      () => m()
    ),
    Re(() => {
      const b = m()
      if (!b) return
      const { available: y, contentBox: p } = b
      p.height > y.y &&
        requestAnimationFrame(() => {
          ;(m(),
            requestAnimationFrame(() => {
              m()
            }))
        })
    }),
    { updateLocation: m }
  )
}
function Os(e) {
  return Math.round(e * devicePixelRatio) / devicePixelRatio
}
function dm(e) {
  return Math.ceil(e * devicePixelRatio) / devicePixelRatio
}
let Ou = !0
const gr = []
function WI(e) {
  !Ou || gr.length ? (gr.push(e), $u()) : ((Ou = !1), e(), $u())
}
let fm = -1
function $u() {
  ;(cancelAnimationFrame(fm),
    (fm = requestAnimationFrame(() => {
      const e = gr.shift()
      ;(e && e(), gr.length ? $u() : (Ou = !0))
    })))
}
const Vb = { none: null, close: GI, block: YI, reposition: qI },
  UI = $(
    {
      scrollStrategy: {
        type: [String, Function],
        default: 'block',
        validator: (e) => typeof e == 'function' || e in Vb,
      },
    },
    'VOverlay-scroll-strategies'
  )
function KI(e, t) {
  if (!Ne) return
  let n
  ;(qe(async () => {
    ;(n?.stop(),
      t.isActive.value &&
        e.scrollStrategy &&
        ((n = Ya()),
        await new Promise((a) => setTimeout(a)),
        n.active &&
          n.run(() => {
            typeof e.scrollStrategy == 'function'
              ? e.scrollStrategy(t, e, n)
              : Vb[e.scrollStrategy]?.(t, e, n)
          })))
  }),
    bt(() => {
      n?.stop()
    }))
}
function GI(e) {
  function t(n) {
    e.isActive.value = !1
  }
  Ib(bd(e.target.value, e.contentEl.value), t)
}
function YI(e, t) {
  const n = e.root.value?.offsetParent,
    a = bd(e.target.value, e.contentEl.value),
    l = [
      ...new Set([
        ...dr(a, t.contained ? n : void 0),
        ...dr(e.contentEl.value, t.contained ? n : void 0),
      ]),
    ].filter((r) => !r.classList.contains('v-overlay-scroll-blocked')),
    o = window.innerWidth - document.documentElement.offsetWidth,
    i = ((r) => Jc(r) && r)(n || document.documentElement)
  ;(i && e.root.value.classList.add('v-overlay--scroll-blocked'),
    l.forEach((r, s) => {
      ;(r.style.setProperty('--v-body-scroll-x', fe(-r.scrollLeft)),
        r.style.setProperty('--v-body-scroll-y', fe(-r.scrollTop)),
        r !== document.documentElement && r.style.setProperty('--v-scrollbar-offset', fe(o)),
        r.classList.add('v-overlay-scroll-blocked'))
    }),
    bt(() => {
      ;(l.forEach((r, s) => {
        const c = parseFloat(r.style.getPropertyValue('--v-body-scroll-x')),
          u = parseFloat(r.style.getPropertyValue('--v-body-scroll-y')),
          d = r.style.scrollBehavior
        ;((r.style.scrollBehavior = 'auto'),
          r.style.removeProperty('--v-body-scroll-x'),
          r.style.removeProperty('--v-body-scroll-y'),
          r.style.removeProperty('--v-scrollbar-offset'),
          r.classList.remove('v-overlay-scroll-blocked'),
          (r.scrollLeft = -c),
          (r.scrollTop = -u),
          (r.style.scrollBehavior = d))
      }),
        i && e.root.value.classList.remove('v-overlay--scroll-blocked'))
    }))
}
function qI(e, t, n) {
  let a = !1,
    l = -1,
    o = -1
  function i(r) {
    WI(() => {
      const s = performance.now()
      ;(e.updateLocation.value?.(r), (a = (performance.now() - s) / (1e3 / 60) > 2))
    })
  }
  ;((o = (typeof requestIdleCallback > 'u' ? (r) => r() : requestIdleCallback)(() => {
    n.run(() => {
      Ib(bd(e.target.value, e.contentEl.value), (r) => {
        a
          ? (cancelAnimationFrame(l),
            (l = requestAnimationFrame(() => {
              l = requestAnimationFrame(() => {
                i(r)
              })
            })))
          : i(r)
      })
    })
  })),
    bt(() => {
      ;(typeof cancelIdleCallback < 'u' && cancelIdleCallback(o), cancelAnimationFrame(l))
    }))
}
function bd(e, t) {
  return Array.isArray(e) ? document.elementsFromPoint(...e).find((n) => !t?.contains(n)) : (e ?? t)
}
function Ib(e, t) {
  const n = [document, ...dr(e)]
  ;(n.forEach((a) => {
    a.addEventListener('scroll', t, { passive: !0 })
  }),
    bt(() => {
      n.forEach((a) => {
        a.removeEventListener('scroll', t)
      })
    }))
}
const Fu = Symbol.for('vuetify:v-menu'),
  pd = $({ closeDelay: [Number, String], openDelay: [Number, String] }, 'delay')
function Sd(e, t) {
  let n = () => {}
  function a(i) {
    n?.()
    const r = Number(i ? e.openDelay : e.closeDelay)
    return new Promise((s) => {
      n = l1(r, () => {
        ;(t?.(i), s(i))
      })
    })
  }
  function l() {
    return a(!0)
  }
  function o() {
    return a(!1)
  }
  return { clearDelay: n, runOpenDelay: l, runCloseDelay: o }
}
const XI = $(
  {
    target: [String, Object],
    activator: [String, Object],
    activatorProps: { type: Object, default: () => ({}) },
    openOnClick: { type: Boolean, default: void 0 },
    openOnHover: Boolean,
    openOnFocus: { type: Boolean, default: void 0 },
    closeOnContentClick: Boolean,
    ...pd(),
  },
  'VOverlay-activator'
)
function ZI(e, t) {
  let { isActive: n, isTop: a, contentEl: l } = t
  const o = rt('useActivator'),
    i = ae()
  let r = !1,
    s = !1,
    c = !0
  const u = C(() => e.openOnFocus || (e.openOnFocus == null && e.openOnHover)),
    d = C(() => e.openOnClick || (e.openOnClick == null && !e.openOnHover && !u.value)),
    { runOpenDelay: f, runCloseDelay: v } = Sd(e, (A) => {
      A === ((e.openOnHover && r) || (u.value && s)) &&
        !(e.openOnHover && n.value && !a.value) &&
        (n.value !== A && (c = !0), (n.value = A))
    }),
    g = ae(),
    h = {
      onClick: (A) => {
        ;(A.stopPropagation(),
          (i.value = A.currentTarget || A.target),
          n.value || (g.value = [A.clientX, A.clientY]),
          (n.value = !n.value))
      },
      onMouseenter: (A) => {
        A.sourceCapabilities?.firesTouchEvents ||
          ((r = !0), (i.value = A.currentTarget || A.target), f())
      },
      onMouseleave: (A) => {
        ;((r = !1), v())
      },
      onFocus: (A) => {
        Hl(A.target, ':focus-visible') !== !1 &&
          ((s = !0), A.stopPropagation(), (i.value = A.currentTarget || A.target), f())
      },
      onBlur: (A) => {
        ;((s = !1), A.stopPropagation(), v())
      },
    },
    m = C(() => {
      const A = {}
      return (
        d.value && (A.onClick = h.onClick),
        e.openOnHover && ((A.onMouseenter = h.onMouseenter), (A.onMouseleave = h.onMouseleave)),
        u.value && ((A.onFocus = h.onFocus), (A.onBlur = h.onBlur)),
        A
      )
    }),
    b = C(() => {
      const A = {}
      if (
        (e.openOnHover &&
          ((A.onMouseenter = () => {
            ;((r = !0), f())
          }),
          (A.onMouseleave = () => {
            ;((r = !1), v())
          })),
        u.value &&
          ((A.onFocusin = () => {
            ;((s = !0), f())
          }),
          (A.onFocusout = () => {
            ;((s = !1), v())
          })),
        e.closeOnContentClick)
      ) {
        const D = Ve(Fu, null)
        A.onClick = () => {
          ;((n.value = !1), D?.closeParents())
        }
      }
      return A
    }),
    y = C(() => {
      const A = {}
      return (
        e.openOnHover &&
          ((A.onMouseenter = () => {
            c && ((r = !0), (c = !1), f())
          }),
          (A.onMouseleave = () => {
            ;((r = !1), v())
          })),
        A
      )
    })
  ;(ue(a, (A) => {
    A &&
      ((e.openOnHover && !r && (!u.value || !s)) || (u.value && !s && (!e.openOnHover || !r))) &&
      !l.value?.contains(document.activeElement) &&
      (n.value = !1)
  }),
    ue(
      n,
      (A) => {
        A ||
          setTimeout(() => {
            g.value = void 0
          })
      },
      { flush: 'post' }
    ))
  const p = sr()
  qe(() => {
    p.value &&
      Re(() => {
        i.value = p.el
      })
  })
  const S = sr(),
    k = C(() =>
      e.target === 'cursor' && g.value ? g.value : S.value ? S.el : Tb(e.target, o) || i.value
    ),
    _ = C(() => (Array.isArray(k.value) ? void 0 : k.value))
  let P
  return (
    ue(
      () => !!e.activator,
      (A) => {
        A && Ne
          ? ((P = Ya()),
            P.run(() => {
              JI(e, o, { activatorEl: i, activatorEvents: m })
            }))
          : P && P.stop()
      },
      { flush: 'post', immediate: !0 }
    ),
    bt(() => {
      P?.stop()
    }),
    {
      activatorEl: i,
      activatorRef: p,
      target: k,
      targetEl: _,
      targetRef: S,
      activatorEvents: m,
      contentEvents: b,
      scrimEvents: y,
    }
  )
}
function JI(e, t, n) {
  let { activatorEl: a, activatorEvents: l } = n
  ;(ue(
    () => e.activator,
    (s, c) => {
      if (c && s !== c) {
        const u = r(c)
        u && i(u)
      }
      s && Re(() => o())
    },
    { immediate: !0 }
  ),
    ue(
      () => e.activatorProps,
      () => {
        o()
      }
    ),
    bt(() => {
      i()
    }))
  function o() {
    let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : r(),
      c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps
    s && d1(s, Z(l.value, c))
  }
  function i() {
    let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : r(),
      c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps
    s && f1(s, Z(l.value, c))
  }
  function r() {
    let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.activator
    const c = Tb(s, t)
    return ((a.value = c?.nodeType === Node.ELEMENT_NODE ? c : void 0), a.value)
  }
}
function Tb(e, t) {
  if (!e) return
  let n
  if (e === 'parent') {
    let a = t?.proxy?.$el?.parentNode
    for (; a?.hasAttribute('data-no-activator'); ) a = a.parentNode
    n = a
  } else typeof e == 'string' ? (n = document.querySelector(e)) : '$el' in e ? (n = e.$el) : (n = e)
  return n
}
function Ab() {
  if (!Ne) return oe(!1)
  const { ssr: e } = gn()
  if (e) {
    const t = oe(!1)
    return (
      pt(() => {
        t.value = !0
      }),
      t
    )
  } else return oe(!0)
}
const wd = $({ eager: Boolean }, 'lazy')
function kd(e, t) {
  const n = oe(!1),
    a = B(() => n.value || e.eager || t.value)
  ue(t, () => (n.value = !0))
  function l() {
    e.eager || (n.value = !1)
  }
  return { isBooted: n, hasContent: a, onAfterLeave: l }
}
function ml() {
  const t = rt('useScopeId').vnode.scopeId
  return { scopeId: t ? { [t]: '' } : void 0 }
}
const vm = Symbol.for('vuetify:stack'),
  vo = it([])
function QI(e, t, n) {
  const a = rt('useStack'),
    l = !n,
    o = Ve(vm, void 0),
    i = it({ activeChildren: new Set() })
  Fe(vm, i)
  const r = oe(Number(Ft(t)))
  Et(e, () => {
    const u = vo.at(-1)?.[1]
    ;((r.value = u ? u + 10 : Number(Ft(t))),
      l && vo.push([a.uid, r.value]),
      o?.activeChildren.add(a.uid),
      bt(() => {
        if (l) {
          const d = _e(vo).findIndex((f) => f[0] === a.uid)
          vo.splice(d, 1)
        }
        o?.activeChildren.delete(a.uid)
      }))
  })
  const s = oe(!0)
  l &&
    qe(() => {
      const u = vo.at(-1)?.[0] === a.uid
      setTimeout(() => (s.value = u))
    })
  const c = B(() => !i.activeChildren.size)
  return { globalTop: qa(s), localTop: c, stackStyles: B(() => ({ zIndex: r.value })) }
}
function eT(e) {
  return {
    teleportTarget: C(() => {
      const n = e()
      if (n === !0 || !Ne) return
      const a = n === !1 ? document.body : typeof n == 'string' ? document.querySelector(n) : n
      if (a == null) return
      let l = [...a.children].find((o) => o.matches('.v-overlay-container'))
      return (
        l ||
          ((l = document.createElement('div')),
          (l.className = 'v-overlay-container'),
          a.appendChild(l)),
        l
      )
    }),
  }
}
function tT() {
  return !0
}
function Eb(e, t, n) {
  if (!e || Db(e, n) === !1) return !1
  const a = gy(t)
  if (typeof ShadowRoot < 'u' && a instanceof ShadowRoot && a.host === e.target) return !1
  const l = ((typeof n.value == 'object' && n.value.include) || (() => []))()
  return (l.push(t), !l.some((o) => o?.contains(e.target)))
}
function Db(e, t) {
  return ((typeof t.value == 'object' && t.value.closeConditional) || tT)(e)
}
function nT(e, t, n) {
  const a = typeof n.value == 'function' ? n.value : n.value.handler
  ;((e.shadowTarget = e.target),
    t._clickOutside.lastMousedownWasOutside &&
      Eb(e, t, n) &&
      setTimeout(() => {
        Db(e, n) && a && a(e)
      }, 0))
}
function mm(e, t) {
  const n = gy(e)
  ;(t(document), typeof ShadowRoot < 'u' && n instanceof ShadowRoot && t(n))
}
const Nu = {
  mounted(e, t) {
    const n = (l) => nT(l, e, t),
      a = (l) => {
        e._clickOutside.lastMousedownWasOutside = Eb(l, e, t)
      }
    ;(mm(e, (l) => {
      ;(l.addEventListener('click', n, !0), l.addEventListener('mousedown', a, !0))
    }),
      e._clickOutside || (e._clickOutside = { lastMousedownWasOutside: !1 }),
      (e._clickOutside[t.instance.$.uid] = { onClick: n, onMousedown: a }))
  },
  beforeUnmount(e, t) {
    e._clickOutside &&
      (mm(e, (n) => {
        if (!n || !e._clickOutside?.[t.instance.$.uid]) return
        const { onClick: a, onMousedown: l } = e._clickOutside[t.instance.$.uid]
        ;(n.removeEventListener('click', a, !0), n.removeEventListener('mousedown', l, !0))
      }),
      delete e._clickOutside[t.instance.$.uid])
  },
}
function aT(e) {
  const { modelValue: t, color: n, ...a } = e
  return w(
    la,
    { name: 'fade-transition', appear: !0 },
    {
      default: () => [
        e.modelValue &&
          x(
            'div',
            Z(
              {
                class: ['v-overlay__scrim', e.color.backgroundColorClasses.value],
                style: e.color.backgroundColorStyles.value,
              },
              a
            ),
            null
          ),
      ],
    }
  )
}
const di = $(
    {
      absolute: Boolean,
      attach: [Boolean, String, Object],
      closeOnBack: { type: Boolean, default: !0 },
      contained: Boolean,
      contentClass: null,
      contentProps: null,
      disabled: Boolean,
      opacity: [Number, String],
      noClickAnimation: Boolean,
      modelValue: Boolean,
      persistent: Boolean,
      scrim: { type: [Boolean, String], default: !0 },
      zIndex: { type: [Number, String], default: 2e3 },
      ...XI(),
      ...be(),
      ...ft(),
      ...wd(),
      ...FI(),
      ...UI(),
      ...Be(),
      ...Vn(),
    },
    'VOverlay'
  ),
  Nn = J()({
    name: 'VOverlay',
    directives: { vClickOutside: Nu },
    inheritAttrs: !1,
    props: { _disableGlobalStack: Boolean, ...di() },
    emits: {
      'click:outside': (e) => !0,
      'update:modelValue': (e) => !0,
      keydown: (e) => !0,
      afterEnter: () => !0,
      afterLeave: () => !0,
    },
    setup(e, t) {
      let { slots: n, attrs: a, emit: l } = t
      const o = rt('VOverlay'),
        i = ae(),
        r = ae(),
        s = ae(),
        c = we(e, 'modelValue'),
        u = C({
          get: () => c.value,
          set: (L) => {
            ;(L && e.disabled) || (c.value = L)
          },
        }),
        { themeClasses: d } = $e(e),
        { rtlClasses: f, isRtl: v } = gt(),
        { hasContent: g, onAfterLeave: h } = kd(e, u),
        m = He(() => (typeof e.scrim == 'string' ? e.scrim : null)),
        {
          globalTop: b,
          localTop: y,
          stackStyles: p,
        } = QI(u, () => e.zIndex, e._disableGlobalStack),
        {
          activatorEl: S,
          activatorRef: k,
          target: _,
          targetEl: P,
          targetRef: A,
          activatorEvents: D,
          contentEvents: E,
          scrimEvents: R,
        } = ZI(e, { isActive: u, isTop: y, contentEl: s }),
        { teleportTarget: V } = eT(() => {
          const L = e.attach || e.contained
          if (L) return L
          const q = S?.value?.getRootNode() || o.proxy?.$el?.getRootNode()
          return q instanceof ShadowRoot ? q : !1
        }),
        { dimensionStyles: M } = vt(e),
        F = Ab(),
        { scopeId: G } = ml()
      ue(
        () => e.disabled,
        (L) => {
          L && (u.value = !1)
        }
      )
      const { contentStyles: W, updateLocation: te } = NI(e, {
        isRtl: v,
        contentEl: s,
        target: _,
        isActive: u,
      })
      KI(e, { root: i, contentEl: s, targetEl: P, target: _, isActive: u, updateLocation: te })
      function H(L) {
        ;(l('click:outside', L), e.persistent ? se() : (u.value = !1))
      }
      function O(L) {
        return (
          u.value &&
          b.value &&
          (!e.scrim ||
            L.target === r.value ||
            (L instanceof MouseEvent && L.shadowTarget === r.value))
        )
      }
      ;(Ne &&
        ue(
          u,
          (L) => {
            L ? window.addEventListener('keydown', j) : window.removeEventListener('keydown', j)
          },
          { immediate: !0 }
        ),
        dt(() => {
          Ne && window.removeEventListener('keydown', j)
        }))
      function j(L) {
        L.key === 'Escape' &&
          b.value &&
          (s.value?.contains(document.activeElement) || l('keydown', L),
          e.persistent
            ? se()
            : ((u.value = !1), s.value?.contains(document.activeElement) && S.value?.focus()))
      }
      function U(L) {
        ;(L.key === 'Escape' && !b.value) || l('keydown', L)
      }
      const Y = Hy()
      Et(
        () => e.closeOnBack,
        () => {
          $V(Y, (L) => {
            b.value && u.value ? (L(!1), e.persistent ? se() : (u.value = !1)) : L()
          })
        }
      )
      const K = ae()
      ue(
        () => u.value && (e.absolute || e.contained) && V.value == null,
        (L) => {
          if (L) {
            const q = Zc(i.value)
            q && q !== document.scrollingElement && (K.value = q.scrollTop)
          }
        }
      )
      function se() {
        e.noClickAnimation ||
          (s.value &&
            Zn(
              s.value,
              [
                { transformOrigin: 'center' },
                { transform: 'scale(1.03)' },
                { transformOrigin: 'center' },
              ],
              { duration: 150, easing: Mo }
            ))
      }
      function de() {
        l('afterEnter')
      }
      function ye() {
        ;(h(), l('afterLeave'))
      }
      return (
        ne(() =>
          x(he, null, [
            n.activator?.({
              isActive: u.value,
              targetRef: A,
              props: Z({ ref: k }, D.value, e.activatorProps),
            }),
            F.value &&
              g.value &&
              w(
                mw,
                { disabled: !V.value, to: V.value },
                {
                  default: () => [
                    x(
                      'div',
                      Z(
                        {
                          class: [
                            'v-overlay',
                            {
                              'v-overlay--absolute': e.absolute || e.contained,
                              'v-overlay--active': u.value,
                              'v-overlay--contained': e.contained,
                            },
                            d.value,
                            f.value,
                            e.class,
                          ],
                          style: [
                            p.value,
                            { '--v-overlay-opacity': e.opacity, top: fe(K.value) },
                            e.style,
                          ],
                          ref: i,
                          onKeydown: U,
                        },
                        G,
                        a
                      ),
                      [
                        w(
                          aT,
                          Z({ color: m, modelValue: u.value && !!e.scrim, ref: r }, R.value),
                          null
                        ),
                        w(
                          $t,
                          {
                            appear: !0,
                            persisted: !0,
                            transition: e.transition,
                            target: _.value,
                            onAfterEnter: de,
                            onAfterLeave: ye,
                          },
                          {
                            default: () => [
                              tt(
                                x(
                                  'div',
                                  Z(
                                    {
                                      ref: s,
                                      class: ['v-overlay__content', e.contentClass],
                                      style: [M.value, W.value],
                                    },
                                    E.value,
                                    e.contentProps
                                  ),
                                  [n.default?.({ isActive: u })]
                                ),
                                [
                                  [Pn, u.value],
                                  [
                                    Nu,
                                    { handler: H, closeConditional: O, include: () => [S.value] },
                                  ],
                                ]
                              ),
                            ],
                          }
                        ),
                      ]
                    ),
                  ],
                }
              ),
          ])
        ),
        {
          activatorEl: S,
          scrimEl: r,
          target: _,
          animateClick: se,
          contentEl: s,
          globalTop: b,
          localTop: y,
          updateLocation: te,
        }
      )
    },
  }),
  Rb = $(
    {
      id: String,
      submenu: Boolean,
      disableInitialFocus: Boolean,
      ...je(
        di({
          closeDelay: 250,
          closeOnContentClick: !0,
          locationStrategy: 'connected',
          location: void 0,
          openDelay: 300,
          scrim: !1,
          scrollStrategy: 'reposition',
          transition: { component: $r },
        }),
        ['absolute']
      ),
    },
    'VMenu'
  ),
  Kl = J()({
    name: 'VMenu',
    props: Rb(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = we(e, 'modelValue'),
        { scopeId: l } = ml(),
        { isRtl: o } = gt(),
        i = Rt(),
        r = B(() => e.id || `v-menu-${i}`),
        s = ae(),
        c = Ve(Fu, null),
        u = oe(new Set())
      ;(Fe(Fu, {
        register() {
          u.value.add(i)
        },
        unregister() {
          u.value.delete(i)
        },
        closeParents(m) {
          setTimeout(() => {
            !u.value.size &&
              !e.persistent &&
              (m == null || (s.value?.contentEl && !o1(m, s.value.contentEl))) &&
              ((a.value = !1), c?.closeParents())
          }, 40)
        },
      }),
        dt(() => {
          ;(c?.unregister(), document.removeEventListener('focusin', d))
        }),
        kr(() => (a.value = !1)))
      async function d(m) {
        const b = m.relatedTarget,
          y = m.target
        ;(await Re(),
          a.value &&
            b !== y &&
            s.value?.contentEl &&
            s.value?.globalTop &&
            ![document, s.value.contentEl].includes(y) &&
            !s.value.contentEl.contains(y) &&
            Ro(s.value.contentEl)[0]?.focus())
      }
      ue(
        a,
        (m) => {
          m
            ? (c?.register(),
              Ne && !e.disableInitialFocus && document.addEventListener('focusin', d, { once: !0 }))
            : (c?.unregister(), Ne && document.removeEventListener('focusin', d))
        },
        { immediate: !0 }
      )
      function f(m) {
        c?.closeParents(m)
      }
      function v(m) {
        if (!e.disabled)
          if (m.key === 'Tab' || (m.key === 'Enter' && !e.closeOnContentClick)) {
            if (
              m.key === 'Enter' &&
              (m.target instanceof HTMLTextAreaElement ||
                (m.target instanceof HTMLInputElement && m.target.closest('form')))
            )
              return
            ;(m.key === 'Enter' && m.preventDefault(),
              ny(
                Ro(s.value?.contentEl, !1),
                m.shiftKey ? 'prev' : 'next',
                (y) => y.tabIndex >= 0
              ) || ((a.value = !1), s.value?.activatorEl?.focus()))
          } else
            e.submenu &&
              m.key === (o.value ? 'ArrowRight' : 'ArrowLeft') &&
              ((a.value = !1), s.value?.activatorEl?.focus())
      }
      function g(m) {
        if (e.disabled) return
        const b = s.value?.contentEl
        b && a.value
          ? m.key === 'ArrowDown'
            ? (m.preventDefault(), m.stopImmediatePropagation(), Ua(b, 'next'))
            : m.key === 'ArrowUp'
              ? (m.preventDefault(), m.stopImmediatePropagation(), Ua(b, 'prev'))
              : e.submenu &&
                (m.key === (o.value ? 'ArrowRight' : 'ArrowLeft')
                  ? (a.value = !1)
                  : m.key === (o.value ? 'ArrowLeft' : 'ArrowRight') &&
                    (m.preventDefault(), Ua(b, 'first')))
          : (e.submenu
              ? m.key === (o.value ? 'ArrowLeft' : 'ArrowRight')
              : ['ArrowDown', 'ArrowUp'].includes(m.key)) &&
            ((a.value = !0), m.preventDefault(), setTimeout(() => setTimeout(() => g(m))))
      }
      const h = C(() =>
        Z(
          {
            'aria-haspopup': 'menu',
            'aria-expanded': String(a.value),
            'aria-controls': r.value,
            onKeydown: g,
          },
          e.activatorProps
        )
      )
      return (
        ne(() => {
          const m = Nn.filterProps(e)
          return w(
            Nn,
            Z(
              { ref: s, id: r.value, class: ['v-menu', e.class], style: e.style },
              m,
              {
                modelValue: a.value,
                'onUpdate:modelValue': (b) => (a.value = b),
                absolute: !0,
                activatorProps: h.value,
                location: e.location ?? (e.submenu ? 'end' : 'bottom'),
                'onClick:outside': f,
                onKeydown: v,
              },
              l
            ),
            {
              activator: n.activator,
              default: function () {
                for (var b = arguments.length, y = new Array(b), p = 0; p < b; p++)
                  y[p] = arguments[p]
                return w(Ae, { root: 'VMenu' }, { default: () => [n.default?.(...y)] })
              },
            }
          )
        }),
        _t({ id: r, ΨopenChildren: u }, s)
      )
    },
  }),
  lT = $(
    {
      active: Boolean,
      disabled: Boolean,
      max: [Number, String],
      value: { type: [Number, String], default: 0 },
      ...be(),
      ...Vn({ transition: { component: sd } }),
    },
    'VCounter'
  ),
  Wr = J()({
    name: 'VCounter',
    functional: !0,
    props: lT(),
    setup(e, t) {
      let { slots: n } = t
      const a = B(() => (e.max ? `${e.value} / ${e.max}` : String(e.value)))
      return (
        ne(() =>
          w(
            $t,
            { transition: e.transition },
            {
              default: () => [
                tt(
                  x(
                    'div',
                    {
                      class: ee([
                        'v-counter',
                        {
                          'text-error':
                            e.max && !e.disabled && parseFloat(e.value) > parseFloat(e.max),
                        },
                        e.class,
                      ]),
                      style: ce(e.style),
                    },
                    [
                      n.default
                        ? n.default({ counter: a.value, max: e.max, value: e.value })
                        : a.value,
                    ]
                  ),
                  [[Pn, e.active]]
                ),
              ],
            }
          )
        ),
        {}
      )
    },
  }),
  oT = $({ floating: Boolean, ...be() }, 'VFieldLabel'),
  go = J()({
    name: 'VFieldLabel',
    props: oT(),
    setup(e, t) {
      let { slots: n } = t
      return (
        ne(() =>
          w(
            eo,
            {
              class: ee(['v-field-label', { 'v-field-label--floating': e.floating }, e.class]),
              style: ce(e.style),
            },
            n
          )
        ),
        {}
      )
    },
  }),
  iT = ['underlined', 'outlined', 'filled', 'solo', 'solo-inverted', 'solo-filled', 'plain'],
  fi = $(
    {
      appendInnerIcon: Se,
      bgColor: String,
      clearable: Boolean,
      clearIcon: { type: Se, default: '$clear' },
      active: Boolean,
      centerAffix: { type: Boolean, default: void 0 },
      color: String,
      baseColor: String,
      details: Boolean,
      dirty: Boolean,
      disabled: { type: Boolean, default: null },
      glow: Boolean,
      error: Boolean,
      flat: Boolean,
      iconColor: [Boolean, String],
      label: String,
      persistentClear: Boolean,
      prependInnerIcon: Se,
      reverse: Boolean,
      singleLine: Boolean,
      variant: { type: String, default: 'filled', validator: (e) => iT.includes(e) },
      'onClick:clear': Pt(),
      'onClick:appendInner': Pt(),
      'onClick:prependInner': Pt(),
      ...be(),
      ...Hr(),
      ...Je(),
      ...Be(),
    },
    'VField'
  ),
  Va = J()({
    name: 'VField',
    inheritAttrs: !1,
    props: { id: String, ...ci(), ...fi() },
    emits: { 'update:focused': (e) => !0, 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { attrs: n, emit: a, slots: l } = t
      const { themeClasses: o } = $e(e),
        { loaderClasses: i } = ii(e),
        { focusClasses: r, isFocused: s, focus: c, blur: u } = va(e),
        { InputIcon: d } = Qy(e),
        { roundedClasses: f } = ot(e),
        { rtlClasses: v } = gt(),
        g = B(() => e.dirty || e.active),
        h = B(() => !!(e.label || l.label)),
        m = B(() => !e.singleLine && h.value),
        b = Rt(),
        y = C(() => e.id || `input-${b}`),
        p = B(() => (e.details ? `${y.value}-messages` : void 0)),
        S = ae(),
        k = ae(),
        _ = ae(),
        P = C(() => ['plain', 'underlined'].includes(e.variant)),
        A = C(() => (e.error || e.disabled ? void 0 : g.value && s.value ? e.color : e.baseColor)),
        D = C(() => {
          if (!(!e.iconColor || (e.glow && !s.value)))
            return e.iconColor === !0 ? A.value : e.iconColor
        }),
        { backgroundColorClasses: E, backgroundColorStyles: R } = He(() => e.bgColor),
        { textColorClasses: V, textColorStyles: M } = Vt(A)
      ue(
        g,
        (W) => {
          if (m.value && !On()) {
            const te = S.value.$el,
              H = k.value.$el
            requestAnimationFrame(() => {
              const O = Gc(te),
                j = H.getBoundingClientRect(),
                U = j.x - O.x,
                Y = j.y - O.y - (O.height / 2 - j.height / 2),
                K = j.width / 0.75,
                se = Math.abs(K - O.width) > 1 ? { maxWidth: fe(K) } : void 0,
                de = getComputedStyle(te),
                ye = getComputedStyle(H),
                L = parseFloat(de.transitionDuration) * 1e3 || 150,
                q = parseFloat(ye.getPropertyValue('--v-field-label-scale')),
                le = ye.getPropertyValue('color')
              ;((te.style.visibility = 'visible'),
                (H.style.visibility = 'hidden'),
                Zn(
                  te,
                  { transform: `translate(${U}px, ${Y}px) scale(${q})`, color: le, ...se },
                  { duration: L, easing: Mo, direction: W ? 'normal' : 'reverse' }
                ).finished.then(() => {
                  ;(te.style.removeProperty('visibility'), H.style.removeProperty('visibility'))
                }))
            })
          }
        },
        { flush: 'post' }
      )
      const F = C(() => ({ isActive: g, isFocused: s, controlRef: _, blur: u, focus: c }))
      function G(W) {
        W.target !== document.activeElement && W.preventDefault()
      }
      return (
        ne(() => {
          const W = e.variant === 'outlined',
            te = !!(l['prepend-inner'] || e.prependInnerIcon),
            H = !!(e.clearable || l.clear) && !e.disabled,
            O = !!(l['append-inner'] || e.appendInnerIcon || H),
            j = () =>
              l.label ? l.label({ ...F.value, label: e.label, props: { for: y.value } }) : e.label
          return x(
            'div',
            Z(
              {
                class: [
                  'v-field',
                  {
                    'v-field--active': g.value,
                    'v-field--appended': O,
                    'v-field--center-affix': e.centerAffix ?? !P.value,
                    'v-field--disabled': e.disabled,
                    'v-field--dirty': e.dirty,
                    'v-field--error': e.error,
                    'v-field--glow': e.glow,
                    'v-field--flat': e.flat,
                    'v-field--has-background': !!e.bgColor,
                    'v-field--persistent-clear': e.persistentClear,
                    'v-field--prepended': te,
                    'v-field--reverse': e.reverse,
                    'v-field--single-line': e.singleLine,
                    'v-field--no-label': !j(),
                    [`v-field--variant-${e.variant}`]: !0,
                  },
                  o.value,
                  E.value,
                  r.value,
                  i.value,
                  f.value,
                  v.value,
                  e.class,
                ],
                style: [R.value, e.style],
                onClick: G,
              },
              n
            ),
            [
              x('div', { class: 'v-field__overlay' }, null),
              w(
                ri,
                {
                  name: 'v-field',
                  active: !!e.loading,
                  color: e.error ? 'error' : typeof e.loading == 'string' ? e.loading : e.color,
                },
                { default: l.loader }
              ),
              te &&
                x('div', { key: 'prepend', class: 'v-field__prepend-inner' }, [
                  e.prependInnerIcon &&
                    w(d, { key: 'prepend-icon', name: 'prependInner', color: D.value }, null),
                  l['prepend-inner']?.(F.value),
                ]),
              x('div', { class: 'v-field__field', 'data-no-activator': '' }, [
                ['filled', 'solo', 'solo-inverted', 'solo-filled'].includes(e.variant) &&
                  m.value &&
                  w(
                    go,
                    {
                      key: 'floating-label',
                      ref: k,
                      class: ee([V.value]),
                      floating: !0,
                      for: y.value,
                      'aria-hidden': !g.value,
                      style: ce(M.value),
                    },
                    { default: () => [j()] }
                  ),
                h.value && w(go, { key: 'label', ref: S, for: y.value }, { default: () => [j()] }),
                l.default?.({
                  ...F.value,
                  props: { id: y.value, class: 'v-field__input', 'aria-describedby': p.value },
                  focus: c,
                  blur: u,
                }) ??
                  x(
                    'div',
                    { id: y.value, class: 'v-field__input', 'aria-describedby': p.value },
                    null
                  ),
              ]),
              H &&
                w(
                  ud,
                  { key: 'clear' },
                  {
                    default: () => [
                      tt(
                        x(
                          'div',
                          {
                            class: 'v-field__clearable',
                            onMousedown: (U) => {
                              ;(U.preventDefault(), U.stopPropagation())
                            },
                          },
                          [
                            w(
                              Ae,
                              { defaults: { VIcon: { icon: e.clearIcon } } },
                              {
                                default: () => [
                                  l.clear
                                    ? l.clear({
                                        ...F.value,
                                        props: {
                                          onFocus: c,
                                          onBlur: u,
                                          onClick: e['onClick:clear'],
                                          tabindex: -1,
                                        },
                                      })
                                    : w(
                                        d,
                                        { name: 'clear', onFocus: c, onBlur: u, tabindex: -1 },
                                        null
                                      ),
                                ],
                              }
                            ),
                          ]
                        ),
                        [[Pn, e.dirty]]
                      ),
                    ],
                  }
                ),
              O &&
                x('div', { key: 'append', class: 'v-field__append-inner' }, [
                  l['append-inner']?.(F.value),
                  e.appendInnerIcon &&
                    w(d, { key: 'append-icon', name: 'appendInner', color: D.value }, null),
                ]),
              x('div', { class: ee(['v-field__outline', V.value]), style: ce(M.value) }, [
                W &&
                  x(he, null, [
                    x('div', { class: 'v-field__outline__start' }, null),
                    m.value &&
                      x('div', { class: 'v-field__outline__notch' }, [
                        w(
                          go,
                          { ref: k, floating: !0, for: y.value, 'aria-hidden': !g.value },
                          { default: () => [j()] }
                        ),
                      ]),
                    x('div', { class: 'v-field__outline__end' }, null),
                  ]),
                P.value &&
                  m.value &&
                  w(
                    go,
                    { ref: k, floating: !0, for: y.value, 'aria-hidden': !g.value },
                    { default: () => [j()] }
                  ),
              ]),
            ]
          )
        }),
        { controlRef: _, fieldIconColor: D }
      )
    },
  }),
  Mb = $({ autocomplete: String }, 'autocomplete')
function Bb(e) {
  const t = Rt(),
    n = oe(0),
    a = B(() => e.autocomplete === 'suppress'),
    l = B(() => (a.value ? `${e.name}-${t}-${n.value}` : e.name)),
    o = B(() => (a.value ? 'off' : e.autocomplete))
  return {
    isSuppressing: a,
    fieldAutocomplete: o,
    fieldName: l,
    update: () => (n.value = new Date().getTime()),
  }
}
function Lb(e) {
  function t(n, a) {
    !e.autofocus || !n || a[0].target?.focus?.()
  }
  return { onIntersect: t }
}
const rT = ['color', 'file', 'time', 'date', 'datetime-local', 'week', 'month'],
  vi = $(
    {
      autofocus: Boolean,
      counter: [Boolean, Number, String],
      counterValue: [Number, Function],
      prefix: String,
      placeholder: String,
      persistentPlaceholder: Boolean,
      persistentCounter: Boolean,
      suffix: String,
      role: String,
      type: { type: String, default: 'text' },
      modelModifiers: Object,
      ...Mb(),
      ...ma(),
      ...fi(),
    },
    'VTextField'
  ),
  ia = J()({
    name: 'VTextField',
    directives: { vIntersect: xn },
    inheritAttrs: !1,
    props: vi(),
    emits: {
      'click:control': (e) => !0,
      'mousedown:control': (e) => !0,
      'update:focused': (e) => !0,
      'update:modelValue': (e) => !0,
    },
    setup(e, t) {
      let { attrs: n, emit: a, slots: l } = t
      const o = we(e, 'modelValue'),
        { isFocused: i, focus: r, blur: s } = va(e),
        { onIntersect: c } = Lb(e),
        u = C(() =>
          typeof e.counterValue == 'function'
            ? e.counterValue(o.value)
            : typeof e.counterValue == 'number'
              ? e.counterValue
              : (o.value ?? '').toString().length
        ),
        d = C(() => {
          if (n.maxlength) return n.maxlength
          if (!(!e.counter || (typeof e.counter != 'number' && typeof e.counter != 'string')))
            return e.counter
        }),
        f = C(() => ['plain', 'underlined'].includes(e.variant)),
        v = ae(),
        g = ae(),
        h = ae(),
        m = Bb(e),
        b = C(() => rT.includes(e.type) || e.persistentPlaceholder || i.value || e.active)
      function y() {
        ;(m.isSuppressing.value && m.update(),
          i.value || r(),
          Re(() => {
            h.value !== document.activeElement && h.value?.focus()
          }))
      }
      function p(P) {
        ;(a('mousedown:control', P), P.target !== h.value && (y(), P.preventDefault()))
      }
      function S(P) {
        a('click:control', P)
      }
      function k(P, A) {
        ;(P.stopPropagation(),
          y(),
          Re(() => {
            ;((o.value = null), A(), ti(e['onClick:clear'], P))
          }))
      }
      function _(P) {
        const A = P.target
        if (
          ((o.value = A.value),
          e.modelModifiers?.trim && ['text', 'search', 'password', 'tel', 'url'].includes(e.type))
        ) {
          const D = [A.selectionStart, A.selectionEnd]
          Re(() => {
            ;((A.selectionStart = D[0]), (A.selectionEnd = D[1]))
          })
        }
      }
      return (
        ne(() => {
          const P = !!(l.counter || (e.counter !== !1 && e.counter != null)),
            A = !!(P || l.details),
            [D, E] = Ia(n),
            { modelValue: R, ...V } = Dt.filterProps(e),
            M = Va.filterProps(e)
          return w(
            Dt,
            Z(
              {
                ref: v,
                modelValue: o.value,
                'onUpdate:modelValue': (F) => (o.value = F),
                class: [
                  'v-text-field',
                  {
                    'v-text-field--prefixed': e.prefix,
                    'v-text-field--suffixed': e.suffix,
                    'v-input--plain-underlined': f.value,
                  },
                  e.class,
                ],
                style: e.style,
              },
              D,
              V,
              { centerAffix: !f.value, focused: i.value }
            ),
            {
              ...l,
              default: (F) => {
                let {
                  id: G,
                  isDisabled: W,
                  isDirty: te,
                  isReadonly: H,
                  isValid: O,
                  hasDetails: j,
                  reset: U,
                } = F
                return w(
                  Va,
                  Z(
                    {
                      ref: g,
                      onMousedown: p,
                      onClick: S,
                      'onClick:clear': (Y) => k(Y, U),
                      'onClick:prependInner': e['onClick:prependInner'],
                      'onClick:appendInner': e['onClick:appendInner'],
                      role: e.role,
                    },
                    je(M, ['onClick:clear']),
                    {
                      id: G.value,
                      active: b.value || te.value,
                      dirty: te.value || e.dirty,
                      disabled: W.value,
                      focused: i.value,
                      details: j.value,
                      error: O.value === !1,
                    }
                  ),
                  {
                    ...l,
                    default: (Y) => {
                      let {
                        props: { class: K, ...se },
                      } = Y
                      const de = tt(
                        x(
                          'input',
                          Z(
                            {
                              ref: h,
                              value: o.value,
                              onInput: _,
                              autofocus: e.autofocus,
                              readonly: H.value,
                              disabled: W.value,
                              name: m.fieldName.value,
                              autocomplete: m.fieldAutocomplete.value,
                              placeholder: e.placeholder,
                              size: 1,
                              role: e.role,
                              type: e.type,
                              onFocus: r,
                              onBlur: s,
                            },
                            se,
                            E
                          ),
                          null
                        ),
                        [[xn, { handler: c }, null, { once: !0 }]]
                      )
                      return x(he, null, [
                        e.prefix &&
                          x('span', { class: 'v-text-field__prefix' }, [
                            x('span', { class: 'v-text-field__prefix__text' }, [e.prefix]),
                          ]),
                        l.default
                          ? x('div', { class: ee(K), 'data-no-activator': '' }, [l.default(), de])
                          : Ln(de, { class: K }),
                        e.suffix &&
                          x('span', { class: 'v-text-field__suffix' }, [
                            x('span', { class: 'v-text-field__suffix__text' }, [e.suffix]),
                          ]),
                      ])
                    },
                  }
                )
              },
              details: A
                ? (F) =>
                    x(he, null, [
                      l.details?.(F),
                      P &&
                        x(he, null, [
                          x('span', null, null),
                          w(
                            Wr,
                            {
                              active: e.persistentCounter || i.value,
                              value: u.value,
                              max: d.value,
                              disabled: e.disabled,
                            },
                            l.counter
                          ),
                        ]),
                    ])
                : void 0,
            }
          )
        }),
        _t({}, v, g, h)
      )
    },
  }),
  sT = $({ renderless: Boolean, ...be() }, 'VVirtualScrollItem'),
  Ob = J()({
    name: 'VVirtualScrollItem',
    inheritAttrs: !1,
    props: sT(),
    emits: { 'update:height': (e) => !0 },
    setup(e, t) {
      let { attrs: n, emit: a, slots: l } = t
      const { resizeRef: o, contentRect: i } = hn(void 0, 'border')
      ;(ue(
        () => i.value?.height,
        (r) => {
          r != null && a('update:height', r)
        }
      ),
        ne(() =>
          e.renderless
            ? x(he, null, [l.default?.({ itemRef: o })])
            : x(
                'div',
                Z({ ref: o, class: ['v-virtual-scroll__item', e.class], style: e.style }, n),
                [l.default?.()]
              )
        ))
    },
  }),
  uT = -1,
  cT = 1,
  $s = 100,
  $b = $(
    {
      itemHeight: { type: [Number, String], default: null },
      itemKey: { type: [String, Array, Function], default: null },
      height: [Number, String],
    },
    'virtual'
  )
function Fb(e, t) {
  const n = gn(),
    a = oe(0)
  qe(() => {
    a.value = parseFloat(e.itemHeight || 0)
  })
  const l = oe(0),
    o = oe(Math.ceil((parseInt(e.height) || n.height.value) / (a.value || 16)) || 1),
    i = oe(0),
    r = oe(0),
    s = ae(),
    c = ae()
  let u = 0
  const { resizeRef: d, contentRect: f } = hn()
  qe(() => {
    d.value = s.value
  })
  const v = C(() =>
      s.value === document.documentElement
        ? n.height.value
        : f.value?.height || parseInt(e.height) || 0
    ),
    g = C(() => !!(s.value && c.value && v.value && a.value))
  let h = Array.from({ length: t.value.length }),
    m = Array.from({ length: t.value.length })
  const b = oe(0)
  let y = -1
  function p(j) {
    return h[j] || a.value
  }
  const S = Jg(() => {
      const j = performance.now()
      m[0] = 0
      const U = t.value.length
      for (let Y = 1; Y <= U - 1; Y++) m[Y] = (m[Y - 1] || 0) + p(Y - 1)
      b.value = Math.max(b.value, performance.now() - j)
    }, b),
    k = ue(g, (j) => {
      j &&
        (k(),
        (u = c.value.offsetTop),
        S.immediate(),
        W(),
        ~y &&
          Re(() => {
            Ne &&
              window.requestAnimationFrame(() => {
                ;(H(y), (y = -1))
              })
          }))
    })
  bt(() => {
    S.clear()
  })
  function _(j, U) {
    const Y = h[j],
      K = a.value
    ;((a.value = K ? Math.min(a.value, U) : U), (Y !== U || K !== a.value) && ((h[j] = U), S()))
  }
  function P(j) {
    j = Ge(j, 0, t.value.length - 1)
    const U = Math.floor(j),
      Y = j % 1,
      K = U + 1,
      se = m[U] || 0,
      de = m[K] || se
    return se + (de - se) * Y
  }
  function A(j) {
    return dT(m, j)
  }
  let D = 0,
    E = 0,
    R = 0
  ue(v, (j, U) => {
    U &&
      (W(),
      j < U &&
        requestAnimationFrame(() => {
          ;((E = 0), W())
        }))
  })
  let V = -1
  function M() {
    if (!s.value || !c.value) return
    const j = s.value.scrollTop,
      U = performance.now()
    ;(U - R > 500 ? ((E = Math.sign(j - D)), (u = c.value.offsetTop)) : (E = j - D),
      (D = j),
      (R = U),
      window.clearTimeout(V),
      (V = window.setTimeout(F, 500)),
      W())
  }
  function F() {
    !s.value || !c.value || ((E = 0), (R = 0), window.clearTimeout(V), W())
  }
  let G = -1
  function W() {
    ;(cancelAnimationFrame(G), (G = requestAnimationFrame(te)))
  }
  function te() {
    if (!s.value || !v.value || !a.value) return
    const j = D - u,
      U = Math.sign(E),
      Y = Math.max(0, j - $s),
      K = Ge(A(Y), 0, t.value.length),
      se = j + v.value + $s,
      de = Ge(A(se) + 1, K + 1, t.value.length)
    if ((U !== uT || K < l.value) && (U !== cT || de > o.value)) {
      const ye = P(l.value) - P(K),
        L = P(de) - P(o.value)
      Math.max(ye, L) > $s
        ? ((l.value = K), (o.value = de))
        : (K <= 0 && (l.value = K), de >= t.value.length && (o.value = de))
    }
    ;((i.value = P(l.value)), (r.value = P(t.value.length) - P(o.value)))
  }
  function H(j) {
    const U = P(j)
    !s.value || (j && !U) ? (y = j) : (s.value.scrollTop = U)
  }
  const O = C(() =>
    t.value.slice(l.value, o.value).map((j, U) => {
      const Y = U + l.value
      return { raw: j, index: Y, key: st(j, e.itemKey, Y) }
    })
  )
  return (
    ue(
      t,
      () => {
        ;((h = Array.from({ length: t.value.length })),
          (m = Array.from({ length: t.value.length })),
          S.immediate(),
          W())
      },
      { deep: 1 }
    ),
    {
      calculateVisibleItems: W,
      containerRef: s,
      markerRef: c,
      computedItems: O,
      paddingTop: i,
      paddingBottom: r,
      scrollToIndex: H,
      handleScroll: M,
      handleScrollend: F,
      handleItemResize: _,
    }
  )
}
function dT(e, t) {
  let n = e.length - 1,
    a = 0,
    l = 0,
    o = null,
    i = -1
  if (e[n] < t) return n
  for (; a <= n; )
    if (((l = (a + n) >> 1), (o = e[l]), o > t)) n = l - 1
    else if (o < t) ((i = l), (a = l + 1))
    else return o === t ? l : a
  return i
}
const fT = $(
    { items: { type: Array, default: () => [] }, renderless: Boolean, ...$b(), ...be(), ...ft() },
    'VVirtualScroll'
  ),
  Ur = J()({
    name: 'VVirtualScroll',
    props: fT(),
    setup(e, t) {
      let { slots: n } = t
      const a = rt('VVirtualScroll'),
        { dimensionStyles: l } = vt(e),
        {
          calculateVisibleItems: o,
          containerRef: i,
          markerRef: r,
          handleScroll: s,
          handleScrollend: c,
          handleItemResize: u,
          scrollToIndex: d,
          paddingTop: f,
          paddingBottom: v,
          computedItems: g,
        } = Fb(
          e,
          B(() => e.items)
        )
      return (
        Et(
          () => e.renderless,
          () => {
            function h() {
              const b = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1)
                ? 'addEventListener'
                : 'removeEventListener'
              i.value === document.documentElement
                ? (document[b]('scroll', s, { passive: !0 }), document[b]('scrollend', c))
                : (i.value?.[b]('scroll', s, { passive: !0 }), i.value?.[b]('scrollend', c))
            }
            ;(pt(() => {
              ;((i.value = Zc(a.vnode.el, !0)), h(!0))
            }),
              bt(h))
          }
        ),
        ne(() => {
          const h = g.value.map((m) =>
            w(
              Ob,
              { key: m.key, renderless: e.renderless, 'onUpdate:height': (b) => u(m.index, b) },
              { default: (b) => n.default?.({ item: m.raw, index: m.index, ...b }) }
            )
          )
          return e.renderless
            ? x(he, null, [
                x(
                  'div',
                  { ref: r, class: 'v-virtual-scroll__spacer', style: { paddingTop: fe(f.value) } },
                  null
                ),
                h,
                x(
                  'div',
                  { class: 'v-virtual-scroll__spacer', style: { paddingBottom: fe(v.value) } },
                  null
                ),
              ])
            : x(
                'div',
                {
                  ref: i,
                  class: ee(['v-virtual-scroll', e.class]),
                  onScrollPassive: s,
                  onScrollend: c,
                  style: ce([l.value, e.style]),
                },
                [
                  x(
                    'div',
                    {
                      ref: r,
                      class: 'v-virtual-scroll__container',
                      style: { paddingTop: fe(f.value), paddingBottom: fe(v.value) },
                    },
                    [h]
                  ),
                ]
              )
        }),
        { calculateVisibleItems: o, scrollToIndex: d }
      )
    },
  })
function Cd(e, t) {
  const n = oe(!1)
  let a
  function l(r) {
    ;(cancelAnimationFrame(a),
      (n.value = !0),
      (a = requestAnimationFrame(() => {
        a = requestAnimationFrame(() => {
          n.value = !1
        })
      })))
  }
  async function o() {
    ;(await new Promise((r) => requestAnimationFrame(r)),
      await new Promise((r) => requestAnimationFrame(r)),
      await new Promise((r) => requestAnimationFrame(r)),
      await new Promise((r) => {
        if (n.value) {
          const s = ue(n, () => {
            ;(s(), r())
          })
        } else r()
      }))
  }
  async function i(r) {
    if (
      (r.key === 'Tab' && t.value?.focus(), !['PageDown', 'PageUp', 'Home', 'End'].includes(r.key))
    )
      return
    const s = e.value?.$el
    if (!s) return
    ;((r.key === 'Home' || r.key === 'End') &&
      s.scrollTo({ top: r.key === 'Home' ? 0 : s.scrollHeight, behavior: 'smooth' }),
      await o())
    const c = s.querySelectorAll(':scope > :not(.v-virtual-scroll__spacer)')
    if (r.key === 'PageDown' || r.key === 'Home') {
      const u = s.getBoundingClientRect().top
      for (const d of c)
        if (d.getBoundingClientRect().top >= u) {
          d.focus()
          break
        }
    } else {
      const u = s.getBoundingClientRect().bottom
      for (const d of [...c].reverse())
        if (d.getBoundingClientRect().bottom <= u) {
          d.focus()
          break
        }
    }
  }
  return { onScrollPassive: l, onKeydown: i }
}
const vT = $(
  {
    closeText: { type: String, default: '$vuetify.close' },
    openText: { type: String, default: '$vuetify.open' },
  },
  'autocomplete'
)
function xd(e, t) {
  const { t: n } = ze(),
    a = Rt(),
    l = C(() => `menu-${a}`),
    o = B(() => Ft(t)),
    i = B(() => l.value),
    r = B(() => n(Ft(t) ? e.closeText : e.openText))
  return { menuId: l, ariaExpanded: o, ariaControls: i, ariaLabel: r }
}
const _d = $(
    {
      chips: Boolean,
      closableChips: Boolean,
      eager: Boolean,
      hideNoData: Boolean,
      hideSelected: Boolean,
      listProps: { type: Object },
      menu: Boolean,
      menuIcon: { type: Se, default: '$dropdown' },
      menuProps: { type: Object },
      multiple: Boolean,
      noDataText: { type: String, default: '$vuetify.noDataText' },
      openOnClear: Boolean,
      itemColor: String,
      noAutoScroll: Boolean,
      ...vT(),
      ...wb({ itemChildren: !1 }),
    },
    'Select'
  ),
  mT = $(
    {
      ..._d(),
      ...je(vi({ modelValue: null, role: 'combobox' }), [
        'validationValue',
        'dirty',
        'appendInnerIcon',
      ]),
      ...Vn({ transition: { component: $r } }),
    },
    'VSelect'
  ),
  Pd = J()({
    name: 'VSelect',
    props: mT(),
    emits: {
      'update:focused': (e) => !0,
      'update:modelValue': (e) => !0,
      'update:menu': (e) => !0,
    },
    setup(e, t) {
      let { slots: n } = t
      const { t: a } = ze(),
        l = ae(),
        o = ae(),
        i = ae(),
        { items: r, transformIn: s, transformOut: c } = gd(e),
        u = we(
          e,
          'modelValue',
          [],
          (K) => s(K === null ? [null] : nt(K)),
          (K) => {
            const se = c(K)
            return e.multiple ? se : (se[0] ?? null)
          }
        ),
        d = C(() =>
          typeof e.counterValue == 'function'
            ? e.counterValue(u.value)
            : typeof e.counterValue == 'number'
              ? e.counterValue
              : u.value.length
        ),
        f = to(e),
        v = C(() => u.value.map((K) => K.value)),
        g = oe(!1)
      let h = '',
        m = -1,
        b
      const y = C(() =>
          e.hideSelected
            ? r.value.filter((K) => !u.value.some((se) => (e.valueComparator || kt)(se, K)))
            : r.value
        ),
        p = C(() => (e.hideNoData && !y.value.length) || f.isReadonly.value || f.isDisabled.value),
        S = we(e, 'menu'),
        k = C({
          get: () => S.value,
          set: (K) => {
            ;(S.value && !K && o.value?.ΨopenChildren.size) || (K && p.value) || (S.value = K)
          },
        }),
        { menuId: _, ariaExpanded: P, ariaControls: A, ariaLabel: D } = xd(e, k),
        E = C(() => ({
          ...e.menuProps,
          activatorProps: { ...(e.menuProps?.activatorProps || {}), 'aria-haspopup': 'listbox' },
        })),
        R = ae(),
        V = Cd(R, l)
      function M(K) {
        e.openOnClear && (k.value = !0)
      }
      function F() {
        p.value || (k.value = !k.value)
      }
      function G(K) {
        jl(K) && W(K)
      }
      function W(K) {
        if (!K.key || f.isReadonly.value) return
        ;(['Enter', ' ', 'ArrowDown', 'ArrowUp', 'Home', 'End'].includes(K.key) &&
          K.preventDefault(),
          ['Enter', 'ArrowDown', ' '].includes(K.key) && (k.value = !0),
          ['Escape', 'Tab'].includes(K.key) && (k.value = !1),
          K.key === 'Home' ? R.value?.focus('first') : K.key === 'End' && R.value?.focus('last'))
        const se = 1e3
        if (!jl(K)) return
        const de = performance.now()
        ;(de - b > se && ((h = ''), (m = -1)), (h += K.key.toLowerCase()), (b = de))
        const ye = y.value
        function L() {
          let pe = q()
          return pe ||
            (h.at(-1) === h.at(-2) && ((h = h.slice(0, -1)), (pe = q()), pe)) ||
            ((m = -1), (pe = q()), pe)
            ? pe
            : ((h = K.key.toLowerCase()), q())
        }
        function q() {
          for (let pe = m + 1; pe < ye.length; pe++) {
            const I = ye[pe]
            if (I.title.toLowerCase().startsWith(h)) return [I, pe]
          }
        }
        const le = L()
        if (!le) return
        const [ie, Ce] = le
        ;((m = Ce), R.value?.focus(Ce), e.multiple || (u.value = [ie]))
      }
      function te(K) {
        let se = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
        if (!K.props.disabled)
          if (e.multiple) {
            const de = u.value.findIndex((L) => (e.valueComparator || kt)(L.value, K.value)),
              ye = se ?? !~de
            if (~de) {
              const L = ye ? [...u.value, K] : [...u.value]
              ;(L.splice(de, 1), (u.value = L))
            } else ye && (u.value = [...u.value, K])
          } else {
            const de = se !== !1
            ;((u.value = de ? [K] : []),
              Re(() => {
                k.value = !1
              }))
          }
      }
      function H(K) {
        R.value?.$el.contains(K.relatedTarget) || (k.value = !1)
      }
      function O() {
        e.eager && i.value?.calculateVisibleItems()
      }
      function j() {
        g.value && l.value?.focus()
      }
      function U(K) {
        g.value = !0
      }
      function Y(K) {
        if (K == null) u.value = []
        else if (Hl(l.value, ':autofill') || Hl(l.value, ':-webkit-autofill')) {
          const se = r.value.find((de) => de.title === K)
          se && te(se)
        } else l.value && (l.value.value = '')
      }
      return (
        ue(k, () => {
          if (!e.hideSelected && k.value && u.value.length) {
            const K = y.value.findIndex((se) =>
              u.value.some((de) => (e.valueComparator || kt)(de.value, se.value))
            )
            Ne &&
              !e.noAutoScroll &&
              window.requestAnimationFrame(() => {
                K >= 0 && i.value?.scrollToIndex(K)
              })
          }
        }),
        ue(r, (K, se) => {
          k.value || (g.value && e.hideNoData && !se.length && K.length && (k.value = !0))
        }),
        ne(() => {
          const K = !!(e.chips || n.chip),
            se = !!(
              !e.hideNoData ||
              y.value.length ||
              n['prepend-item'] ||
              n['append-item'] ||
              n['no-data']
            ),
            de = u.value.length > 0,
            ye = ia.filterProps(e),
            L = de || (!g.value && e.label && !e.persistentPlaceholder) ? void 0 : e.placeholder
          return w(
            ia,
            Z({ ref: l }, ye, {
              modelValue: u.value.map((q) => q.props.value).join(', '),
              'onUpdate:modelValue': Y,
              focused: g.value,
              'onUpdate:focused': (q) => (g.value = q),
              validationValue: u.externalValue,
              counterValue: d.value,
              dirty: de,
              class: [
                'v-select',
                {
                  'v-select--active-menu': k.value,
                  'v-select--chips': !!e.chips,
                  [`v-select--${e.multiple ? 'multiple' : 'single'}`]: !0,
                  'v-select--selected': u.value.length,
                  'v-select--selection-slot': !!n.selection,
                },
                e.class,
              ],
              style: e.style,
              inputmode: 'none',
              placeholder: L,
              'onClick:clear': M,
              'onMousedown:control': F,
              onBlur: H,
              onKeydown: W,
              'aria-expanded': P.value,
              'aria-controls': A.value,
              'aria-label': D.value,
              title: D.value,
            }),
            {
              ...n,
              default: () =>
                x(he, null, [
                  w(
                    Kl,
                    Z(
                      {
                        id: _.value,
                        ref: o,
                        modelValue: k.value,
                        'onUpdate:modelValue': (q) => (k.value = q),
                        activator: 'parent',
                        contentClass: 'v-select__content',
                        disabled: p.value,
                        eager: e.eager,
                        maxHeight: 310,
                        openOnClick: !1,
                        closeOnContentClick: !1,
                        transition: e.transition,
                        onAfterEnter: O,
                        onAfterLeave: j,
                      },
                      E.value
                    ),
                    {
                      default: () => [
                        se &&
                          w(
                            Ul,
                            Z(
                              {
                                ref: R,
                                selected: v.value,
                                selectStrategy: e.multiple ? 'independent' : 'single-independent',
                                onMousedown: (q) => q.preventDefault(),
                                onKeydown: G,
                                onFocusin: U,
                                tabindex: '-1',
                                selectable: !0,
                                'aria-live': 'polite',
                                'aria-label': `${e.label}-list`,
                                color: e.itemColor ?? e.color,
                              },
                              V,
                              e.listProps
                            ),
                            {
                              default: () => [
                                n['prepend-item']?.(),
                                !y.value.length &&
                                  !e.hideNoData &&
                                  (n['no-data']?.() ??
                                    w(_n, { key: 'no-data', title: a(e.noDataText) }, null)),
                                w(
                                  Ur,
                                  { ref: i, renderless: !0, items: y.value, itemKey: 'value' },
                                  {
                                    default: (q) => {
                                      let { item: le, index: ie, itemRef: Ce } = q
                                      const pe = r1(le.props),
                                        I = Z(le.props, {
                                          ref: Ce,
                                          key: le.value,
                                          onClick: () => te(le, null),
                                        })
                                      return le.type === 'divider'
                                        ? (n.divider?.({ props: le.raw, index: ie }) ??
                                            w(rn, Z(le.props, { key: `divider-${ie}` }), null))
                                        : le.type === 'subheader'
                                          ? (n.subheader?.({ props: le.raw, index: ie }) ??
                                            w(ao, Z(le.props, { key: `subheader-${ie}` }), null))
                                          : (n.item?.({ item: le, index: ie, props: I }) ??
                                            w(_n, Z(I, { role: 'option' }), {
                                              prepend: (T) => {
                                                let { isSelected: z } = T
                                                return x(he, null, [
                                                  e.multiple && !e.hideSelected
                                                    ? w(
                                                        Fn,
                                                        {
                                                          key: le.value,
                                                          modelValue: z,
                                                          ripple: !1,
                                                          tabindex: '-1',
                                                        },
                                                        null
                                                      )
                                                    : void 0,
                                                  pe.prependAvatar &&
                                                    w(sn, { image: pe.prependAvatar }, null),
                                                  pe.prependIcon &&
                                                    w(Le, { icon: pe.prependIcon }, null),
                                                ])
                                              },
                                            }))
                                    },
                                  }
                                ),
                                n['append-item']?.(),
                              ],
                            }
                          ),
                      ],
                    }
                  ),
                  u.value.map((q, le) => {
                    function ie(T) {
                      ;(T.stopPropagation(), T.preventDefault(), te(q, !1))
                    }
                    const Ce = {
                        'onClick:close': ie,
                        onKeydown(T) {
                          ;(T.key !== 'Enter' && T.key !== ' ') ||
                            (T.preventDefault(), T.stopPropagation(), ie(T))
                        },
                        onMousedown(T) {
                          ;(T.preventDefault(), T.stopPropagation())
                        },
                        modelValue: !0,
                        'onUpdate:modelValue': void 0,
                      },
                      pe = K ? !!n.chip : !!n.selection,
                      I = pe
                        ? Br(
                            K
                              ? n.chip({ item: q, index: le, props: Ce })
                              : n.selection({ item: q, index: le })
                          )
                        : void 0
                    if (!(pe && !I))
                      return x('div', { key: q.value, class: 'v-select__selection' }, [
                        K
                          ? n.chip
                            ? w(
                                Ae,
                                {
                                  key: 'chip-defaults',
                                  defaults: {
                                    VChip: {
                                      closable: e.closableChips,
                                      size: 'small',
                                      text: q.title,
                                    },
                                  },
                                },
                                { default: () => [I] }
                              )
                            : w(
                                no,
                                Z(
                                  {
                                    key: 'chip',
                                    closable: e.closableChips,
                                    size: 'small',
                                    text: q.title,
                                    disabled: q.props.disabled,
                                  },
                                  Ce
                                ),
                                null
                              )
                          : (I ??
                            x('span', { class: 'v-select__selection-text' }, [
                              q.title,
                              e.multiple &&
                                le < u.value.length - 1 &&
                                x('span', { class: 'v-select__selection-comma' }, [qt(',')]),
                            ])),
                      ])
                  }),
                ]),
              'append-inner': function () {
                for (var q = arguments.length, le = new Array(q), ie = 0; ie < q; ie++)
                  le[ie] = arguments[ie]
                return x(he, null, [
                  n['append-inner']?.(...le),
                  e.menuIcon
                    ? w(
                        Le,
                        {
                          class: 'v-select__menu-icon',
                          color: l.value?.fieldIconColor,
                          icon: e.menuIcon,
                        },
                        null
                      )
                    : void 0,
                ])
              },
            }
          )
        }),
        _t({ isFocused: g, menu: k, select: te }, l)
      )
    },
  }),
  hT = (e, t, n) => {
    if (e == null || t == null) return -1
    if (!t.length) return 0
    ;((e = e.toString().toLocaleLowerCase()), (t = t.toString().toLocaleLowerCase()))
    const a = []
    let l = e.indexOf(t)
    for (; ~l; ) (a.push([l, l + t.length]), (l = e.indexOf(t, l + t.length)))
    return a.length ? a : -1
  }
function Fs(e, t) {
  if (!(e == null || typeof e == 'boolean' || e === -1))
    return typeof e == 'number' ? [[e, e + t.length]] : Array.isArray(e[0]) ? e : [e]
}
const lo = $(
  {
    customFilter: Function,
    customKeyFilter: Object,
    filterKeys: [Array, String],
    filterMode: { type: String, default: 'intersection' },
    noFilter: Boolean,
  },
  'filter'
)
function gT(e, t, n) {
  const a = [],
    l = n?.default ?? hT,
    o = n?.filterKeys ? nt(n.filterKeys) : !1,
    i = Object.keys(n?.customKeyFilter ?? {}).length
  if (!e?.length) return a
  let r = null
  e: for (let s = 0; s < e.length; s++) {
    const [c, u = c] = nt(e[s]),
      d = {},
      f = {}
    let v = -1
    if ((t || i > 0) && !n?.noFilter) {
      let g = !1
      if (typeof c == 'object') {
        if (c.type === 'divider' || c.type === 'subheader') {
          ;(r?.type === 'divider' && c.type === 'subheader' && a.push(r),
            (r = { index: s, matches: {}, type: c.type }))
          continue
        }
        const b = o || Object.keys(u)
        g = b.length === i
        for (const y of b) {
          const p = st(u, y),
            S = n?.customKeyFilter?.[y]
          if (((v = S ? S(p, t, c) : l(p, t, c)), v !== -1 && v !== !1))
            S ? (d[y] = Fs(v, t)) : (f[y] = Fs(v, t))
          else if (n?.filterMode === 'every') continue e
        }
      } else ((v = l(c, t, c)), v !== -1 && v !== !1 && (f.title = Fs(v, t)))
      const h = Object.keys(f).length,
        m = Object.keys(d).length
      if (
        (!h && !m) ||
        (n?.filterMode === 'union' && m !== i && !h) ||
        (n?.filterMode === 'intersection' && (m !== i || (!h && i > 0 && !g)))
      )
        continue
    }
    ;(r && (a.push(r), (r = null)), a.push({ index: s, matches: { ...f, ...d } }))
  }
  return a
}
function oo(e, t, n, a) {
  const l = oe([]),
    o = oe(new Map()),
    i = C(() => (a?.transform ? Ke(t).map((s) => [s, a.transform(s)]) : Ke(t)))
  qe(() => {
    const s = typeof n == 'function' ? n() : Ke(n),
      c = typeof s != 'string' && typeof s != 'number' ? '' : String(s),
      u = gT(i.value, c, {
        customKeyFilter: { ...e.customKeyFilter, ...Ke(a?.customKeyFilter) },
        default: e.customFilter,
        filterKeys: e.filterKeys,
        filterMode: e.filterMode,
        noFilter: e.noFilter,
      }),
      d = Ke(t),
      f = [],
      v = new Map()
    ;(u.forEach((g) => {
      let { index: h, matches: m } = g
      const b = d[h]
      ;(f.push(b), v.set(b.value, m))
    }),
      (l.value = f),
      (o.value = v))
  })
  function r(s) {
    return o.value.get(s.value)
  }
  return { filteredItems: l, filteredMatches: o, getMatches: r }
}
function Nb(e, t, n) {
  return n == null || !n.length
    ? t
    : n.map((a, l) => {
        const o = l === 0 ? 0 : n[l - 1][1],
          i = [
            x('span', { class: ee(`${e}__unmask`) }, [t.slice(o, a[0])]),
            x('span', { class: ee(`${e}__mask`) }, [t.slice(a[0], a[1])]),
          ]
        return (
          l === n.length - 1 && i.push(x('span', { class: ee(`${e}__unmask`) }, [t.slice(a[1])])),
          x(he, null, [i])
        )
      })
}
const yT = $(
    {
      autoSelectFirst: { type: [Boolean, String] },
      clearOnSelect: Boolean,
      search: String,
      ...lo({ filterKeys: ['title'] }),
      ..._d(),
      ...je(vi({ modelValue: null, role: 'combobox' }), [
        'validationValue',
        'dirty',
        'appendInnerIcon',
      ]),
      ...Vn({ transition: !1 }),
    },
    'VAutocomplete'
  ),
  bT = J()({
    name: 'VAutocomplete',
    props: yT(),
    emits: {
      'update:focused': (e) => !0,
      'update:search': (e) => !0,
      'update:modelValue': (e) => !0,
      'update:menu': (e) => !0,
    },
    setup(e, t) {
      let { slots: n } = t
      const { t: a } = ze(),
        l = ae(),
        o = oe(!1),
        i = oe(!0),
        r = oe(!1),
        s = ae(),
        c = ae(),
        u = oe(-1),
        { items: d, transformIn: f, transformOut: v } = gd(e),
        { textColorClasses: g, textColorStyles: h } = Vt(() => l.value?.color),
        m = we(e, 'search', ''),
        b = we(
          e,
          'modelValue',
          [],
          (I) => f(I === null ? [null] : nt(I)),
          (I) => {
            const T = v(I)
            return e.multiple ? T : (T[0] ?? null)
          }
        ),
        y = C(() =>
          typeof e.counterValue == 'function'
            ? e.counterValue(b.value)
            : typeof e.counterValue == 'number'
              ? e.counterValue
              : b.value.length
        ),
        p = to(e),
        { filteredItems: S, getMatches: k } = oo(e, d, () => (i.value ? '' : m.value)),
        _ = C(() =>
          e.hideSelected
            ? S.value.filter((I) => !b.value.some((T) => T.value === I.value))
            : S.value
        ),
        P = C(() => !!(e.chips || n.chip)),
        A = C(() => P.value || !!n.selection),
        D = C(() => b.value.map((I) => I.props.value)),
        E = C(
          () =>
            (e.autoSelectFirst === !0 ||
              (e.autoSelectFirst === 'exact' && m.value === _.value[0]?.title)) &&
            _.value.length > 0 &&
            !i.value &&
            !r.value
        ),
        R = C(() => (e.hideNoData && !_.value.length) || p.isReadonly.value || p.isDisabled.value),
        V = we(e, 'menu'),
        M = C({
          get: () => V.value,
          set: (I) => {
            ;(V.value && !I && s.value?.ΨopenChildren.size) || (I && R.value) || (V.value = I)
          },
        }),
        { menuId: F, ariaExpanded: G, ariaControls: W, ariaLabel: te } = xd(e, M),
        H = ae(),
        O = Cd(H, l)
      function j(I) {
        ;(e.openOnClear && (M.value = !0), (m.value = ''))
      }
      function U() {
        R.value || (M.value = !0)
      }
      function Y(I) {
        R.value || (o.value && (I.preventDefault(), I.stopPropagation()), (M.value = !M.value))
      }
      function K(I) {
        ;(jl(I) || I.key === 'Backspace') && l.value?.focus()
      }
      function se(I) {
        if (p.isReadonly.value) return
        const T = l.value?.selectionStart,
          z = b.value.length
        if (
          (['Enter', 'ArrowDown', 'ArrowUp'].includes(I.key) && I.preventDefault(),
          ['Enter', 'ArrowDown'].includes(I.key) && (M.value = !0),
          ['Escape'].includes(I.key) && (M.value = !1),
          E.value &&
            ['Enter', 'Tab'].includes(I.key) &&
            !b.value.some((X) => {
              let { value: N } = X
              return N === _.value[0].value
            }) &&
            pe(_.value[0]),
          I.key === 'ArrowDown' && E.value && H.value?.focus('next'),
          ['Backspace', 'Delete'].includes(I.key))
        ) {
          if (!e.multiple && A.value && b.value.length > 0 && !m.value) return pe(b.value[0], !1)
          if (~u.value) {
            I.preventDefault()
            const X = u.value
            ;(pe(b.value[u.value], !1), (u.value = X >= z - 1 ? z - 2 : X))
          } else I.key === 'Backspace' && !m.value && (u.value = z - 1)
          return
        }
        if (e.multiple)
          if (I.key === 'ArrowLeft') {
            if (u.value < 0 && T && T > 0) return
            const X = u.value > -1 ? u.value - 1 : z - 1
            if (b.value[X]) u.value = X
            else {
              const N = m.value?.length ?? null
              ;((u.value = -1), l.value?.setSelectionRange(N, N))
            }
          } else if (I.key === 'ArrowRight') {
            if (u.value < 0) return
            const X = u.value + 1
            b.value[X] ? (u.value = X) : ((u.value = -1), l.value?.setSelectionRange(0, 0))
          } else ~u.value && jl(I) && (u.value = -1)
      }
      function de(I) {
        if (Hl(l.value, ':autofill') || Hl(l.value, ':-webkit-autofill')) {
          const T = d.value.find((z) => z.title === I.target.value)
          T && pe(T)
        }
      }
      function ye() {
        e.eager && c.value?.calculateVisibleItems()
      }
      function L() {
        o.value && ((i.value = !0), l.value?.focus())
      }
      function q(I) {
        ;((o.value = !0),
          setTimeout(() => {
            r.value = !0
          }))
      }
      function le(I) {
        r.value = !1
      }
      function ie(I) {
        ;(I == null || (I === '' && !e.multiple && !A.value)) && (b.value = [])
      }
      const Ce = oe(!1)
      function pe(I) {
        let T = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
        if (!(!I || I.props.disabled))
          if (e.multiple) {
            const z = b.value.findIndex((N) => (e.valueComparator || kt)(N.value, I.value)),
              X = T ?? !~z
            if (~z) {
              const N = X ? [...b.value, I] : [...b.value]
              ;(N.splice(z, 1), (b.value = N))
            } else X && (b.value = [...b.value, I])
            e.clearOnSelect && (m.value = '')
          } else {
            const z = T !== !1
            ;((b.value = z ? [I] : []),
              (m.value = z && !A.value ? I.title : ''),
              Re(() => {
                ;((M.value = !1), (i.value = !0))
              }))
          }
      }
      return (
        ue(o, (I, T) => {
          I !== T &&
            (I
              ? ((Ce.value = !0),
                (m.value = e.multiple || A.value ? '' : String(b.value.at(-1)?.props.title ?? '')),
                (i.value = !0),
                Re(() => (Ce.value = !1)))
              : (!e.multiple && m.value == null && (b.value = []),
                (M.value = !1),
                (m.value = ''),
                (u.value = -1)))
        }),
        ue(m, (I) => {
          !o.value || Ce.value || (I && (M.value = !0), (i.value = !I))
        }),
        ue(M, () => {
          if (!e.hideSelected && M.value && b.value.length) {
            const I = _.value.findIndex((T) => b.value.some((z) => T.value === z.value))
            Ne &&
              window.requestAnimationFrame(() => {
                I >= 0 && c.value?.scrollToIndex(I)
              })
          }
        }),
        ue(d, (I, T) => {
          M.value || (o.value && !T.length && I.length && (M.value = !0))
        }),
        ne(() => {
          const I = !!(
              !e.hideNoData ||
              _.value.length ||
              n['prepend-item'] ||
              n['append-item'] ||
              n['no-data']
            ),
            T = b.value.length > 0,
            z = ia.filterProps(e)
          return w(
            ia,
            Z({ ref: l }, z, {
              modelValue: m.value,
              'onUpdate:modelValue': [(X) => (m.value = X), ie],
              focused: o.value,
              'onUpdate:focused': (X) => (o.value = X),
              validationValue: b.externalValue,
              counterValue: y.value,
              dirty: T,
              onChange: de,
              class: [
                'v-autocomplete',
                `v-autocomplete--${e.multiple ? 'multiple' : 'single'}`,
                {
                  'v-autocomplete--active-menu': M.value,
                  'v-autocomplete--chips': !!e.chips,
                  'v-autocomplete--selection-slot': !!A.value,
                  'v-autocomplete--selecting-index': u.value > -1,
                },
                e.class,
              ],
              style: e.style,
              readonly: p.isReadonly.value,
              placeholder: T ? void 0 : e.placeholder,
              'onClick:clear': j,
              'onMousedown:control': U,
              onKeydown: se,
              'aria-expanded': G.value,
              'aria-controls': W.value,
            }),
            {
              ...n,
              default: () =>
                x(he, null, [
                  w(
                    Kl,
                    Z(
                      {
                        id: F.value,
                        ref: s,
                        modelValue: M.value,
                        'onUpdate:modelValue': (X) => (M.value = X),
                        activator: 'parent',
                        contentClass: 'v-autocomplete__content',
                        disabled: R.value,
                        eager: e.eager,
                        maxHeight: 310,
                        openOnClick: !1,
                        closeOnContentClick: !1,
                        transition: e.transition,
                        onAfterEnter: ye,
                        onAfterLeave: L,
                      },
                      e.menuProps
                    ),
                    {
                      default: () => [
                        I &&
                          w(
                            Ul,
                            Z(
                              {
                                ref: H,
                                filterable: !0,
                                selected: D.value,
                                selectStrategy: e.multiple ? 'independent' : 'single-independent',
                                onMousedown: (X) => X.preventDefault(),
                                onKeydown: K,
                                onFocusin: q,
                                onFocusout: le,
                                tabindex: '-1',
                                selectable: !0,
                                'aria-live': 'polite',
                                color: e.itemColor ?? e.color,
                              },
                              O,
                              e.listProps
                            ),
                            {
                              default: () => [
                                n['prepend-item']?.(),
                                !_.value.length &&
                                  !e.hideNoData &&
                                  (n['no-data']?.() ??
                                    w(_n, { key: 'no-data', title: a(e.noDataText) }, null)),
                                w(
                                  Ur,
                                  { ref: c, renderless: !0, items: _.value, itemKey: 'value' },
                                  {
                                    default: (X) => {
                                      let { item: N, index: Q, itemRef: ve } = X
                                      const ge = Z(N.props, {
                                        ref: ve,
                                        key: N.value,
                                        active: E.value && Q === 0 ? !0 : void 0,
                                        onClick: () => pe(N, null),
                                      })
                                      return N.type === 'divider'
                                        ? (n.divider?.({ props: N.raw, index: Q }) ??
                                            w(rn, Z(N.props, { key: `divider-${Q}` }), null))
                                        : N.type === 'subheader'
                                          ? (n.subheader?.({ props: N.raw, index: Q }) ??
                                            w(ao, Z(N.props, { key: `subheader-${Q}` }), null))
                                          : (n.item?.({ item: N, index: Q, props: ge }) ??
                                            w(_n, Z(ge, { role: 'option' }), {
                                              prepend: (me) => {
                                                let { isSelected: re } = me
                                                return x(he, null, [
                                                  e.multiple && !e.hideSelected
                                                    ? w(
                                                        Fn,
                                                        {
                                                          key: N.value,
                                                          modelValue: re,
                                                          ripple: !1,
                                                          tabindex: '-1',
                                                        },
                                                        null
                                                      )
                                                    : void 0,
                                                  N.props.prependAvatar &&
                                                    w(sn, { image: N.props.prependAvatar }, null),
                                                  N.props.prependIcon &&
                                                    w(Le, { icon: N.props.prependIcon }, null),
                                                ])
                                              },
                                              title: () =>
                                                i.value
                                                  ? N.title
                                                  : Nb('v-autocomplete', N.title, k(N)?.title),
                                            }))
                                    },
                                  }
                                ),
                                n['append-item']?.(),
                              ],
                            }
                          ),
                      ],
                    }
                  ),
                  b.value.map((X, N) => {
                    function Q(re) {
                      ;(re.stopPropagation(), re.preventDefault(), pe(X, !1))
                    }
                    const ve = {
                        'onClick:close': Q,
                        onKeydown(re) {
                          ;(re.key !== 'Enter' && re.key !== ' ') ||
                            (re.preventDefault(), re.stopPropagation(), Q(re))
                        },
                        onMousedown(re) {
                          ;(re.preventDefault(), re.stopPropagation())
                        },
                        modelValue: !0,
                        'onUpdate:modelValue': void 0,
                      },
                      ge = P.value ? !!n.chip : !!n.selection,
                      me = ge
                        ? Br(
                            P.value
                              ? n.chip({ item: X, index: N, props: ve })
                              : n.selection({ item: X, index: N })
                          )
                        : void 0
                    if (!(ge && !me))
                      return x(
                        'div',
                        {
                          key: X.value,
                          class: ee([
                            'v-autocomplete__selection',
                            N === u.value && ['v-autocomplete__selection--selected', g.value],
                          ]),
                          style: ce(N === u.value ? h.value : {}),
                        },
                        [
                          P.value
                            ? n.chip
                              ? w(
                                  Ae,
                                  {
                                    key: 'chip-defaults',
                                    defaults: {
                                      VChip: {
                                        closable: e.closableChips,
                                        size: 'small',
                                        text: X.title,
                                      },
                                    },
                                  },
                                  { default: () => [me] }
                                )
                              : w(
                                  no,
                                  Z(
                                    {
                                      key: 'chip',
                                      closable: e.closableChips,
                                      size: 'small',
                                      text: X.title,
                                      disabled: X.props.disabled,
                                    },
                                    ve
                                  ),
                                  null
                                )
                            : (me ??
                              x('span', { class: 'v-autocomplete__selection-text' }, [
                                X.title,
                                e.multiple &&
                                  N < b.value.length - 1 &&
                                  x('span', { class: 'v-autocomplete__selection-comma' }, [
                                    qt(','),
                                  ]),
                              ])),
                        ]
                      )
                  }),
                ]),
              'append-inner': function () {
                for (var X = arguments.length, N = new Array(X), Q = 0; Q < X; Q++)
                  N[Q] = arguments[Q]
                return x(he, null, [
                  n['append-inner']?.(...N),
                  e.menuIcon
                    ? w(
                        Le,
                        {
                          class: 'v-autocomplete__menu-icon',
                          color: l.value?.fieldIconColor,
                          icon: e.menuIcon,
                          onMousedown: Y,
                          onClick: ay,
                          'aria-label': te.value,
                          title: te.value,
                          tabindex: '-1',
                        },
                        null
                      )
                    : void 0,
                ])
              },
            }
          )
        }),
        _t({ isFocused: o, isPristine: i, menu: M, search: m, filteredItems: S, select: pe }, l)
      )
    },
  }),
  pT = $(
    {
      bordered: Boolean,
      color: String,
      content: [Number, String],
      dot: Boolean,
      floating: Boolean,
      icon: Se,
      inline: Boolean,
      label: { type: String, default: '$vuetify.badge' },
      max: [Number, String],
      modelValue: { type: Boolean, default: !0 },
      offsetX: [Number, String],
      offsetY: [Number, String],
      textColor: String,
      ...be(),
      ...fa({ location: 'top end' }),
      ...Je(),
      ...Ie(),
      ...Be(),
      ...Vn({ transition: 'scale-rotate-transition' }),
      ...ft(),
    },
    'VBadge'
  ),
  ST = J()({
    name: 'VBadge',
    inheritAttrs: !1,
    props: pT(),
    setup(e, t) {
      const { backgroundColorClasses: n, backgroundColorStyles: a } = He(() => e.color),
        { roundedClasses: l } = ot(e),
        { t: o } = ze(),
        { textColorClasses: i, textColorStyles: r } = Vt(() => e.textColor),
        { themeClasses: s } = ld(),
        { locationStyles: c } = vl(
          e,
          !0,
          (d) =>
            (e.floating ? (e.dot ? 2 : 4) : e.dot ? 8 : 12) +
            (['top', 'bottom'].includes(d)
              ? Number(e.offsetY ?? 0)
              : ['left', 'right'].includes(d)
                ? Number(e.offsetX ?? 0)
                : 0)
        ),
        { dimensionStyles: u } = vt(e)
      return (
        ne(() => {
          const d = Number(e.content),
            f = !e.max || isNaN(d) ? e.content : d <= Number(e.max) ? d : `${e.max}+`,
            [v, g] = wu(t.attrs, ['aria-atomic', 'aria-label', 'aria-live', 'role', 'title'])
          return w(
            e.tag,
            Z(
              {
                class: [
                  'v-badge',
                  {
                    'v-badge--bordered': e.bordered,
                    'v-badge--dot': e.dot,
                    'v-badge--floating': e.floating,
                    'v-badge--inline': e.inline,
                  },
                  e.class,
                ],
              },
              g,
              { style: e.style }
            ),
            {
              default: () => [
                x('div', { class: 'v-badge__wrapper' }, [
                  t.slots.default?.(),
                  w(
                    $t,
                    { transition: e.transition },
                    {
                      default: () => [
                        tt(
                          x(
                            'span',
                            Z(
                              {
                                class: ['v-badge__badge', s.value, n.value, l.value, i.value],
                                style: [a.value, r.value, u.value, e.inline ? {} : c.value],
                                'aria-atomic': 'true',
                                'aria-label': o(e.label, d),
                                'aria-live': 'polite',
                                role: 'status',
                              },
                              v
                            ),
                            [
                              e.dot
                                ? void 0
                                : t.slots.badge
                                  ? t.slots.badge?.()
                                  : e.icon
                                    ? w(Le, { icon: e.icon }, null)
                                    : f,
                            ]
                          ),
                          [[Pn, e.modelValue]]
                        ),
                      ],
                    }
                  ),
                ]),
              ],
            }
          )
        }),
        {}
      )
    },
  }),
  wT = $({ color: String, density: String, ...be() }, 'VBannerActions'),
  Hb = J()({
    name: 'VBannerActions',
    props: wT(),
    setup(e, t) {
      let { slots: n } = t
      return (
        lt({ VBtn: { color: e.color, density: e.density, slim: !0, variant: 'text' } }),
        ne(() =>
          x('div', { class: ee(['v-banner-actions', e.class]), style: ce(e.style) }, [
            n.default?.(),
          ])
        ),
        {}
      )
    },
  }),
  jb = da('v-banner-text'),
  kT = $(
    {
      avatar: String,
      bgColor: String,
      color: String,
      icon: Se,
      lines: String,
      stacked: Boolean,
      sticky: Boolean,
      text: String,
      ...Ut(),
      ...be(),
      ...St(),
      ...ft(),
      ...ol({ mobile: null }),
      ...yt(),
      ...fa(),
      ...Jl(),
      ...Je(),
      ...Ie(),
      ...Be(),
    },
    'VBanner'
  ),
  CT = J()({
    name: 'VBanner',
    props: kT(),
    setup(e, t) {
      let { slots: n } = t
      const { backgroundColorClasses: a, backgroundColorStyles: l } = He(() => e.bgColor),
        { borderClasses: o } = Jt(e),
        { densityClasses: i } = Ht(e),
        { displayClasses: r, mobile: s } = gn(e),
        { dimensionStyles: c } = vt(e),
        { elevationClasses: u } = xt(e),
        { locationStyles: d } = vl(e),
        { positionClasses: f } = Ql(e),
        { roundedClasses: v } = ot(e),
        { themeClasses: g } = $e(e),
        h = B(() => e.color),
        m = B(() => e.density)
      ;(lt({ VBannerActions: { color: h, density: m } }),
        ne(() => {
          const b = !!(e.text || n.text),
            y = !!(e.avatar || e.icon),
            p = !!(y || n.prepend)
          return w(
            e.tag,
            {
              class: ee([
                'v-banner',
                {
                  'v-banner--stacked': e.stacked || s.value,
                  'v-banner--sticky': e.sticky,
                  [`v-banner--${e.lines}-line`]: !!e.lines,
                },
                g.value,
                a.value,
                o.value,
                i.value,
                r.value,
                u.value,
                f.value,
                v.value,
                e.class,
              ]),
              style: ce([l.value, c.value, d.value, e.style]),
              role: 'banner',
            },
            {
              default: () => [
                p &&
                  x('div', { key: 'prepend', class: 'v-banner__prepend' }, [
                    n.prepend
                      ? w(
                          Ae,
                          {
                            key: 'prepend-defaults',
                            disabled: !y,
                            defaults: {
                              VAvatar: {
                                color: h.value,
                                density: m.value,
                                icon: e.icon,
                                image: e.avatar,
                              },
                            },
                          },
                          n.prepend
                        )
                      : w(
                          sn,
                          {
                            key: 'prepend-avatar',
                            color: h.value,
                            density: m.value,
                            icon: e.icon,
                            image: e.avatar,
                          },
                          null
                        ),
                  ]),
                x('div', { class: 'v-banner__content' }, [
                  b && w(jb, { key: 'text' }, { default: () => [n.text?.() ?? e.text] }),
                  n.default?.(),
                ]),
                n.actions && w(Hb, { key: 'actions' }, n.actions),
              ],
            }
          )
        }))
    },
  }),
  xT = $(
    {
      baseColor: String,
      bgColor: String,
      color: String,
      grow: Boolean,
      mode: { type: String, validator: (e) => !e || ['horizontal', 'shift'].includes(e) },
      height: { type: [Number, String], default: 56 },
      active: { type: Boolean, default: !0 },
      ...Ut(),
      ...be(),
      ...St(),
      ...yt(),
      ...Je(),
      ...il({ name: 'bottom-navigation' }),
      ...Ie({ tag: 'header' }),
      ...cl({ selectedClass: 'v-btn--selected' }),
      ...Be(),
    },
    'VBottomNavigation'
  ),
  _T = J()({
    name: 'VBottomNavigation',
    props: xT(),
    emits: { 'update:active': (e) => !0, 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: a } = ld(),
        { borderClasses: l } = Jt(e),
        { backgroundColorClasses: o, backgroundColorStyles: i } = He(() => e.bgColor),
        { densityClasses: r } = Ht(e),
        { elevationClasses: s } = xt(e),
        { roundedClasses: c } = ot(e),
        { ssrBootStyles: u } = sl(),
        d = C(
          () =>
            Number(e.height) -
            (e.density === 'comfortable' ? 8 : 0) -
            (e.density === 'compact' ? 16 : 0)
        ),
        f = we(e, 'active', e.active),
        { layoutItemStyles: v } = rl({
          id: e.name,
          order: C(() => parseInt(e.order, 10)),
          position: B(() => 'bottom'),
          layoutSize: B(() => (f.value ? d.value : 0)),
          elementSize: d,
          active: f,
          absolute: B(() => e.absolute),
        })
      return (
        Aa(e, dd),
        lt(
          {
            VBtn: {
              baseColor: B(() => e.baseColor),
              color: B(() => e.color),
              density: B(() => e.density),
              stacked: B(() => e.mode !== 'horizontal'),
              variant: 'text',
            },
          },
          { scoped: !0 }
        ),
        ne(() =>
          w(
            e.tag,
            {
              class: ee([
                'v-bottom-navigation',
                {
                  'v-bottom-navigation--active': f.value,
                  'v-bottom-navigation--grow': e.grow,
                  'v-bottom-navigation--shift': e.mode === 'shift',
                },
                a.value,
                o.value,
                l.value,
                r.value,
                s.value,
                c.value,
                e.class,
              ]),
              style: ce([i.value, v.value, { height: fe(d.value) }, u.value, e.style]),
            },
            {
              default: () => [
                n.default && x('div', { class: 'v-bottom-navigation__content' }, [n.default()]),
              ],
            }
          )
        ),
        {}
      )
    },
  }),
  zb = $(
    {
      fullscreen: Boolean,
      retainFocus: { type: Boolean, default: !0 },
      scrollable: Boolean,
      ...di({
        origin: 'center center',
        scrollStrategy: 'block',
        transition: { component: $r },
        zIndex: 2400,
      }),
    },
    'VDialog'
  ),
  Hu = J()({
    name: 'VDialog',
    props: zb(),
    emits: { 'update:modelValue': (e) => !0, afterEnter: () => !0, afterLeave: () => !0 },
    setup(e, t) {
      let { emit: n, slots: a } = t
      const l = we(e, 'modelValue'),
        { scopeId: o } = ml(),
        i = ae()
      function r(u) {
        const d = u.relatedTarget,
          f = u.target
        if (
          d !== f &&
          i.value?.contentEl &&
          i.value?.globalTop &&
          ![document, i.value.contentEl].includes(f) &&
          !i.value.contentEl.contains(f)
        ) {
          const v = Ro(i.value.contentEl)
          if (!v.length) return
          const g = v[0],
            h = v[v.length - 1]
          d === g ? h.focus() : g.focus()
        }
      }
      ;(dt(() => {
        document.removeEventListener('focusin', r)
      }),
        Ne &&
          ue(
            () => l.value && e.retainFocus,
            (u) => {
              u
                ? document.addEventListener('focusin', r)
                : document.removeEventListener('focusin', r)
            },
            { immediate: !0 }
          ))
      function s() {
        ;(n('afterEnter'),
          (e.scrim || e.retainFocus) &&
            i.value?.contentEl &&
            !i.value.contentEl.contains(document.activeElement) &&
            i.value.contentEl.focus({ preventScroll: !0 }))
      }
      function c() {
        n('afterLeave')
      }
      return (
        ue(l, async (u) => {
          u || (await Re(), i.value.activatorEl?.focus({ preventScroll: !0 }))
        }),
        ne(() => {
          const u = Nn.filterProps(e),
            d = Z({ 'aria-haspopup': 'dialog' }, e.activatorProps),
            f = Z({ tabindex: -1 }, e.contentProps)
          return w(
            Nn,
            Z(
              {
                ref: i,
                class: [
                  'v-dialog',
                  { 'v-dialog--fullscreen': e.fullscreen, 'v-dialog--scrollable': e.scrollable },
                  e.class,
                ],
                style: e.style,
              },
              u,
              {
                modelValue: l.value,
                'onUpdate:modelValue': (v) => (l.value = v),
                'aria-modal': 'true',
                activatorProps: d,
                contentProps: f,
                height: e.fullscreen ? void 0 : e.height,
                width: e.fullscreen ? void 0 : e.width,
                maxHeight: e.fullscreen ? void 0 : e.maxHeight,
                maxWidth: e.fullscreen ? void 0 : e.maxWidth,
                role: 'dialog',
                onAfterEnter: s,
                onAfterLeave: c,
              },
              o
            ),
            {
              activator: a.activator,
              default: function () {
                for (var v = arguments.length, g = new Array(v), h = 0; h < v; h++)
                  g[h] = arguments[h]
                return w(Ae, { root: 'VDialog' }, { default: () => [a.default?.(...g)] })
              },
            }
          )
        }),
        _t({}, i)
      )
    },
  }),
  PT = $({ inset: Boolean, ...zb({ transition: 'bottom-sheet-transition' }) }, 'VBottomSheet'),
  VT = J()({
    name: 'VBottomSheet',
    props: PT(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = we(e, 'modelValue')
      return (
        ne(() => {
          const l = Hu.filterProps(e)
          return w(
            Hu,
            Z(l, {
              contentClass: ['v-bottom-sheet__content', e.contentClass],
              modelValue: a.value,
              'onUpdate:modelValue': (o) => (a.value = o),
              class: ['v-bottom-sheet', { 'v-bottom-sheet--inset': e.inset }, e.class],
              style: e.style,
            }),
            n
          )
        }),
        {}
      )
    },
  }),
  IT = $({ divider: [Number, String], ...be() }, 'VBreadcrumbsDivider'),
  Wb = J()({
    name: 'VBreadcrumbsDivider',
    props: IT(),
    setup(e, t) {
      let { slots: n } = t
      return (
        ne(() =>
          x(
            'li',
            {
              'aria-hidden': 'true',
              class: ee(['v-breadcrumbs-divider', e.class]),
              style: ce(e.style),
            },
            [n?.default?.() ?? e.divider]
          )
        ),
        {}
      )
    },
  }),
  TT = $(
    {
      active: Boolean,
      activeClass: String,
      activeColor: String,
      color: String,
      disabled: Boolean,
      title: String,
      ...be(),
      ...ui(),
      ...Ie({ tag: 'li' }),
    },
    'VBreadcrumbsItem'
  ),
  Ub = J()({
    name: 'VBreadcrumbsItem',
    props: TT(),
    setup(e, t) {
      let { slots: n, attrs: a } = t
      const l = si(e, a),
        o = C(() => e.active || l.isActive?.value),
        { textColorClasses: i, textColorStyles: r } = Vt(() => (o.value ? e.activeColor : e.color))
      return (
        ne(() =>
          w(
            e.tag,
            {
              class: ee([
                'v-breadcrumbs-item',
                {
                  'v-breadcrumbs-item--active': o.value,
                  'v-breadcrumbs-item--disabled': e.disabled,
                  [`${e.activeClass}`]: o.value && e.activeClass,
                },
                i.value,
                e.class,
              ]),
              style: ce([r.value, e.style]),
              'aria-current': o.value ? 'page' : void 0,
            },
            {
              default: () => [
                l.isLink.value
                  ? x(
                      'a',
                      Z({ class: 'v-breadcrumbs-item--link', onClick: l.navigate }, l.linkProps),
                      [n.default?.() ?? e.title]
                    )
                  : (n.default?.() ?? e.title),
              ],
            }
          )
        ),
        {}
      )
    },
  }),
  AT = $(
    {
      activeClass: String,
      activeColor: String,
      bgColor: String,
      color: String,
      disabled: Boolean,
      divider: { type: String, default: '/' },
      icon: Se,
      items: { type: Array, default: () => [] },
      ...be(),
      ...St(),
      ...Je(),
      ...Ie({ tag: 'ul' }),
    },
    'VBreadcrumbs'
  ),
  ET = J()({
    name: 'VBreadcrumbs',
    props: AT(),
    setup(e, t) {
      let { slots: n } = t
      const { backgroundColorClasses: a, backgroundColorStyles: l } = He(() => e.bgColor),
        { densityClasses: o } = Ht(e),
        { roundedClasses: i } = ot(e)
      lt({
        VBreadcrumbsDivider: { divider: B(() => e.divider) },
        VBreadcrumbsItem: {
          activeClass: B(() => e.activeClass),
          activeColor: B(() => e.activeColor),
          color: B(() => e.color),
          disabled: B(() => e.disabled),
        },
      })
      const r = C(() =>
        e.items.map((s) =>
          typeof s == 'string' ? { item: { title: s }, raw: s } : { item: s, raw: s }
        )
      )
      return (
        ne(() => {
          const s = !!(n.prepend || e.icon)
          return w(
            e.tag,
            {
              class: ee(['v-breadcrumbs', a.value, o.value, i.value, e.class]),
              style: ce([l.value, e.style]),
            },
            {
              default: () => [
                s &&
                  x('li', { key: 'prepend', class: 'v-breadcrumbs__prepend' }, [
                    n.prepend
                      ? w(
                          Ae,
                          {
                            key: 'prepend-defaults',
                            disabled: !e.icon,
                            defaults: { VIcon: { icon: e.icon, start: !0 } },
                          },
                          n.prepend
                        )
                      : w(Le, { key: 'prepend-icon', start: !0, icon: e.icon }, null),
                  ]),
                r.value.map((c, u, d) => {
                  let { item: f, raw: v } = c
                  return x(he, null, [
                    n.item?.({ item: f, index: u }) ??
                      w(
                        Ub,
                        Z(
                          { key: u, disabled: u >= d.length - 1 },
                          typeof f == 'string' ? { title: f } : f
                        ),
                        { default: n.title ? () => n.title?.({ item: f, index: u }) : void 0 }
                      ),
                    u < d.length - 1 &&
                      w(Wb, null, {
                        default: n.divider ? () => n.divider?.({ item: v, index: u }) : void 0,
                      }),
                  ])
                }),
                n.default?.(),
              ],
            }
          )
        }),
        {}
      )
    },
  }),
  DT = $({ ...be(), ...Ie() }, 'VCardActions'),
  Kb = J()({
    name: 'VCardActions',
    props: DT(),
    setup(e, t) {
      let { slots: n } = t
      return (
        lt({ VBtn: { slim: !0, variant: 'text' } }),
        ne(() => w(e.tag, { class: ee(['v-card-actions', e.class]), style: ce(e.style) }, n)),
        {}
      )
    },
  }),
  RT = $({ opacity: [Number, String], ...be(), ...Ie() }, 'VCardSubtitle'),
  Gb = J()({
    name: 'VCardSubtitle',
    props: RT(),
    setup(e, t) {
      let { slots: n } = t
      return (
        ne(() =>
          w(
            e.tag,
            {
              class: ee(['v-card-subtitle', e.class]),
              style: ce([{ '--v-card-subtitle-opacity': e.opacity }, e.style]),
            },
            n
          )
        ),
        {}
      )
    },
  }),
  Vd = da('v-card-title'),
  MT = $(
    {
      appendAvatar: String,
      appendIcon: Se,
      prependAvatar: String,
      prependIcon: Se,
      subtitle: { type: [String, Number, Boolean], default: void 0 },
      title: { type: [String, Number, Boolean], default: void 0 },
      ...be(),
      ...St(),
      ...Ie(),
    },
    'VCardItem'
  ),
  Yb = J()({
    name: 'VCardItem',
    props: MT(),
    setup(e, t) {
      let { slots: n } = t
      return (
        ne(() => {
          const a = !!(e.prependAvatar || e.prependIcon),
            l = !!(a || n.prepend),
            o = !!(e.appendAvatar || e.appendIcon),
            i = !!(o || n.append),
            r = !!(e.title != null || n.title),
            s = !!(e.subtitle != null || n.subtitle)
          return w(
            e.tag,
            { class: ee(['v-card-item', e.class]), style: ce(e.style) },
            {
              default: () => [
                l &&
                  x('div', { key: 'prepend', class: 'v-card-item__prepend' }, [
                    n.prepend
                      ? w(
                          Ae,
                          {
                            key: 'prepend-defaults',
                            disabled: !a,
                            defaults: {
                              VAvatar: { density: e.density, image: e.prependAvatar },
                              VIcon: { density: e.density, icon: e.prependIcon },
                            },
                          },
                          n.prepend
                        )
                      : x(he, null, [
                          e.prependAvatar &&
                            w(
                              sn,
                              { key: 'prepend-avatar', density: e.density, image: e.prependAvatar },
                              null
                            ),
                          e.prependIcon &&
                            w(
                              Le,
                              { key: 'prepend-icon', density: e.density, icon: e.prependIcon },
                              null
                            ),
                        ]),
                  ]),
                x('div', { class: 'v-card-item__content' }, [
                  r && w(Vd, { key: 'title' }, { default: () => [n.title?.() ?? Bn(e.title)] }),
                  s &&
                    w(
                      Gb,
                      { key: 'subtitle' },
                      { default: () => [n.subtitle?.() ?? Bn(e.subtitle)] }
                    ),
                  n.default?.(),
                ]),
                i &&
                  x('div', { key: 'append', class: 'v-card-item__append' }, [
                    n.append
                      ? w(
                          Ae,
                          {
                            key: 'append-defaults',
                            disabled: !o,
                            defaults: {
                              VAvatar: { density: e.density, image: e.appendAvatar },
                              VIcon: { density: e.density, icon: e.appendIcon },
                            },
                          },
                          n.append
                        )
                      : x(he, null, [
                          e.appendIcon &&
                            w(
                              Le,
                              { key: 'append-icon', density: e.density, icon: e.appendIcon },
                              null
                            ),
                          e.appendAvatar &&
                            w(
                              sn,
                              { key: 'append-avatar', density: e.density, image: e.appendAvatar },
                              null
                            ),
                        ]),
                  ]),
              ],
            }
          )
        }),
        {}
      )
    },
  }),
  BT = $({ opacity: [Number, String], ...be(), ...Ie() }, 'VCardText'),
  Id = J()({
    name: 'VCardText',
    props: BT(),
    setup(e, t) {
      let { slots: n } = t
      return (
        ne(() =>
          w(
            e.tag,
            {
              class: ee(['v-card-text', e.class]),
              style: ce([{ '--v-card-text-opacity': e.opacity }, e.style]),
            },
            n
          )
        ),
        {}
      )
    },
  }),
  LT = $(
    {
      appendAvatar: String,
      appendIcon: Se,
      disabled: Boolean,
      flat: Boolean,
      hover: Boolean,
      image: String,
      link: { type: Boolean, default: void 0 },
      prependAvatar: String,
      prependIcon: Se,
      ripple: { type: [Boolean, Object], default: !0 },
      subtitle: { type: [String, Number, Boolean], default: void 0 },
      text: { type: [String, Number, Boolean], default: void 0 },
      title: { type: [String, Number, Boolean], default: void 0 },
      ...Ut(),
      ...be(),
      ...St(),
      ...ft(),
      ...yt(),
      ...Hr(),
      ...fa(),
      ...Jl(),
      ...Je(),
      ...ui(),
      ...Ie(),
      ...Be(),
      ...yn({ variant: 'elevated' }),
    },
    'VCard'
  ),
  qb = J()({
    name: 'VCard',
    directives: { vRipple: Nt },
    props: LT(),
    setup(e, t) {
      let { attrs: n, slots: a } = t
      const { themeClasses: l } = $e(e),
        { borderClasses: o } = Jt(e),
        { colorClasses: i, colorStyles: r, variantClasses: s } = ul(e),
        { densityClasses: c } = Ht(e),
        { dimensionStyles: u } = vt(e),
        { elevationClasses: d } = xt(e),
        { loaderClasses: f } = ii(e),
        { locationStyles: v } = vl(e),
        { positionClasses: g } = Ql(e),
        { roundedClasses: h } = ot(e),
        m = si(e, n)
      return (
        ne(() => {
          const b = e.link !== !1 && m.isLink.value,
            y = !e.disabled && e.link !== !1 && (e.link || m.isClickable.value),
            p = b ? 'a' : e.tag,
            S = !!(a.title || e.title != null),
            k = !!(a.subtitle || e.subtitle != null),
            _ = S || k,
            P = !!(a.append || e.appendAvatar || e.appendIcon),
            A = !!(a.prepend || e.prependAvatar || e.prependIcon),
            D = !!(a.image || e.image),
            E = _ || A || P,
            R = !!(a.text || e.text != null)
          return tt(
            w(
              p,
              Z(m.linkProps, {
                class: [
                  'v-card',
                  {
                    'v-card--disabled': e.disabled,
                    'v-card--flat': e.flat,
                    'v-card--hover': e.hover && !(e.disabled || e.flat),
                    'v-card--link': y,
                  },
                  l.value,
                  o.value,
                  i.value,
                  c.value,
                  d.value,
                  f.value,
                  g.value,
                  h.value,
                  s.value,
                  e.class,
                ],
                style: [r.value, u.value, v.value, e.style],
                onClick: y && m.navigate,
                tabindex: e.disabled ? -1 : void 0,
              }),
              {
                default: () => [
                  D &&
                    x('div', { key: 'image', class: 'v-card__image' }, [
                      a.image
                        ? w(
                            Ae,
                            {
                              key: 'image-defaults',
                              disabled: !e.image,
                              defaults: { VImg: { cover: !0, src: e.image } },
                            },
                            a.image
                          )
                        : w(oa, { key: 'image-img', cover: !0, src: e.image }, null),
                    ]),
                  w(
                    ri,
                    {
                      name: 'v-card',
                      active: !!e.loading,
                      color: typeof e.loading == 'boolean' ? void 0 : e.loading,
                    },
                    { default: a.loader }
                  ),
                  E &&
                    w(
                      Yb,
                      {
                        key: 'item',
                        prependAvatar: e.prependAvatar,
                        prependIcon: e.prependIcon,
                        title: e.title,
                        subtitle: e.subtitle,
                        appendAvatar: e.appendAvatar,
                        appendIcon: e.appendIcon,
                      },
                      {
                        default: a.item,
                        prepend: a.prepend,
                        title: a.title,
                        subtitle: a.subtitle,
                        append: a.append,
                      }
                    ),
                  R && w(Id, { key: 'text' }, { default: () => [a.text?.() ?? e.text] }),
                  a.default?.(),
                  a.actions && w(Kb, null, { default: a.actions }),
                  Ta(y, 'v-card'),
                ],
              }
            ),
            [[Nt, y && e.ripple]]
          )
        }),
        {}
      )
    },
  }),
  OT = (e) => {
    const { touchstartX: t, touchendX: n, touchstartY: a, touchendY: l } = e,
      o = 0.5,
      i = 16
    ;((e.offsetX = n - t),
      (e.offsetY = l - a),
      Math.abs(e.offsetY) < o * Math.abs(e.offsetX) &&
        (e.left && n < t - i && e.left(e), e.right && n > t + i && e.right(e)),
      Math.abs(e.offsetX) < o * Math.abs(e.offsetY) &&
        (e.up && l < a - i && e.up(e), e.down && l > a + i && e.down(e)))
  }
function $T(e, t) {
  const n = e.changedTouches[0]
  ;((t.touchstartX = n.clientX), (t.touchstartY = n.clientY), t.start?.({ originalEvent: e, ...t }))
}
function FT(e, t) {
  const n = e.changedTouches[0]
  ;((t.touchendX = n.clientX),
    (t.touchendY = n.clientY),
    t.end?.({ originalEvent: e, ...t }),
    OT(t))
}
function NT(e, t) {
  const n = e.changedTouches[0]
  ;((t.touchmoveX = n.clientX), (t.touchmoveY = n.clientY), t.move?.({ originalEvent: e, ...t }))
}
function HT() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
  const t = {
    touchstartX: 0,
    touchstartY: 0,
    touchendX: 0,
    touchendY: 0,
    touchmoveX: 0,
    touchmoveY: 0,
    offsetX: 0,
    offsetY: 0,
    left: e.left,
    right: e.right,
    up: e.up,
    down: e.down,
    start: e.start,
    move: e.move,
    end: e.end,
  }
  return { touchstart: (n) => $T(n, t), touchend: (n) => FT(n, t), touchmove: (n) => NT(n, t) }
}
function jT(e, t) {
  const n = t.value,
    a = n?.parent ? e.parentElement : e,
    l = n?.options ?? { passive: !0 },
    o = t.instance?.$.uid
  if (!a || o === void 0) return
  const i = HT(t.value)
  ;((a._touchHandlers = a._touchHandlers ?? Object.create(null)),
    (a._touchHandlers[o] = i),
    Xg(i).forEach((r) => {
      a.addEventListener(r, i[r], l)
    }))
}
function zT(e, t) {
  const n = t.value?.parent ? e.parentElement : e,
    a = t.instance?.$.uid
  if (!n?._touchHandlers || a === void 0) return
  const l = n._touchHandlers[a]
  ;(Xg(l).forEach((o) => {
    n.removeEventListener(o, l[o])
  }),
    delete n._touchHandlers[a])
}
const yr = { mounted: jT, unmounted: zT },
  Xb = Symbol.for('vuetify:v-window'),
  Zb = Symbol.for('vuetify:v-window-group'),
  Kr = $(
    {
      continuous: Boolean,
      nextIcon: { type: [Boolean, String, Function, Object], default: '$next' },
      prevIcon: { type: [Boolean, String, Function, Object], default: '$prev' },
      reverse: Boolean,
      showArrows: {
        type: [Boolean, String],
        validator: (e) => typeof e == 'boolean' || e === 'hover',
      },
      verticalArrows: [Boolean, String],
      touch: { type: [Object, Boolean], default: void 0 },
      direction: { type: String, default: 'horizontal' },
      modelValue: null,
      disabled: Boolean,
      selectedClass: { type: String, default: 'v-window-item--active' },
      mandatory: { type: [Boolean, String], default: 'force' },
      crossfade: Boolean,
      transitionDuration: Number,
      ...be(),
      ...Ie(),
      ...Be(),
    },
    'VWindow'
  ),
  Qa = J()({
    name: 'VWindow',
    directives: { vTouch: yr },
    props: Kr(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: a } = $e(e),
        { isRtl: l } = gt(),
        { t: o } = ze(),
        i = Aa(e, Zb),
        r = ae(),
        s = C(() => (l.value ? !e.reverse : e.reverse)),
        c = oe(!1),
        u = C(() => {
          if (e.crossfade) return 'v-window-crossfade-transition'
          const S = e.direction === 'vertical' ? 'y' : 'x',
            _ = (s.value ? !c.value : c.value) ? '-reverse' : ''
          return `v-window-${S}${_}-transition`
        }),
        d = oe(0),
        f = ae(void 0),
        v = C(() => i.items.value.findIndex((S) => i.selected.value.includes(S.id)))
      ;(ue(v, (S, k) => {
        const _ = i.items.value.length,
          P = _ - 1
        _ <= 2
          ? (c.value = S < k)
          : S === P && k === 0
            ? (c.value = !0)
            : S === 0 && k === P
              ? (c.value = !1)
              : (c.value = S < k)
      }),
        Fe(Xb, {
          transition: u,
          isReversed: c,
          transitionCount: d,
          transitionHeight: f,
          rootRef: r,
        }))
      const g = B(() => e.continuous || v.value !== 0),
        h = B(() => e.continuous || v.value !== i.items.value.length - 1)
      function m() {
        g.value && i.prev()
      }
      function b() {
        h.value && i.next()
      }
      const y = C(() => {
          const S = [],
            k = {
              icon: l.value ? e.nextIcon : e.prevIcon,
              class: `v-window__${s.value ? 'right' : 'left'}`,
              onClick: i.prev,
              'aria-label': o('$vuetify.carousel.prev'),
            }
          S.push(g.value ? (n.prev ? n.prev({ props: k }) : w(Me, k, null)) : x('div', null, null))
          const _ = {
            icon: l.value ? e.prevIcon : e.nextIcon,
            class: `v-window__${s.value ? 'left' : 'right'}`,
            onClick: i.next,
            'aria-label': o('$vuetify.carousel.next'),
          }
          return (
            S.push(
              h.value ? (n.next ? n.next({ props: _ }) : w(Me, _, null)) : x('div', null, null)
            ),
            S
          )
        }),
        p = C(() =>
          e.touch === !1
            ? e.touch
            : {
                ...{
                  left: () => {
                    s.value ? m() : b()
                  },
                  right: () => {
                    s.value ? b() : m()
                  },
                  start: (k) => {
                    let { originalEvent: _ } = k
                    _.stopPropagation()
                  },
                },
                ...(e.touch === !0 ? {} : e.touch),
              }
        )
      return (
        ne(() =>
          tt(
            w(
              e.tag,
              {
                ref: r,
                class: ee([
                  'v-window',
                  {
                    'v-window--show-arrows-on-hover': e.showArrows === 'hover',
                    'v-window--vertical-arrows': !!e.verticalArrows,
                    'v-window--crossfade': !!e.crossfade,
                  },
                  a.value,
                  e.class,
                ]),
                style: ce([
                  e.style,
                  e.transitionDuration && !On
                    ? { '--v-window-transition-duration': fe(e.transitionDuration, 'ms') }
                    : void 0,
                ]),
              },
              {
                default: () => [
                  x('div', { class: 'v-window__container', style: { height: f.value } }, [
                    n.default?.({ group: i }),
                    e.showArrows !== !1 &&
                      x(
                        'div',
                        {
                          class: ee([
                            'v-window__controls',
                            {
                              'v-window__controls--left':
                                e.verticalArrows === 'left' || e.verticalArrows === !0,
                            },
                            { 'v-window__controls--right': e.verticalArrows === 'right' },
                          ]),
                        },
                        [y.value]
                      ),
                  ]),
                  n.additional?.({ group: i }),
                ],
              }
            ),
            [[yr, p.value]]
          )
        ),
        { group: i }
      )
    },
  }),
  WT = $(
    {
      color: String,
      cycle: Boolean,
      delimiterIcon: { type: Se, default: '$delimiter' },
      height: { type: [Number, String], default: 500 },
      hideDelimiters: Boolean,
      hideDelimiterBackground: Boolean,
      interval: { type: [Number, String], default: 6e3, validator: (e) => Number(e) > 0 },
      progress: [Boolean, String],
      verticalDelimiters: [Boolean, String],
      ...Kr({ continuous: !0, mandatory: 'force', showArrows: !0 }),
    },
    'VCarousel'
  ),
  UT = J()({
    name: 'VCarousel',
    props: WT(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = we(e, 'modelValue'),
        { t: l } = ze(),
        o = ae()
      let i = -1
      ;(ue(a, s),
        ue(() => e.interval, s),
        ue(
          () => e.cycle,
          (c) => {
            c ? s() : window.clearTimeout(i)
          }
        ),
        pt(r))
      function r() {
        !e.cycle ||
          !o.value ||
          (i = window.setTimeout(
            o.value.group.next,
            Number(e.interval) > 0 ? Number(e.interval) : 6e3
          ))
      }
      function s() {
        ;(window.clearTimeout(i), window.requestAnimationFrame(r))
      }
      return (
        ne(() => {
          const c = Qa.filterProps(e)
          return w(
            Qa,
            Z({ ref: o }, c, {
              modelValue: a.value,
              'onUpdate:modelValue': (u) => (a.value = u),
              class: [
                'v-carousel',
                {
                  'v-carousel--hide-delimiter-background': e.hideDelimiterBackground,
                  'v-carousel--vertical-delimiters': e.verticalDelimiters,
                },
                e.class,
              ],
              style: [{ height: fe(e.height) }, e.style],
            }),
            {
              default: n.default,
              additional: (u) => {
                let { group: d } = u
                return x(he, null, [
                  !e.hideDelimiters &&
                    x(
                      'div',
                      {
                        class: 'v-carousel__controls',
                        style: {
                          left:
                            e.verticalDelimiters === 'left' && e.verticalDelimiters ? 0 : 'auto',
                          right: e.verticalDelimiters === 'right' ? 0 : 'auto',
                        },
                      },
                      [
                        d.items.value.length > 0 &&
                          w(
                            Ae,
                            {
                              defaults: {
                                VBtn: {
                                  color: e.color,
                                  icon: e.delimiterIcon,
                                  size: 'x-small',
                                  variant: 'text',
                                },
                              },
                              scoped: !0,
                            },
                            {
                              default: () => [
                                d.items.value.map((f, v) => {
                                  const g = {
                                    id: `carousel-item-${f.id}`,
                                    'aria-label': l(
                                      '$vuetify.carousel.ariaLabel.delimiter',
                                      v + 1,
                                      d.items.value.length
                                    ),
                                    class: [
                                      'v-carousel__controls__item',
                                      d.isSelected(f.id) && 'v-btn--active',
                                    ],
                                    onClick: () => d.select(f.id, !0),
                                  }
                                  return n.item
                                    ? n.item({ props: g, item: f })
                                    : w(Me, Z(f, g), null)
                                }),
                              ],
                            }
                          ),
                      ]
                    ),
                  e.progress &&
                    w(
                      Nr,
                      {
                        absolute: !0,
                        class: 'v-carousel__progress',
                        color: typeof e.progress == 'string' ? e.progress : void 0,
                        modelValue: ((d.getItemIndex(a.value) + 1) / d.items.value.length) * 100,
                      },
                      null
                    ),
                ])
              },
              prev: n.prev,
              next: n.next,
            }
          )
        }),
        {}
      )
    },
  }),
  Gr = $(
    {
      reverseTransition: { type: [Boolean, String], default: void 0 },
      transition: { type: [Boolean, String], default: void 0 },
      ...be(),
      ...dl(),
      ...wd(),
    },
    'VWindowItem'
  ),
  el = J()({
    name: 'VWindowItem',
    directives: { vTouch: yr },
    props: Gr(),
    emits: { 'group:selected': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = Ve(Xb),
        l = fl(e, Zb),
        { isBooted: o } = sl()
      if (!a || !l) throw new Error('[Vuetify] VWindowItem must be used inside VWindow')
      const i = oe(!1),
        r = C(
          () => o.value && (a.isReversed.value ? e.reverseTransition !== !1 : e.transition !== !1)
        )
      function s() {
        !i.value ||
          !a ||
          ((i.value = !1),
          a.transitionCount.value > 0 &&
            ((a.transitionCount.value -= 1),
            a.transitionCount.value === 0 && (a.transitionHeight.value = void 0)))
      }
      function c() {
        i.value ||
          !a ||
          ((i.value = !0),
          a.transitionCount.value === 0 &&
            (a.transitionHeight.value = fe(a.rootRef.value?.clientHeight)),
          (a.transitionCount.value += 1))
      }
      function u() {
        s()
      }
      function d(g) {
        i.value &&
          Re(() => {
            !r.value || !i.value || !a || (a.transitionHeight.value = fe(g.clientHeight))
          })
      }
      const f = C(() => {
          const g = a.isReversed.value ? e.reverseTransition : e.transition
          return r.value
            ? {
                name: typeof g != 'string' ? a.transition.value : g,
                onBeforeEnter: c,
                onAfterEnter: s,
                onEnterCancelled: u,
                onBeforeLeave: c,
                onAfterLeave: s,
                onLeaveCancelled: u,
                onEnter: d,
              }
            : !1
        }),
        { hasContent: v } = kd(e, l.isSelected)
      return (
        ne(() =>
          w(
            $t,
            { transition: f.value, disabled: !o.value },
            {
              default: () => [
                tt(
                  x(
                    'div',
                    {
                      class: ee(['v-window-item', l.selectedClass.value, e.class]),
                      style: ce(e.style),
                    },
                    [v.value && n.default?.()]
                  ),
                  [[Pn, l.isSelected.value]]
                ),
              ],
            }
          )
        ),
        { groupItem: l }
      )
    },
  }),
  KT = $({ ...Oy(), ...Gr() }, 'VCarouselItem'),
  GT = J()({
    name: 'VCarouselItem',
    inheritAttrs: !1,
    props: KT(),
    setup(e, t) {
      let { slots: n, attrs: a } = t
      ne(() => {
        const l = oa.filterProps(e),
          o = el.filterProps(e)
        return w(el, Z({ class: ['v-carousel-item', e.class] }, o), {
          default: () => [w(oa, Z(a, l), n)],
        })
      })
    },
  }),
  YT = da('v-code', 'code'),
  qT = $(
    {
      color: { type: Object },
      disabled: Boolean,
      dotSize: { type: [Number, String], default: 10 },
      height: { type: [Number, String], default: 150 },
      width: { type: [Number, String], default: 300 },
      ...be(),
    },
    'VColorPickerCanvas'
  ),
  XT = un({
    name: 'VColorPickerCanvas',
    props: qT(),
    emits: { 'update:color': (e) => !0, 'update:position': (e) => !0 },
    setup(e, t) {
      let { emit: n } = t
      const a = oe(!1),
        l = ae(),
        o = oe(parseFloat(e.width)),
        i = oe(parseFloat(e.height)),
        r = ae({ x: 0, y: 0 }),
        s = C({
          get: () => r.value,
          set(m) {
            if (!l.value) return
            const { x: b, y } = m
            ;((r.value = m),
              n('update:color', {
                h: e.color?.h ?? 0,
                s: Ge(b, 0, o.value) / o.value,
                v: 1 - Ge(y, 0, i.value) / i.value,
                a: e.color?.a ?? 1,
              }))
          },
        }),
        c = C(() => {
          const { x: m, y: b } = s.value,
            y = parseInt(e.dotSize, 10) / 2
          return {
            width: fe(e.dotSize),
            height: fe(e.dotSize),
            transform: `translate(${fe(m - y)}, ${fe(b - y)})`,
          }
        }),
        { resizeRef: u } = hn((m) => {
          if (!u.el?.offsetParent) return
          const { width: b, height: y } = m[0].contentRect
          ;((o.value = b), (i.value = y))
        })
      function d(m, b, y) {
        const { left: p, top: S, width: k, height: _ } = y
        s.value = { x: Ge(m - p, 0, k), y: Ge(b - S, 0, _) }
      }
      function f(m) {
        ;(m.type === 'mousedown' && m.preventDefault(),
          !e.disabled &&
            (v(m),
            window.addEventListener('mousemove', v),
            window.addEventListener('mouseup', g),
            window.addEventListener('touchmove', v),
            window.addEventListener('touchend', g)))
      }
      function v(m) {
        if (e.disabled || !l.value) return
        a.value = !0
        const b = a1(m)
        d(b.clientX, b.clientY, l.value.getBoundingClientRect())
      }
      function g() {
        ;(window.removeEventListener('mousemove', v),
          window.removeEventListener('mouseup', g),
          window.removeEventListener('touchmove', v),
          window.removeEventListener('touchend', g))
      }
      function h() {
        if (!l.value) return
        const m = l.value,
          b = m.getContext('2d')
        if (!b) return
        const y = b.createLinearGradient(0, 0, m.width, 0)
        ;(y.addColorStop(0, 'hsla(0, 0%, 100%, 1)'),
          y.addColorStop(1, `hsla(${e.color?.h ?? 0}, 100%, 50%, 1)`),
          (b.fillStyle = y),
          b.fillRect(0, 0, m.width, m.height))
        const p = b.createLinearGradient(0, 0, 0, m.height)
        ;(p.addColorStop(0, 'hsla(0, 0%, 0%, 0)'),
          p.addColorStop(1, 'hsla(0, 0%, 0%, 1)'),
          (b.fillStyle = p),
          b.fillRect(0, 0, m.width, m.height))
      }
      return (
        ue(() => e.color?.h, h, { immediate: !0 }),
        ue(
          () => [o.value, i.value],
          (m, b) => {
            ;(h(), (r.value = { x: (s.value.x * m[0]) / b[0], y: (s.value.y * m[1]) / b[1] }))
          },
          { flush: 'post' }
        ),
        ue(
          () => e.color,
          () => {
            if (a.value) {
              a.value = !1
              return
            }
            r.value = e.color
              ? { x: e.color.s * o.value, y: (1 - e.color.v) * i.value }
              : { x: 0, y: 0 }
          },
          { deep: !0, immediate: !0 }
        ),
        pt(() => h()),
        ne(() =>
          x(
            'div',
            {
              ref: u,
              class: ee(['v-color-picker-canvas', e.class]),
              style: ce(e.style),
              onMousedown: f,
              onTouchstartPassive: f,
            },
            [
              x('canvas', { ref: l, width: o.value, height: i.value }, null),
              e.color &&
                x(
                  'div',
                  {
                    class: ee([
                      'v-color-picker-canvas__dot',
                      { 'v-color-picker-canvas__dot--disabled': e.disabled },
                    ]),
                    style: ce(c.value),
                  },
                  null
                ),
            ]
          )
        ),
        {}
      )
    },
  })
function ZT(e, t) {
  if (t) {
    const { a: n, ...a } = e
    return a
  }
  return e
}
function JT(e, t) {
  if (t == null || typeof t == 'string') {
    const n = e.a !== 1
    if (t?.startsWith('rgb(')) {
      const { r: l, g: o, b: i, a: r } = $n(e)
      return `rgb(${l} ${o} ${i}` + (n ? ` / ${r})` : ')')
    } else if (t?.startsWith('hsl(')) {
      const { h: l, s: o, l: i, a: r } = Pu(e)
      return `hsl(${l} ${Math.round(o * 100)} ${Math.round(i * 100)}` + (n ? ` / ${r})` : ')')
    }
    const a = my(e)
    return e.a === 1 ? a.slice(0, 7) : a
  }
  if (typeof t == 'object') {
    let n
    return (
      $a(t, ['r', 'g', 'b'])
        ? (n = $n(e))
        : $a(t, ['h', 's', 'l'])
          ? (n = Pu(e))
          : $a(t, ['h', 's', 'v']) && (n = e),
      ZT(n, !$a(t, ['a']) && e.a === 1)
    )
  }
  return e
}
const Pl = { h: 0, s: 0, v: 0, a: 1 },
  ju = {
    inputProps: { type: 'number', min: 0 },
    inputs: [
      {
        label: 'R',
        max: 255,
        step: 1,
        getValue: (e) => Math.round(e.r),
        getColor: (e, t) => ({ ...e, r: Number(t) }),
        localeKey: 'redInput',
      },
      {
        label: 'G',
        max: 255,
        step: 1,
        getValue: (e) => Math.round(e.g),
        getColor: (e, t) => ({ ...e, g: Number(t) }),
        localeKey: 'greenInput',
      },
      {
        label: 'B',
        max: 255,
        step: 1,
        getValue: (e) => Math.round(e.b),
        getColor: (e, t) => ({ ...e, b: Number(t) }),
        localeKey: 'blueInput',
      },
      {
        label: 'A',
        max: 1,
        step: 0.01,
        getValue: (e) => {
          let { a: t } = e
          return t != null ? Math.round(t * 100) / 100 : 1
        },
        getColor: (e, t) => ({ ...e, a: Number(t) }),
        localeKey: 'alphaInput',
      },
    ],
    to: $n,
    from: ni,
  },
  QT = { ...ju, inputs: ju.inputs?.slice(0, 3) },
  zu = {
    inputProps: { type: 'number', min: 0 },
    inputs: [
      {
        label: 'H',
        max: 360,
        step: 1,
        getValue: (e) => Math.round(e.h),
        getColor: (e, t) => ({ ...e, h: Number(t) }),
        localeKey: 'hueInput',
      },
      {
        label: 'S',
        max: 1,
        step: 0.01,
        getValue: (e) => Math.round(e.s * 100) / 100,
        getColor: (e, t) => ({ ...e, s: Number(t) }),
        localeKey: 'saturationInput',
      },
      {
        label: 'L',
        max: 1,
        step: 0.01,
        getValue: (e) => Math.round(e.l * 100) / 100,
        getColor: (e, t) => ({ ...e, l: Number(t) }),
        localeKey: 'lightnessInput',
      },
      {
        label: 'A',
        max: 1,
        step: 0.01,
        getValue: (e) => {
          let { a: t } = e
          return t != null ? Math.round(t * 100) / 100 : 1
        },
        getColor: (e, t) => ({ ...e, a: Number(t) }),
        localeKey: 'alphaInput',
      },
    ],
    to: Pu,
    from: qc,
  },
  eA = { ...zu, inputs: zu.inputs.slice(0, 3) },
  Jb = {
    inputProps: { type: 'text' },
    inputs: [{ label: 'HEXA', getValue: (e) => e, getColor: (e, t) => t, localeKey: 'hexaInput' }],
    to: my,
    from: I1,
  },
  tA = {
    ...Jb,
    inputs: [
      {
        label: 'HEX',
        getValue: (e) => e.slice(0, 7),
        getColor: (e, t) => t,
        localeKey: 'hexInput',
      },
    ],
  },
  Ga = { rgb: QT, rgba: ju, hsl: eA, hsla: zu, hex: tA, hexa: Jb },
  nA = (e) => {
    let { label: t, ...n } = e
    return x('div', { class: 'v-color-picker-edit__input' }, [
      x('input', BS(Kh(n)), null),
      x('span', null, [t]),
    ])
  },
  aA = $(
    {
      color: Object,
      disabled: Boolean,
      mode: { type: String, default: 'rgba', validator: (e) => Object.keys(Ga).includes(e) },
      modes: {
        type: Array,
        default: () => Object.keys(Ga),
        validator: (e) => Array.isArray(e) && e.every((t) => Object.keys(Ga).includes(t)),
      },
      ...be(),
    },
    'VColorPickerEdit'
  ),
  lA = un({
    name: 'VColorPickerEdit',
    props: aA(),
    emits: { 'update:color': (e) => !0, 'update:mode': (e) => !0 },
    setup(e, t) {
      let { emit: n } = t
      const { t: a } = ze(),
        l = C(() => e.modes.map((i) => ({ ...Ga[i], name: i }))),
        o = C(() => {
          const i = l.value.find((s) => s.name === e.mode)
          if (!i) return []
          const r = e.color ? i.to(e.color) : null
          return i.inputs?.map((s) => {
            let { getValue: c, getColor: u, localeKey: d, ...f } = s
            return {
              ...i.inputProps,
              ...f,
              ariaLabel: a(`$vuetify.colorPicker.ariaLabel.${d}`),
              disabled: e.disabled,
              value: r && c(r),
              onChange: (v) => {
                const g = v.target
                g && n('update:color', i.from(u(r ?? i.to(Pl), g.value)))
              },
            }
          })
        })
      return (
        ne(() =>
          x('div', { class: ee(['v-color-picker-edit', e.class]), style: ce(e.style) }, [
            o.value?.map((i) => w(nA, i, null)),
            l.value.length > 1 &&
              w(
                Me,
                {
                  icon: '$unfold',
                  size: 'x-small',
                  variant: 'plain',
                  'aria-label': a('$vuetify.colorPicker.ariaLabel.changeFormat'),
                  onClick: () => {
                    const i = l.value.findIndex((r) => r.name === e.mode)
                    n('update:mode', l.value[(i + 1) % l.value.length].name)
                  },
                },
                null
              ),
          ])
        ),
        {}
      )
    },
  }),
  Td = Symbol.for('vuetify:v-slider')
function Wu(e, t, n) {
  const a = n === 'vertical',
    l = t.getBoundingClientRect(),
    o = 'touches' in e ? e.touches[0] : e
  return a ? o.clientY - (l.top + l.height / 2) : o.clientX - (l.left + l.width / 2)
}
function oA(e, t) {
  return 'touches' in e && e.touches.length
    ? e.touches[0][t]
    : 'changedTouches' in e && e.changedTouches.length
      ? e.changedTouches[0][t]
      : e[t]
}
const Qb = $(
    {
      disabled: { type: Boolean, default: null },
      error: Boolean,
      readonly: { type: Boolean, default: null },
      max: { type: [Number, String], default: 100 },
      min: { type: [Number, String], default: 0 },
      step: { type: [Number, String], default: 0 },
      thumbColor: String,
      thumbLabel: {
        type: [Boolean, String],
        default: void 0,
        validator: (e) => typeof e == 'boolean' || e === 'always',
      },
      thumbSize: { type: [Number, String], default: 20 },
      showTicks: {
        type: [Boolean, String],
        default: !1,
        validator: (e) => typeof e == 'boolean' || e === 'always',
      },
      ticks: { type: [Array, Object] },
      tickSize: { type: [Number, String], default: 2 },
      color: String,
      trackColor: String,
      trackFillColor: String,
      trackSize: { type: [Number, String], default: 4 },
      direction: {
        type: String,
        default: 'horizontal',
        validator: (e) => ['vertical', 'horizontal'].includes(e),
      },
      reverse: Boolean,
      noKeyboard: Boolean,
      ...Je(),
      ...yt({ elevation: 2 }),
      ripple: { type: Boolean, default: !0 },
    },
    'Slider'
  ),
  ep = (e) => {
    const t = C(() => parseFloat(e.min)),
      n = C(() => parseFloat(e.max)),
      a = C(() => (Number(e.step) > 0 ? parseFloat(e.step) : 0)),
      l = C(() => Math.max(Cv(a.value), Cv(t.value)))
    function o(i) {
      if (((i = parseFloat(i)), a.value <= 0)) return i
      const r = Ge(i, t.value, n.value),
        s = t.value % a.value
      let c = Math.round((r - s) / a.value) * a.value + s
      return (
        r > c && c + a.value > n.value && (c = n.value),
        parseFloat(Math.min(c, n.value).toFixed(l.value))
      )
    }
    return { min: t, max: n, step: a, decimals: l, roundValue: o }
  },
  tp = (e) => {
    let {
      props: t,
      steps: n,
      onSliderStart: a,
      onSliderMove: l,
      onSliderEnd: o,
      getActiveThumb: i,
    } = e
    const r = to(t),
      { isRtl: s } = gt(),
      c = B(() => t.reverse),
      u = C(() => t.direction === 'vertical'),
      d = C(() => u.value !== c.value),
      { min: f, max: v, step: g, decimals: h, roundValue: m } = n,
      b = C(() => parseInt(t.thumbSize, 10)),
      y = C(() => parseInt(t.tickSize, 10)),
      p = C(() => parseInt(t.trackSize, 10)),
      S = C(() => (v.value - f.value) / g.value),
      k = C(() => (t.error || r.isDisabled.value ? void 0 : (t.thumbColor ?? t.color))),
      _ = C(() => (t.error || r.isDisabled.value ? void 0 : t.thumbColor)),
      P = C(() => (t.error || r.isDisabled.value ? void 0 : (t.trackColor ?? t.color))),
      A = C(() => (t.error || r.isDisabled.value ? void 0 : (t.trackFillColor ?? t.color))),
      D = oe(!1),
      E = oe(0),
      R = ae(),
      V = ae()
    function M(L) {
      const q = R.value?.$el
      if (!q) return
      const le = t.direction === 'vertical',
        ie = le ? 'top' : 'left',
        Ce = le ? 'height' : 'width',
        pe = le ? 'clientY' : 'clientX',
        { [ie]: I, [Ce]: T } = q.getBoundingClientRect(),
        z = oA(L, pe)
      let X = Ge((z - I - E.value) / T) || 0
      return (
        (le ? d.value : d.value !== s.value) && (X = 1 - X),
        m(f.value + X * (v.value - f.value))
      )
    }
    const F = (L) => {
        const q = M(L)
        ;(q != null && o({ value: q }), (D.value = !1), (E.value = 0))
      },
      G = (L) => {
        const q = M(L)
        ;((V.value = i(L)),
          V.value &&
            ((D.value = !0),
            V.value.contains(L.target)
              ? (E.value = Wu(L, V.value, t.direction))
              : ((E.value = 0), q != null && l({ value: q })),
            q != null && a({ value: q }),
            Re(() => V.value?.focus())))
      },
      W = { passive: !0, capture: !0 }
    function te(L) {
      const q = M(L)
      q != null && l({ value: q })
    }
    function H(L) {
      ;(L.stopPropagation(),
        L.preventDefault(),
        F(L),
        window.removeEventListener('mousemove', te, W),
        window.removeEventListener('mouseup', H))
    }
    function O(L) {
      ;(F(L),
        window.removeEventListener('touchmove', te, W),
        L.target?.removeEventListener('touchend', O))
    }
    function j(L) {
      ;(G(L),
        window.addEventListener('touchmove', te, W),
        L.target?.addEventListener('touchend', O, { passive: !1 }))
    }
    function U(L) {
      L.button === 0 &&
        (L.preventDefault(),
        G(L),
        window.addEventListener('mousemove', te, W),
        window.addEventListener('mouseup', H, { passive: !1 }))
    }
    const Y = (L) => {
        const q = ((L - f.value) / (v.value - f.value)) * 100
        return Ge(isNaN(q) ? 0 : q, 0, 100)
      },
      K = B(() => t.showTicks),
      se = C(() =>
        K.value
          ? t.ticks
            ? Array.isArray(t.ticks)
              ? t.ticks.map((L) => ({ value: L, position: Y(L), label: L.toString() }))
              : Object.keys(t.ticks).map((L) => ({
                  value: parseFloat(L),
                  position: Y(parseFloat(L)),
                  label: t.ticks[L],
                }))
            : S.value !== 1 / 0
              ? ln(S.value + 1).map((L) => {
                  const q = f.value + L * g.value
                  return { value: q, position: Y(q) }
                })
              : []
          : []
      ),
      de = C(() =>
        se.value.some((L) => {
          let { label: q } = L
          return !!q
        })
      ),
      ye = {
        activeThumbRef: V,
        color: B(() => t.color),
        decimals: h,
        disabled: r.isDisabled,
        direction: B(() => t.direction),
        elevation: B(() => t.elevation),
        hasLabels: de,
        isReversed: c,
        indexFromEnd: d,
        min: f,
        max: v,
        mousePressed: D,
        noKeyboard: B(() => t.noKeyboard),
        numTicks: S,
        onSliderMousedown: U,
        onSliderTouchstart: j,
        parsedTicks: se,
        parseMouseMove: M,
        position: Y,
        readonly: r.isReadonly,
        rounded: B(() => t.rounded),
        roundValue: m,
        showTicks: K,
        startOffset: E,
        step: g,
        thumbSize: b,
        thumbColor: k,
        thumbLabelColor: _,
        thumbLabel: B(() => t.thumbLabel),
        ticks: B(() => t.ticks),
        tickSize: y,
        trackColor: P,
        trackContainerRef: R,
        trackFillColor: A,
        trackSize: p,
        vertical: u,
      }
    return (Fe(Td, ye), ye)
  },
  iA = $(
    {
      focused: Boolean,
      max: { type: Number, required: !0 },
      min: { type: Number, required: !0 },
      modelValue: { type: Number, required: !0 },
      position: { type: Number, required: !0 },
      ripple: { type: [Boolean, Object], default: !0 },
      name: String,
      noKeyboard: Boolean,
      ...be(),
    },
    'VSliderThumb'
  ),
  Uu = J()({
    name: 'VSliderThumb',
    directives: { vRipple: Nt },
    props: iA(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n, emit: a } = t
      const l = Ve(Td),
        { isRtl: o, rtlClasses: i } = gt()
      if (!l)
        throw new Error('[Vuetify] v-slider-thumb must be used inside v-slider or v-range-slider')
      const {
          min: r,
          max: s,
          thumbColor: c,
          thumbLabelColor: u,
          step: d,
          disabled: f,
          thumbSize: v,
          thumbLabel: g,
          direction: h,
          isReversed: m,
          vertical: b,
          readonly: y,
          elevation: p,
          mousePressed: S,
          decimals: k,
          indexFromEnd: _,
        } = l,
        P = C(() => (f.value ? void 0 : p.value)),
        { elevationClasses: A } = xt(P),
        { textColorClasses: D, textColorStyles: E } = Vt(c),
        { backgroundColorClasses: R, backgroundColorStyles: V } = He(u),
        { pageup: M, pagedown: F, end: G, home: W, left: te, right: H, down: O, up: j } = Su,
        U = [M, F, G, W, te, H, O, j],
        Y = C(() => (d.value ? [1, 2, 3] : [1, 5, 10]))
      function K(de, ye) {
        if (e.noKeyboard || !U.includes(de.key)) return
        de.preventDefault()
        const L = d.value || 0.1,
          q = (s.value - r.value) / L
        if ([te, H, O, j].includes(de.key)) {
          const ie = (b.value
              ? [o.value ? te : H, m.value ? O : j]
              : _.value !== o.value
                ? [te, j]
                : [H, j]
            ).includes(de.key)
              ? 1
              : -1,
            Ce = de.shiftKey ? 2 : de.ctrlKey ? 1 : 0
          ie === -1 && ye === s.value && !Ce && !Number.isInteger(q)
            ? (ye = ye - (q % 1) * L)
            : (ye = ye + ie * L * Y.value[Ce])
        } else if (de.key === W) ye = r.value
        else if (de.key === G) ye = s.value
        else {
          const le = de.key === F ? 1 : -1
          ye = ye - le * L * (q > 100 ? q / 10 : 10)
        }
        return Math.max(e.min, Math.min(e.max, ye))
      }
      function se(de) {
        const ye = K(de, e.modelValue)
        ye != null && a('update:modelValue', ye)
      }
      return (
        ne(() => {
          const de = fe(_.value ? 100 - e.position : e.position, '%')
          return x(
            'div',
            {
              class: ee([
                'v-slider-thumb',
                {
                  'v-slider-thumb--focused': e.focused,
                  'v-slider-thumb--pressed': e.focused && S.value,
                },
                e.class,
                i.value,
              ]),
              style: ce([
                { '--v-slider-thumb-position': de, '--v-slider-thumb-size': fe(v.value) },
                e.style,
              ]),
              role: 'slider',
              tabindex: f.value ? -1 : 0,
              'aria-label': e.name,
              'aria-valuemin': r.value,
              'aria-valuemax': s.value,
              'aria-valuenow': e.modelValue,
              'aria-readonly': !!y.value,
              'aria-orientation': h.value,
              onKeydown: y.value ? void 0 : se,
            },
            [
              x(
                'div',
                { class: ee(['v-slider-thumb__surface', D.value, A.value]), style: ce(E.value) },
                null
              ),
              tt(
                x(
                  'div',
                  { class: ee(['v-slider-thumb__ripple', D.value]), style: ce(E.value) },
                  null
                ),
                [[Nt, e.ripple, null, { circle: !0, center: !0 }]]
              ),
              w(
                rd,
                { origin: 'bottom center' },
                {
                  default: () => [
                    tt(
                      x('div', { class: 'v-slider-thumb__label-container' }, [
                        x(
                          'div',
                          { class: ee(['v-slider-thumb__label', R.value]), style: ce(V.value) },
                          [
                            x('div', null, [
                              n['thumb-label']?.({ modelValue: e.modelValue }) ??
                                e.modelValue.toFixed(d.value ? k.value : 1),
                            ]),
                            x('div', { class: 'v-slider-thumb__label-wedge' }, null),
                          ]
                        ),
                      ]),
                      [[Pn, (g.value && e.focused) || g.value === 'always']]
                    ),
                  ],
                }
              ),
            ]
          )
        }),
        {}
      )
    },
  }),
  rA = $(
    { start: { type: Number, required: !0 }, stop: { type: Number, required: !0 }, ...be() },
    'VSliderTrack'
  ),
  np = J()({
    name: 'VSliderTrack',
    props: rA(),
    emits: {},
    setup(e, t) {
      let { slots: n } = t
      const a = Ve(Td)
      if (!a) throw new Error('[Vuetify] v-slider-track must be inside v-slider or v-range-slider')
      const {
          color: l,
          parsedTicks: o,
          rounded: i,
          showTicks: r,
          tickSize: s,
          trackColor: c,
          trackFillColor: u,
          trackSize: d,
          vertical: f,
          min: v,
          max: g,
          indexFromEnd: h,
        } = a,
        { roundedClasses: m } = ot(i),
        { backgroundColorClasses: b, backgroundColorStyles: y } = He(u),
        { backgroundColorClasses: p, backgroundColorStyles: S } = He(c),
        k = C(() => `inset-${f.value ? 'block' : 'inline'}-${h.value ? 'end' : 'start'}`),
        _ = C(() => (f.value ? 'height' : 'width')),
        P = C(() => ({ [k.value]: '0%', [_.value]: '100%' })),
        A = C(() => e.stop - e.start),
        D = C(() => ({ [k.value]: fe(e.start, '%'), [_.value]: fe(A.value, '%') })),
        E = C(() =>
          r.value
            ? (f.value ? o.value.slice().reverse() : o.value).map((V, M) => {
                const F = V.value !== v.value && V.value !== g.value ? fe(V.position, '%') : void 0
                return x(
                  'div',
                  {
                    key: V.value,
                    class: ee([
                      'v-slider-track__tick',
                      {
                        'v-slider-track__tick--filled':
                          V.position >= e.start && V.position <= e.stop,
                        'v-slider-track__tick--first': V.value === v.value,
                        'v-slider-track__tick--last': V.value === g.value,
                      },
                    ]),
                    style: { [k.value]: F },
                  },
                  [
                    (V.label || n['tick-label']) &&
                      x('div', { class: 'v-slider-track__tick-label' }, [
                        n['tick-label']?.({ tick: V, index: M }) ?? V.label,
                      ]),
                  ]
                )
              })
            : []
        )
      return (
        ne(() =>
          x(
            'div',
            {
              class: ee(['v-slider-track', m.value, e.class]),
              style: ce([
                { '--v-slider-track-size': fe(d.value), '--v-slider-tick-size': fe(s.value) },
                e.style,
              ]),
            },
            [
              x(
                'div',
                {
                  class: ee([
                    'v-slider-track__background',
                    p.value,
                    { 'v-slider-track__background--opacity': !!l.value || !u.value },
                  ]),
                  style: { ...P.value, ...S.value },
                },
                null
              ),
              x(
                'div',
                { class: ee(['v-slider-track__fill', b.value]), style: { ...D.value, ...y.value } },
                null
              ),
              r.value &&
                x(
                  'div',
                  {
                    class: ee([
                      'v-slider-track__ticks',
                      { 'v-slider-track__ticks--always-show': r.value === 'always' },
                    ]),
                  },
                  [E.value]
                ),
            ]
          )
        ),
        {}
      )
    },
  }),
  sA = $(
    { ...ci(), ...Qb(), ...ma(), modelValue: { type: [Number, String], default: 0 } },
    'VSlider'
  ),
  Ku = J()({
    name: 'VSlider',
    props: sA(),
    emits: {
      'update:focused': (e) => !0,
      'update:modelValue': (e) => !0,
      start: (e) => !0,
      end: (e) => !0,
    },
    setup(e, t) {
      let { slots: n, emit: a } = t
      const l = ae(),
        o = ae(),
        { rtlClasses: i } = gt(),
        r = ep(e),
        s = we(e, 'modelValue', void 0, (D) => r.roundValue(D ?? r.min.value)),
        {
          min: c,
          max: u,
          mousePressed: d,
          roundValue: f,
          onSliderMousedown: v,
          onSliderTouchstart: g,
          trackContainerRef: h,
          position: m,
          hasLabels: b,
          disabled: y,
          readonly: p,
          noKeyboard: S,
        } = tp({
          props: e,
          steps: r,
          onSliderStart: () => {
            a('start', s.value)
          },
          onSliderEnd: (D) => {
            let { value: E } = D
            const R = f(E)
            ;((s.value = R), a('end', R))
          },
          onSliderMove: (D) => {
            let { value: E } = D
            return (s.value = f(E))
          },
          getActiveThumb: () => l.value?.$el,
        }),
        { isFocused: k, focus: _, blur: P } = va(e),
        A = C(() => m(s.value))
      return (
        ne(() => {
          const D = Dt.filterProps(e),
            E = !!(e.label || n.label || n.prepend)
          return w(
            Dt,
            Z(
              {
                ref: o,
                class: [
                  'v-slider',
                  {
                    'v-slider--has-labels': !!n['tick-label'] || b.value,
                    'v-slider--focused': k.value,
                    'v-slider--pressed': d.value,
                    'v-slider--disabled': e.disabled,
                  },
                  i.value,
                  e.class,
                ],
                style: e.style,
              },
              D,
              { focused: k.value }
            ),
            {
              ...n,
              prepend: E
                ? (R) =>
                    x(he, null, [
                      n.label?.(R) ??
                        (e.label
                          ? w(eo, { id: R.id.value, class: 'v-slider__label', text: e.label }, null)
                          : void 0),
                      n.prepend?.(R),
                    ])
                : void 0,
              default: (R) => {
                let { id: V, messagesId: M } = R
                return x(
                  'div',
                  {
                    class: 'v-slider__container',
                    onMousedown: p.value ? void 0 : v,
                    onTouchstartPassive: p.value ? void 0 : g,
                  },
                  [
                    x(
                      'input',
                      {
                        id: V.value,
                        name: e.name || V.value,
                        disabled: !!y.value,
                        readonly: !!p.value,
                        tabindex: '-1',
                        value: s.value,
                      },
                      null
                    ),
                    w(np, { ref: h, start: 0, stop: A.value }, { 'tick-label': n['tick-label'] }),
                    w(
                      Uu,
                      {
                        ref: l,
                        'aria-describedby': M.value,
                        focused: k.value,
                        noKeyboard: S.value,
                        min: c.value,
                        max: u.value,
                        modelValue: s.value,
                        'onUpdate:modelValue': (F) => (s.value = F),
                        position: A.value,
                        elevation: e.elevation,
                        onFocus: _,
                        onBlur: P,
                        ripple: e.ripple,
                        name: e.name,
                      },
                      { 'thumb-label': n['thumb-label'] }
                    ),
                  ]
                )
              },
            }
          )
        }),
        _t({ focus: () => l.value?.$el.focus() }, o)
      )
    },
  }),
  ap = $(
    {
      color: { type: Object },
      disabled: Boolean,
      hideAlpha: Boolean,
      hideEyeDropper: Boolean,
      eyeDropperIcon: { type: Se, default: '$eyeDropper' },
      ...be(),
    },
    'VColorPickerPreview'
  ),
  uA = un({
    name: 'VColorPickerPreview',
    props: ap(),
    emits: { 'update:color': (e) => !0 },
    setup(e, t) {
      let { emit: n } = t
      const { t: a } = ze(),
        l = new AbortController()
      xc(() => l.abort())
      async function o() {
        if (!pv || e.disabled) return
        const i = new window.EyeDropper()
        try {
          const r = await i.open({ signal: l.signal }),
            s = ni(on(r.sRGBHex))
          n('update:color', { ...(e.color ?? Pl), ...s })
        } catch {}
      }
      return (
        ne(() =>
          x(
            'div',
            {
              class: ee([
                'v-color-picker-preview',
                { 'v-color-picker-preview--hide-alpha': e.hideAlpha },
                e.class,
              ]),
              style: ce(e.style),
            },
            [
              pv &&
                !e.hideEyeDropper &&
                x('div', { class: 'v-color-picker-preview__eye-dropper', key: 'eyeDropper' }, [
                  w(
                    Me,
                    {
                      'aria-label': a('$vuetify.colorPicker.ariaLabel.eyedropper'),
                      density: 'comfortable',
                      disabled: e.disabled,
                      icon: e.eyeDropperIcon,
                      variant: 'plain',
                      onClick: o,
                    },
                    null
                  ),
                ]),
              x('div', { class: 'v-color-picker-preview__dot' }, [
                x('div', { style: { background: dy(e.color ?? Pl) } }, null),
              ]),
              x('div', { class: 'v-color-picker-preview__sliders' }, [
                w(
                  Ku,
                  {
                    class: 'v-color-picker-preview__track v-color-picker-preview__hue',
                    name: a('$vuetify.colorPicker.ariaLabel.hueSlider'),
                    modelValue: e.color?.h,
                    'onUpdate:modelValue': (i) => n('update:color', { ...(e.color ?? Pl), h: i }),
                    step: 0,
                    min: 0,
                    max: 360,
                    disabled: e.disabled,
                    thumbSize: 14,
                    trackSize: 8,
                    trackFillColor: 'white',
                    hideDetails: !0,
                  },
                  null
                ),
                !e.hideAlpha &&
                  w(
                    Ku,
                    {
                      class: 'v-color-picker-preview__track v-color-picker-preview__alpha',
                      name: a('$vuetify.colorPicker.ariaLabel.alphaSlider'),
                      modelValue: e.color?.a ?? 1,
                      'onUpdate:modelValue': (i) => n('update:color', { ...(e.color ?? Pl), a: i }),
                      step: 1 / 256,
                      min: 0,
                      max: 1,
                      disabled: e.disabled,
                      thumbSize: 14,
                      trackSize: 8,
                      trackFillColor: 'white',
                      hideDetails: !0,
                    },
                    null
                  ),
              ]),
            ]
          )
        ),
        {}
      )
    },
  }),
  cA = {
    base: '#f44336',
    lighten5: '#ffebee',
    lighten4: '#ffcdd2',
    lighten3: '#ef9a9a',
    lighten2: '#e57373',
    lighten1: '#ef5350',
    darken1: '#e53935',
    darken2: '#d32f2f',
    darken3: '#c62828',
    darken4: '#b71c1c',
    accent1: '#ff8a80',
    accent2: '#ff5252',
    accent3: '#ff1744',
    accent4: '#d50000',
  },
  dA = {
    base: '#e91e63',
    lighten5: '#fce4ec',
    lighten4: '#f8bbd0',
    lighten3: '#f48fb1',
    lighten2: '#f06292',
    lighten1: '#ec407a',
    darken1: '#d81b60',
    darken2: '#c2185b',
    darken3: '#ad1457',
    darken4: '#880e4f',
    accent1: '#ff80ab',
    accent2: '#ff4081',
    accent3: '#f50057',
    accent4: '#c51162',
  },
  fA = {
    base: '#9c27b0',
    lighten5: '#f3e5f5',
    lighten4: '#e1bee7',
    lighten3: '#ce93d8',
    lighten2: '#ba68c8',
    lighten1: '#ab47bc',
    darken1: '#8e24aa',
    darken2: '#7b1fa2',
    darken3: '#6a1b9a',
    darken4: '#4a148c',
    accent1: '#ea80fc',
    accent2: '#e040fb',
    accent3: '#d500f9',
    accent4: '#aa00ff',
  },
  vA = {
    base: '#673ab7',
    lighten5: '#ede7f6',
    lighten4: '#d1c4e9',
    lighten3: '#b39ddb',
    lighten2: '#9575cd',
    lighten1: '#7e57c2',
    darken1: '#5e35b1',
    darken2: '#512da8',
    darken3: '#4527a0',
    darken4: '#311b92',
    accent1: '#b388ff',
    accent2: '#7c4dff',
    accent3: '#651fff',
    accent4: '#6200ea',
  },
  mA = {
    base: '#3f51b5',
    lighten5: '#e8eaf6',
    lighten4: '#c5cae9',
    lighten3: '#9fa8da',
    lighten2: '#7986cb',
    lighten1: '#5c6bc0',
    darken1: '#3949ab',
    darken2: '#303f9f',
    darken3: '#283593',
    darken4: '#1a237e',
    accent1: '#8c9eff',
    accent2: '#536dfe',
    accent3: '#3d5afe',
    accent4: '#304ffe',
  },
  hA = {
    base: '#2196f3',
    lighten5: '#e3f2fd',
    lighten4: '#bbdefb',
    lighten3: '#90caf9',
    lighten2: '#64b5f6',
    lighten1: '#42a5f5',
    darken1: '#1e88e5',
    darken2: '#1976d2',
    darken3: '#1565c0',
    darken4: '#0d47a1',
    accent1: '#82b1ff',
    accent2: '#448aff',
    accent3: '#2979ff',
    accent4: '#2962ff',
  },
  gA = {
    base: '#03a9f4',
    lighten5: '#e1f5fe',
    lighten4: '#b3e5fc',
    lighten3: '#81d4fa',
    lighten2: '#4fc3f7',
    lighten1: '#29b6f6',
    darken1: '#039be5',
    darken2: '#0288d1',
    darken3: '#0277bd',
    darken4: '#01579b',
    accent1: '#80d8ff',
    accent2: '#40c4ff',
    accent3: '#00b0ff',
    accent4: '#0091ea',
  },
  yA = {
    base: '#00bcd4',
    lighten5: '#e0f7fa',
    lighten4: '#b2ebf2',
    lighten3: '#80deea',
    lighten2: '#4dd0e1',
    lighten1: '#26c6da',
    darken1: '#00acc1',
    darken2: '#0097a7',
    darken3: '#00838f',
    darken4: '#006064',
    accent1: '#84ffff',
    accent2: '#18ffff',
    accent3: '#00e5ff',
    accent4: '#00b8d4',
  },
  bA = {
    base: '#009688',
    lighten5: '#e0f2f1',
    lighten4: '#b2dfdb',
    lighten3: '#80cbc4',
    lighten2: '#4db6ac',
    lighten1: '#26a69a',
    darken1: '#00897b',
    darken2: '#00796b',
    darken3: '#00695c',
    darken4: '#004d40',
    accent1: '#a7ffeb',
    accent2: '#64ffda',
    accent3: '#1de9b6',
    accent4: '#00bfa5',
  },
  pA = {
    base: '#4caf50',
    lighten5: '#e8f5e9',
    lighten4: '#c8e6c9',
    lighten3: '#a5d6a7',
    lighten2: '#81c784',
    lighten1: '#66bb6a',
    darken1: '#43a047',
    darken2: '#388e3c',
    darken3: '#2e7d32',
    darken4: '#1b5e20',
    accent1: '#b9f6ca',
    accent2: '#69f0ae',
    accent3: '#00e676',
    accent4: '#00c853',
  },
  SA = {
    base: '#8bc34a',
    lighten5: '#f1f8e9',
    lighten4: '#dcedc8',
    lighten3: '#c5e1a5',
    lighten2: '#aed581',
    lighten1: '#9ccc65',
    darken1: '#7cb342',
    darken2: '#689f38',
    darken3: '#558b2f',
    darken4: '#33691e',
    accent1: '#ccff90',
    accent2: '#b2ff59',
    accent3: '#76ff03',
    accent4: '#64dd17',
  },
  wA = {
    base: '#cddc39',
    lighten5: '#f9fbe7',
    lighten4: '#f0f4c3',
    lighten3: '#e6ee9c',
    lighten2: '#dce775',
    lighten1: '#d4e157',
    darken1: '#c0ca33',
    darken2: '#afb42b',
    darken3: '#9e9d24',
    darken4: '#827717',
    accent1: '#f4ff81',
    accent2: '#eeff41',
    accent3: '#c6ff00',
    accent4: '#aeea00',
  },
  kA = {
    base: '#ffeb3b',
    lighten5: '#fffde7',
    lighten4: '#fff9c4',
    lighten3: '#fff59d',
    lighten2: '#fff176',
    lighten1: '#ffee58',
    darken1: '#fdd835',
    darken2: '#fbc02d',
    darken3: '#f9a825',
    darken4: '#f57f17',
    accent1: '#ffff8d',
    accent2: '#ffff00',
    accent3: '#ffea00',
    accent4: '#ffd600',
  },
  CA = {
    base: '#ffc107',
    lighten5: '#fff8e1',
    lighten4: '#ffecb3',
    lighten3: '#ffe082',
    lighten2: '#ffd54f',
    lighten1: '#ffca28',
    darken1: '#ffb300',
    darken2: '#ffa000',
    darken3: '#ff8f00',
    darken4: '#ff6f00',
    accent1: '#ffe57f',
    accent2: '#ffd740',
    accent3: '#ffc400',
    accent4: '#ffab00',
  },
  xA = {
    base: '#ff9800',
    lighten5: '#fff3e0',
    lighten4: '#ffe0b2',
    lighten3: '#ffcc80',
    lighten2: '#ffb74d',
    lighten1: '#ffa726',
    darken1: '#fb8c00',
    darken2: '#f57c00',
    darken3: '#ef6c00',
    darken4: '#e65100',
    accent1: '#ffd180',
    accent2: '#ffab40',
    accent3: '#ff9100',
    accent4: '#ff6d00',
  },
  _A = {
    base: '#ff5722',
    lighten5: '#fbe9e7',
    lighten4: '#ffccbc',
    lighten3: '#ffab91',
    lighten2: '#ff8a65',
    lighten1: '#ff7043',
    darken1: '#f4511e',
    darken2: '#e64a19',
    darken3: '#d84315',
    darken4: '#bf360c',
    accent1: '#ff9e80',
    accent2: '#ff6e40',
    accent3: '#ff3d00',
    accent4: '#dd2c00',
  },
  PA = {
    base: '#795548',
    lighten5: '#efebe9',
    lighten4: '#d7ccc8',
    lighten3: '#bcaaa4',
    lighten2: '#a1887f',
    lighten1: '#8d6e63',
    darken1: '#6d4c41',
    darken2: '#5d4037',
    darken3: '#4e342e',
    darken4: '#3e2723',
  },
  VA = {
    base: '#607d8b',
    lighten5: '#eceff1',
    lighten4: '#cfd8dc',
    lighten3: '#b0bec5',
    lighten2: '#90a4ae',
    lighten1: '#78909c',
    darken1: '#546e7a',
    darken2: '#455a64',
    darken3: '#37474f',
    darken4: '#263238',
  },
  IA = {
    base: '#9e9e9e',
    lighten5: '#fafafa',
    lighten4: '#f5f5f5',
    lighten3: '#eeeeee',
    lighten2: '#e0e0e0',
    lighten1: '#bdbdbd',
    darken1: '#757575',
    darken2: '#616161',
    darken3: '#424242',
    darken4: '#212121',
  },
  TA = { black: '#000000', white: '#ffffff', transparent: '#ffffff00' },
  AA = {
    red: cA,
    pink: dA,
    purple: fA,
    deepPurple: vA,
    indigo: mA,
    blue: hA,
    lightBlue: gA,
    cyan: yA,
    teal: bA,
    green: pA,
    lightGreen: SA,
    lime: wA,
    yellow: kA,
    amber: CA,
    orange: xA,
    deepOrange: _A,
    brown: PA,
    blueGrey: VA,
    grey: IA,
    shades: TA,
  },
  EA = $(
    {
      swatches: { type: Array, default: () => DA(AA) },
      disabled: Boolean,
      color: Object,
      maxHeight: [Number, String],
      ...be(),
    },
    'VColorPickerSwatches'
  )
function DA(e) {
  return Object.keys(e).map((t) => {
    const n = e[t]
    return n.base
      ? [
          n.base,
          n.darken4,
          n.darken3,
          n.darken2,
          n.darken1,
          n.lighten1,
          n.lighten2,
          n.lighten3,
          n.lighten4,
          n.lighten5,
        ]
      : [n.black, n.white, n.transparent]
  })
}
const RA = un({
    name: 'VColorPickerSwatches',
    props: EA(),
    emits: { 'update:color': (e) => !0 },
    setup(e, t) {
      let { emit: n } = t
      return (
        ne(() =>
          x(
            'div',
            {
              class: ee(['v-color-picker-swatches', e.class]),
              style: ce([{ maxHeight: fe(e.maxHeight) }, e.style]),
            },
            [
              x('div', null, [
                e.swatches.map((a) =>
                  x('div', { class: 'v-color-picker-swatches__swatch' }, [
                    a.map((l) => {
                      const o = on(l),
                        i = ni(o),
                        r = cy(o)
                      return x(
                        'div',
                        {
                          class: 'v-color-picker-swatches__color',
                          onClick: () => i && n('update:color', i),
                        },
                        [
                          x('div', { style: { background: r } }, [
                            e.color && kt(e.color, i)
                              ? w(
                                  Le,
                                  {
                                    size: 'x-small',
                                    icon: '$success',
                                    color: D1(l, '#FFFFFF') > 2 ? 'white' : 'black',
                                  },
                                  null
                                )
                              : void 0,
                          ]),
                        ]
                      )
                    }),
                  ])
                ),
              ]),
            ]
          )
        ),
        {}
      )
    },
  }),
  MA = da('v-picker-title'),
  Ad = $(
    {
      color: String,
      ...Ut(),
      ...be(),
      ...ft(),
      ...yt(),
      ...fa(),
      ...Jl(),
      ...Je(),
      ...Ie(),
      ...Be(),
    },
    'VSheet'
  ),
  Ko = J()({
    name: 'VSheet',
    props: Ad(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: a } = $e(e),
        { backgroundColorClasses: l, backgroundColorStyles: o } = He(() => e.color),
        { borderClasses: i } = Jt(e),
        { dimensionStyles: r } = vt(e),
        { elevationClasses: s } = xt(e),
        { locationStyles: c } = vl(e),
        { positionClasses: u } = Ql(e),
        { roundedClasses: d } = ot(e)
      return (
        ne(() =>
          w(
            e.tag,
            {
              class: ee(['v-sheet', a.value, l.value, i.value, s.value, u.value, d.value, e.class]),
              style: ce([o.value, r.value, c.value, e.style]),
            },
            n
          )
        ),
        {}
      )
    },
  }),
  Yr = $(
    {
      bgColor: String,
      divided: Boolean,
      landscape: Boolean,
      title: String,
      hideHeader: Boolean,
      hideTitle: Boolean,
      ...Ad(),
    },
    'VPicker'
  ),
  Gl = J()({
    name: 'VPicker',
    props: Yr(),
    setup(e, t) {
      let { slots: n } = t
      const { backgroundColorClasses: a, backgroundColorStyles: l } = He(() => e.color)
      return (
        ne(() => {
          const o = Ko.filterProps(e),
            i = !e.hideTitle && !!(e.title || n.title)
          return w(
            Ko,
            Z(o, {
              color: e.bgColor,
              class: [
                'v-picker',
                {
                  'v-picker--divided': e.divided,
                  'v-picker--landscape': e.landscape,
                  'v-picker--with-actions': !!n.actions,
                },
                e.class,
              ],
              style: e.style,
            }),
            {
              default: () => [
                !e.hideHeader &&
                  x('div', { key: 'header', class: ee([a.value]), style: ce([l.value]) }, [
                    i &&
                      w(MA, { key: 'picker-title' }, { default: () => [n.title?.() ?? e.title] }),
                    n.header && x('div', { class: 'v-picker__header' }, [n.header()]),
                  ]),
                x('div', { class: 'v-picker__body' }, [n.default?.()]),
                n.actions &&
                  w(
                    Ae,
                    { defaults: { VBtn: { slim: !0, variant: 'text' } } },
                    { default: () => [x('div', { class: 'v-picker__actions' }, [n.actions()])] }
                  ),
              ],
            }
          )
        }),
        {}
      )
    },
  }),
  BA = $(
    {
      canvasHeight: { type: [String, Number], default: 150 },
      disabled: Boolean,
      dotSize: { type: [Number, String], default: 10 },
      hideCanvas: Boolean,
      hideSliders: Boolean,
      hideInputs: Boolean,
      mode: { type: String, default: 'rgba', validator: (e) => Object.keys(Ga).includes(e) },
      modes: {
        type: Array,
        default: () => Object.keys(Ga),
        validator: (e) => Array.isArray(e) && e.every((t) => Object.keys(Ga).includes(t)),
      },
      showSwatches: Boolean,
      swatches: Array,
      swatchesMaxHeight: { type: [Number, String], default: 150 },
      modelValue: { type: [Object, String] },
      ...Yr({ hideHeader: !0 }),
      ...Zt(ap(), ['hideEyeDropper', 'eyeDropperIcon']),
    },
    'VColorPicker'
  ),
  LA = un({
    name: 'VColorPicker',
    props: BA(),
    emits: { 'update:modelValue': (e) => !0, 'update:mode': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = we(e, 'mode'),
        l = ae(null),
        o = we(
          e,
          'modelValue',
          void 0,
          (u) => {
            if (u == null || u === '') return null
            let d
            try {
              d = ni(on(u))
            } catch {
              return null
            }
            return d
          },
          (u) => (u ? JT(u, e.modelValue) : null)
        ),
        i = C(() => (o.value ? { ...o.value, h: l.value ?? o.value.h } : null)),
        { rtlClasses: r } = gt()
      let s = !0
      ue(
        o,
        (u) => {
          if (!s) {
            s = !0
            return
          }
          u && (l.value = u.h)
        },
        { immediate: !0 }
      )
      const c = (u) => {
        ;((s = !1), (l.value = u.h), (o.value = u))
      }
      return (
        Xl(() => {
          e.modes.includes(a.value) || (a.value = e.modes[0])
        }),
        lt({ VSlider: { color: void 0, trackColor: void 0, trackFillColor: void 0 } }),
        ne(() => {
          const u = Gl.filterProps(e)
          return w(
            Gl,
            Z(u, {
              class: ['v-color-picker', r.value, e.class],
              style: [{ '--v-color-picker-color-hsv': dy({ ...(i.value ?? Pl), a: 1 }) }, e.style],
            }),
            {
              ...n,
              default: () =>
                x(he, null, [
                  !e.hideCanvas &&
                    w(
                      XT,
                      {
                        key: 'canvas',
                        color: i.value,
                        'onUpdate:color': c,
                        disabled: e.disabled,
                        dotSize: e.dotSize,
                        width: e.width,
                        height: e.canvasHeight,
                      },
                      null
                    ),
                  (!e.hideSliders || !e.hideInputs) &&
                    x('div', { key: 'controls', class: 'v-color-picker__controls' }, [
                      !e.hideSliders &&
                        w(
                          uA,
                          {
                            key: 'preview',
                            color: i.value,
                            'onUpdate:color': c,
                            hideAlpha: !a.value.endsWith('a'),
                            disabled: e.disabled,
                            hideEyeDropper: e.hideEyeDropper,
                            eyeDropperIcon: e.eyeDropperIcon,
                          },
                          null
                        ),
                      !e.hideInputs &&
                        w(
                          lA,
                          {
                            key: 'edit',
                            modes: e.modes,
                            mode: a.value,
                            'onUpdate:mode': (d) => (a.value = d),
                            color: i.value,
                            'onUpdate:color': c,
                            disabled: e.disabled,
                          },
                          null
                        ),
                    ]),
                  e.showSwatches &&
                    w(
                      RA,
                      {
                        key: 'swatches',
                        color: i.value,
                        'onUpdate:color': c,
                        maxHeight: e.swatchesMaxHeight,
                        swatches: e.swatches,
                        disabled: e.disabled,
                      },
                      null
                    ),
                ]),
            }
          )
        }),
        {}
      )
    },
  }),
  OA = $(
    {
      autoSelectFirst: { type: [Boolean, String] },
      clearOnSelect: { type: Boolean, default: !0 },
      delimiters: Array,
      ...lo({ filterKeys: ['title'] }),
      ..._d({ hideNoData: !0, returnObject: !0 }),
      ...je(vi({ modelValue: null, role: 'combobox' }), [
        'validationValue',
        'dirty',
        'appendInnerIcon',
      ]),
      ...Vn({ transition: !1 }),
    },
    'VCombobox'
  ),
  $A = J()({
    name: 'VCombobox',
    props: OA(),
    emits: {
      'update:focused': (e) => !0,
      'update:modelValue': (e) => !0,
      'update:search': (e) => !0,
      'update:menu': (e) => !0,
    },
    setup(e, t) {
      let { emit: n, slots: a } = t
      const { t: l } = ze(),
        o = ae(),
        i = oe(!1),
        r = oe(!0),
        s = oe(!1),
        c = ae(),
        u = ae(),
        d = oe(-1)
      let f = !1
      const { items: v, transformIn: g, transformOut: h } = gd(e),
        { textColorClasses: m, textColorStyles: b } = Vt(() => o.value?.color),
        y = we(
          e,
          'modelValue',
          [],
          (T) => g(nt(T)),
          (T) => {
            const z = h(T)
            return e.multiple ? z : (z[0] ?? null)
          }
        ),
        p = to(e),
        S = C(() => !!(e.chips || a.chip)),
        k = C(() => S.value || !!a.selection),
        _ = oe(!e.multiple && !k.value ? (y.value[0]?.title ?? '') : ''),
        P = C({
          get: () => _.value,
          set: async (T) => {
            if (
              ((_.value = T ?? ''),
              !e.multiple &&
                !k.value &&
                ((y.value = [Sn(e, T)]), Re(() => u.value?.scrollToIndex(0))),
              T && e.multiple && e.delimiters?.length)
            ) {
              const z = e.delimiters.map(ur).join('|'),
                X = T.split(new RegExp(`(?:${z})+`))
              if (X.length > 1) {
                for (let N of X) ((N = N.trim()), N && (ie(Sn(e, N)), await Re()))
                _.value = ''
              }
            }
            ;(T || (d.value = -1), (r.value = !T))
          },
        }),
        A = C(() =>
          typeof e.counterValue == 'function'
            ? e.counterValue(y.value)
            : typeof e.counterValue == 'number'
              ? e.counterValue
              : e.multiple
                ? y.value.length
                : P.value.length
        ),
        { filteredItems: D, getMatches: E } = oo(e, v, () => (r.value ? '' : P.value)),
        R = C(() =>
          e.hideSelected
            ? D.value.filter((T) => !y.value.some((z) => z.value === T.value))
            : D.value
        ),
        V = C(() => (e.hideNoData && !R.value.length) || p.isReadonly.value || p.isDisabled.value),
        M = we(e, 'menu'),
        F = C({
          get: () => M.value,
          set: (T) => {
            ;(M.value && !T && c.value?.ΨopenChildren.size) || (T && V.value) || (M.value = T)
          },
        }),
        { menuId: G, ariaExpanded: W, ariaControls: te, ariaLabel: H } = xd(e, F)
      ;(ue(_, (T) => {
        ;(f ? Re(() => (f = !1)) : i.value && !F.value && (F.value = !0), n('update:search', T))
      }),
        ue(y, (T) => {
          !e.multiple && !k.value && (_.value = T[0]?.title ?? '')
        }))
      const O = C(() => y.value.map((T) => T.value)),
        j = C(
          () =>
            (e.autoSelectFirst === !0 ||
              (e.autoSelectFirst === 'exact' && P.value === R.value[0]?.title)) &&
            R.value.length > 0 &&
            !r.value &&
            !s.value
        ),
        U = ae(),
        Y = Cd(U, o)
      function K(T) {
        ;((f = !0), e.openOnClear && (F.value = !0))
      }
      function se() {
        V.value || (F.value = !0)
      }
      function de(T) {
        V.value || (i.value && (T.preventDefault(), T.stopPropagation()), (F.value = !F.value))
      }
      function ye(T) {
        ;(jl(T) || T.key === 'Backspace') && o.value?.focus()
      }
      function L(T) {
        if (t1(T) || p.isReadonly.value) return
        const z = o.value?.selectionStart,
          X = y.value.length
        if (
          (['Enter', 'ArrowDown', 'ArrowUp'].includes(T.key) && T.preventDefault(),
          ['Enter', 'ArrowDown'].includes(T.key) && (F.value = !0),
          ['Escape'].includes(T.key) && (F.value = !1),
          ['Enter', 'Escape', 'Tab'].includes(T.key) &&
            (j.value &&
              ['Enter', 'Tab'].includes(T.key) &&
              !y.value.some((N) => {
                let { value: Q } = N
                return Q === R.value[0].value
              }) &&
              ie(D.value[0]),
            (r.value = !0)),
          T.key === 'ArrowDown' && j.value && U.value?.focus('next'),
          T.key === 'Enter' && P.value && (ie(Sn(e, P.value)), k.value && (_.value = '')),
          ['Backspace', 'Delete'].includes(T.key))
        ) {
          if (!e.multiple && k.value && y.value.length > 0 && !P.value) return ie(y.value[0], !1)
          if (~d.value) {
            T.preventDefault()
            const N = d.value
            ;(ie(y.value[d.value], !1), (d.value = N >= X - 1 ? X - 2 : N))
          } else T.key === 'Backspace' && !P.value && (d.value = X - 1)
          return
        }
        if (e.multiple)
          if (T.key === 'ArrowLeft') {
            if (d.value < 0 && z && z > 0) return
            const N = d.value > -1 ? d.value - 1 : X - 1
            y.value[N]
              ? (d.value = N)
              : ((d.value = -1), o.value?.setSelectionRange(P.value.length, P.value.length))
          } else if (T.key === 'ArrowRight') {
            if (d.value < 0) return
            const N = d.value + 1
            y.value[N] ? (d.value = N) : ((d.value = -1), o.value?.setSelectionRange(0, 0))
          } else ~d.value && jl(T) && (d.value = -1)
      }
      function q() {
        e.eager && u.value?.calculateVisibleItems()
      }
      function le() {
        i.value && ((r.value = !0), o.value?.focus())
      }
      function ie(T) {
        let z = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
        if (!(!T || T.props.disabled))
          if (e.multiple) {
            const X = y.value.findIndex((Q) => (e.valueComparator || kt)(Q.value, T.value)),
              N = z ?? !~X
            if (~X) {
              const Q = N ? [...y.value, T] : [...y.value]
              ;(Q.splice(X, 1), (y.value = Q))
            } else N && (y.value = [...y.value, T])
            e.clearOnSelect && (P.value = '')
          } else {
            const X = z !== !1
            ;((y.value = X ? [T] : []),
              (_.value = X && !k.value ? T.title : ''),
              Re(() => {
                ;((F.value = !1), (r.value = !0))
              }))
          }
      }
      function Ce(T) {
        ;((i.value = !0),
          setTimeout(() => {
            s.value = !0
          }))
      }
      function pe(T) {
        s.value = !1
      }
      function I(T) {
        ;(T == null || (T === '' && !e.multiple && !k.value)) && (y.value = [])
      }
      return (
        ue(i, (T, z) => {
          if (!(T || T === z) && ((d.value = -1), (F.value = !1), P.value)) {
            if (e.multiple) {
              ie(Sn(e, P.value))
              return
            }
            if (!k.value) return
            y.value.some((X) => {
              let { title: N } = X
              return N === P.value
            })
              ? (_.value = '')
              : ie(Sn(e, P.value))
          }
        }),
        ue(F, () => {
          if (!e.hideSelected && F.value && y.value.length) {
            const T = R.value.findIndex((z) =>
              y.value.some((X) => (e.valueComparator || kt)(X.value, z.value))
            )
            Ne &&
              window.requestAnimationFrame(() => {
                T >= 0 && u.value?.scrollToIndex(T)
              })
          }
        }),
        ue(v, (T, z) => {
          F.value || (i.value && !z.length && T.length && (F.value = !0))
        }),
        ne(() => {
          const T = !!(
              !e.hideNoData ||
              R.value.length ||
              a['prepend-item'] ||
              a['append-item'] ||
              a['no-data']
            ),
            z = y.value.length > 0,
            X = ia.filterProps(e)
          return w(
            ia,
            Z({ ref: o }, X, {
              modelValue: P.value,
              'onUpdate:modelValue': [(N) => (P.value = N), I],
              focused: i.value,
              'onUpdate:focused': (N) => (i.value = N),
              validationValue: y.externalValue,
              counterValue: A.value,
              dirty: z,
              class: [
                'v-combobox',
                {
                  'v-combobox--active-menu': F.value,
                  'v-combobox--chips': !!e.chips,
                  'v-combobox--selection-slot': !!k.value,
                  'v-combobox--selecting-index': d.value > -1,
                  [`v-combobox--${e.multiple ? 'multiple' : 'single'}`]: !0,
                },
                e.class,
              ],
              style: e.style,
              readonly: p.isReadonly.value,
              placeholder: z ? void 0 : e.placeholder,
              'onClick:clear': K,
              'onMousedown:control': se,
              onKeydown: L,
              'aria-expanded': W.value,
              'aria-controls': te.value,
            }),
            {
              ...a,
              default: () =>
                x(he, null, [
                  w(
                    Kl,
                    Z(
                      {
                        id: G.value,
                        ref: c,
                        modelValue: F.value,
                        'onUpdate:modelValue': (N) => (F.value = N),
                        activator: 'parent',
                        contentClass: 'v-combobox__content',
                        disabled: V.value,
                        eager: e.eager,
                        maxHeight: 310,
                        openOnClick: !1,
                        closeOnContentClick: !1,
                        transition: e.transition,
                        onAfterEnter: q,
                        onAfterLeave: le,
                      },
                      e.menuProps
                    ),
                    {
                      default: () => [
                        T &&
                          w(
                            Ul,
                            Z(
                              {
                                ref: U,
                                filterable: !0,
                                selected: O.value,
                                selectStrategy: e.multiple ? 'independent' : 'single-independent',
                                onMousedown: (N) => N.preventDefault(),
                                selectable: !0,
                                onKeydown: ye,
                                onFocusin: Ce,
                                onFocusout: pe,
                                tabindex: '-1',
                                'aria-live': 'polite',
                                color: e.itemColor ?? e.color,
                              },
                              Y,
                              e.listProps
                            ),
                            {
                              default: () => [
                                a['prepend-item']?.(),
                                !R.value.length &&
                                  !e.hideNoData &&
                                  (a['no-data']?.() ??
                                    w(_n, { key: 'no-data', title: l(e.noDataText) }, null)),
                                w(
                                  Ur,
                                  { ref: u, renderless: !0, items: R.value, itemKey: 'value' },
                                  {
                                    default: (N) => {
                                      let { item: Q, index: ve, itemRef: ge } = N
                                      const me = Z(Q.props, {
                                        ref: ge,
                                        key: Q.value,
                                        active: j.value && ve === 0 ? !0 : void 0,
                                        onClick: () => ie(Q, null),
                                      })
                                      return Q.type === 'divider'
                                        ? (a.divider?.({ props: Q.raw, index: ve }) ??
                                            w(rn, Z(Q.props, { key: `divider-${ve}` }), null))
                                        : Q.type === 'subheader'
                                          ? (a.subheader?.({ props: Q.raw, index: ve }) ??
                                            w(ao, Z(Q.props, { key: `subheader-${ve}` }), null))
                                          : (a.item?.({ item: Q, index: ve, props: me }) ??
                                            w(_n, Z(me, { role: 'option' }), {
                                              prepend: (re) => {
                                                let { isSelected: xe } = re
                                                return x(he, null, [
                                                  e.multiple && !e.hideSelected
                                                    ? w(
                                                        Fn,
                                                        {
                                                          key: Q.value,
                                                          modelValue: xe,
                                                          ripple: !1,
                                                          tabindex: '-1',
                                                        },
                                                        null
                                                      )
                                                    : void 0,
                                                  Q.props.prependAvatar &&
                                                    w(sn, { image: Q.props.prependAvatar }, null),
                                                  Q.props.prependIcon &&
                                                    w(Le, { icon: Q.props.prependIcon }, null),
                                                ])
                                              },
                                              title: () =>
                                                r.value
                                                  ? Q.title
                                                  : Nb('v-combobox', Q.title, E(Q)?.title),
                                            }))
                                    },
                                  }
                                ),
                                a['append-item']?.(),
                              ],
                            }
                          ),
                      ],
                    }
                  ),
                  y.value.map((N, Q) => {
                    function ve(xe) {
                      ;(xe.stopPropagation(), xe.preventDefault(), ie(N, !1))
                    }
                    const ge = {
                        'onClick:close': ve,
                        onKeydown(xe) {
                          ;(xe.key !== 'Enter' && xe.key !== ' ') ||
                            (xe.preventDefault(), xe.stopPropagation(), ve(xe))
                        },
                        onMousedown(xe) {
                          ;(xe.preventDefault(), xe.stopPropagation())
                        },
                        modelValue: !0,
                        'onUpdate:modelValue': void 0,
                      },
                      me = S.value ? !!a.chip : !!a.selection,
                      re = me
                        ? Br(
                            S.value
                              ? a.chip({ item: N, index: Q, props: ge })
                              : a.selection({ item: N, index: Q })
                          )
                        : void 0
                    if (!(me && !re))
                      return x(
                        'div',
                        {
                          key: N.value,
                          class: ee([
                            'v-combobox__selection',
                            Q === d.value && ['v-combobox__selection--selected', m.value],
                          ]),
                          style: ce(Q === d.value ? b.value : {}),
                        },
                        [
                          S.value
                            ? a.chip
                              ? w(
                                  Ae,
                                  {
                                    key: 'chip-defaults',
                                    defaults: {
                                      VChip: {
                                        closable: e.closableChips,
                                        size: 'small',
                                        text: N.title,
                                      },
                                    },
                                  },
                                  { default: () => [re] }
                                )
                              : w(
                                  no,
                                  Z(
                                    {
                                      key: 'chip',
                                      closable: e.closableChips,
                                      size: 'small',
                                      text: N.title,
                                      disabled: N.props.disabled,
                                    },
                                    ge
                                  ),
                                  null
                                )
                            : (re ??
                              x('span', { class: 'v-combobox__selection-text' }, [
                                N.title,
                                e.multiple &&
                                  Q < y.value.length - 1 &&
                                  x('span', { class: 'v-combobox__selection-comma' }, [qt(',')]),
                              ])),
                        ]
                      )
                  }),
                ]),
              'append-inner': function () {
                for (var N = arguments.length, Q = new Array(N), ve = 0; ve < N; ve++)
                  Q[ve] = arguments[ve]
                return x(he, null, [
                  a['append-inner']?.(...Q),
                  (!e.hideNoData || e.items.length) && e.menuIcon
                    ? w(
                        Le,
                        {
                          class: 'v-combobox__menu-icon',
                          color: o.value?.fieldIconColor,
                          icon: e.menuIcon,
                          onMousedown: de,
                          onClick: ay,
                          'aria-label': H.value,
                          title: H.value,
                          tabindex: '-1',
                        },
                        null
                      )
                    : void 0,
                ])
              },
            }
          )
        }),
        _t(
          {
            isFocused: i,
            isPristine: r,
            menu: F,
            search: P,
            selectionIndex: d,
            filteredItems: D,
            select: ie,
          },
          o
        )
      )
    },
  }),
  FA = $(
    {
      modelValue: null,
      color: String,
      cancelText: { type: String, default: '$vuetify.confirmEdit.cancel' },
      okText: { type: String, default: '$vuetify.confirmEdit.ok' },
      disabled: { type: [Boolean, Array], default: void 0 },
      hideActions: Boolean,
    },
    'VConfirmEdit'
  ),
  NA = J()({
    name: 'VConfirmEdit',
    props: FA(),
    emits: { cancel: () => !0, save: (e) => !0, 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { emit: n, slots: a } = t
      const l = we(e, 'modelValue'),
        o = ae()
      qe(() => {
        o.value = structuredClone(_e(l.value))
      })
      const { t: i } = ze(),
        r = C(() => kt(l.value, o.value))
      function s(h) {
        return typeof e.disabled == 'boolean'
          ? e.disabled
          : Array.isArray(e.disabled)
            ? e.disabled.includes(h)
            : r.value
      }
      const c = C(() => s('save')),
        u = C(() => s('cancel'))
      function d() {
        ;((l.value = o.value), n('save', o.value))
      }
      function f() {
        ;((o.value = structuredClone(_e(l.value))), n('cancel'))
      }
      function v(h) {
        return x(he, null, [
          w(
            Me,
            Z(
              {
                disabled: u.value,
                variant: 'text',
                color: e.color,
                onClick: f,
                text: i(e.cancelText),
              },
              h
            ),
            null
          ),
          w(
            Me,
            Z(
              { disabled: c.value, variant: 'text', color: e.color, onClick: d, text: i(e.okText) },
              h
            ),
            null
          ),
        ])
      }
      let g = !1
      return (
        ne(() =>
          x(he, null, [
            a.default?.({
              model: o,
              save: d,
              cancel: f,
              isPristine: r.value,
              get actions() {
                return ((g = !0), v)
              },
            }),
            !e.hideActions && !g && v(),
          ])
        ),
        { save: d, cancel: f, isPristine: r }
      )
    },
  }),
  lp = $(
    { expandOnClick: Boolean, showExpand: Boolean, expanded: { type: Array, default: () => [] } },
    'DataTable-expand'
  ),
  op = Symbol.for('vuetify:datatable:expanded')
function qr(e) {
  const t = B(() => e.expandOnClick),
    n = we(
      e,
      'expanded',
      e.expanded,
      (r) => new Set(r),
      (r) => [...r.values()]
    )
  function a(r, s) {
    const c = new Set(n.value),
      u = _e(r.value)
    if (s) c.add(u)
    else {
      const d = [...n.value].find((f) => _e(f) === u)
      c.delete(d)
    }
    n.value = c
  }
  function l(r) {
    const s = _e(r.value)
    return [...n.value].some((c) => _e(c) === s)
  }
  function o(r) {
    a(r, !l(r))
  }
  const i = { expand: a, expanded: n, expandOnClick: t, isExpanded: l, toggleExpand: o }
  return (Fe(op, i), i)
}
function ip() {
  const e = Ve(op)
  if (!e) throw new Error('foo')
  return e
}
const Ed = $({ groupBy: { type: Array, default: () => [] } }, 'DataTable-group'),
  rp = Symbol.for('vuetify:data-table-group')
function Dd(e) {
  return { groupBy: we(e, 'groupBy') }
}
function Xr(e) {
  const { disableSort: t, groupBy: n, sortBy: a } = e,
    l = ae(new Set()),
    o = C(() =>
      n.value.map((u) => ({ ...u, order: u.order ?? !1 })).concat(t?.value ? [] : a.value)
    )
  function i(u) {
    return l.value.has(u.id)
  }
  function r(u) {
    const d = new Set(l.value)
    ;(i(u) ? d.delete(u.id) : d.add(u.id), (l.value = d))
  }
  function s(u) {
    function d(f) {
      const v = []
      for (const g of f.items) 'type' in g && g.type === 'group' ? v.push(...d(g)) : v.push(g)
      return [...new Set(v)]
    }
    return d({ items: u })
  }
  const c = {
    sortByWithGroups: o,
    toggleGroup: r,
    opened: l,
    groupBy: n,
    extractRows: s,
    isGroupOpen: i,
  }
  return (Fe(rp, c), c)
}
function sp() {
  const e = Ve(rp)
  if (!e) throw new Error('Missing group!')
  return e
}
function HA(e, t) {
  if (!e.length) return []
  const n = new Map()
  for (const a of e) {
    const l = Za(a.raw, t)
    ;(n.has(l) || n.set(l, []), n.get(l).push(a))
  }
  return n
}
function up(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
    a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 'root'
  if (!t.length) return []
  const l = HA(e, t[0]),
    o = [],
    i = t.slice(1)
  return (
    l.forEach((r, s) => {
      const c = t[0],
        u = `${a}_${c}_${s}`
      o.push({
        depth: n,
        id: u,
        key: c,
        value: s,
        items: i.length ? up(r, i, n + 1, u) : r,
        type: 'group',
      })
    }),
    o
  )
}
function cp(e, t, n) {
  const a = []
  for (const l of e)
    'type' in l && l.type === 'group'
      ? (l.value != null && a.push(l),
        (t.has(l.id) || l.value == null) &&
          (a.push(...cp(l.items, t, n)), n && a.push({ ...l, type: 'group-summary' })))
      : a.push(l)
  return a
}
function Zr(e, t, n, a) {
  return {
    flatItems: C(() => {
      if (!t.value.length) return e.value
      const o = up(
        e.value,
        t.value.map((i) => i.key)
      )
      return cp(o, n.value, Ft(a))
    }),
  }
}
function Jr(e) {
  let { page: t, itemsPerPage: n, sortBy: a, groupBy: l, search: o } = e
  const i = rt('VDataTable'),
    r = () => ({
      page: t.value,
      itemsPerPage: n.value,
      sortBy: a.value,
      groupBy: l.value,
      search: o.value,
    })
  let s = null
  ue(
    r,
    (c) => {
      kt(s, c) ||
        (s && s.search !== c.search && (t.value = 1), i.emit('update:options', c), (s = c))
    },
    { deep: !0, immediate: !0 }
  )
}
const Rd = $(
    {
      page: { type: [Number, String], default: 1 },
      itemsPerPage: { type: [Number, String], default: 10 },
    },
    'DataTable-paginate'
  ),
  dp = Symbol.for('vuetify:data-table-pagination')
function Md(e) {
  const t = we(e, 'page', void 0, (a) => Number(a ?? 1)),
    n = we(e, 'itemsPerPage', void 0, (a) => Number(a ?? 10))
  return { page: t, itemsPerPage: n }
}
function Bd(e) {
  const { page: t, itemsPerPage: n, itemsLength: a } = e,
    l = C(() => (n.value === -1 ? 0 : n.value * (t.value - 1))),
    o = C(() => (n.value === -1 ? a.value : Math.min(a.value, l.value + n.value))),
    i = C(() => (n.value === -1 || a.value === 0 ? 1 : Math.ceil(a.value / n.value)))
  ue([t, i], () => {
    t.value > i.value && (t.value = i.value)
  })
  function r(f) {
    ;((n.value = f), (t.value = 1))
  }
  function s() {
    t.value = Ge(t.value + 1, 1, i.value)
  }
  function c() {
    t.value = Ge(t.value - 1, 1, i.value)
  }
  function u(f) {
    t.value = Ge(f, 1, i.value)
  }
  const d = {
    page: t,
    itemsPerPage: n,
    startIndex: l,
    stopIndex: o,
    pageCount: i,
    itemsLength: a,
    nextPage: s,
    prevPage: c,
    setPage: u,
    setItemsPerPage: r,
  }
  return (Fe(dp, d), d)
}
function jA() {
  const e = Ve(dp)
  if (!e) throw new Error('Missing pagination!')
  return e
}
function fp(e) {
  const t = rt('usePaginatedItems'),
    { items: n, startIndex: a, stopIndex: l, itemsPerPage: o } = e,
    i = C(() => (o.value <= 0 ? n.value : n.value.slice(a.value, l.value)))
  return (
    ue(
      i,
      (r) => {
        t.emit('update:currentItems', r)
      },
      { immediate: !0 }
    ),
    { paginatedItems: i }
  )
}
const zA = {
    showSelectAll: !1,
    allSelected: () => [],
    select: (e) => {
      let { items: t, value: n } = e
      return new Set(n ? [t[0]?.value] : [])
    },
    selectAll: (e) => {
      let { selected: t } = e
      return t
    },
  },
  vp = {
    showSelectAll: !0,
    allSelected: (e) => {
      let { currentPage: t } = e
      return t
    },
    select: (e) => {
      let { items: t, value: n, selected: a } = e
      for (const l of t) n ? a.add(l.value) : a.delete(l.value)
      return a
    },
    selectAll: (e) => {
      let { value: t, currentPage: n, selected: a } = e
      return vp.select({ items: n, value: t, selected: a })
    },
  },
  mp = {
    showSelectAll: !0,
    allSelected: (e) => {
      let { allItems: t } = e
      return t
    },
    select: (e) => {
      let { items: t, value: n, selected: a } = e
      for (const l of t) n ? a.add(l.value) : a.delete(l.value)
      return a
    },
    selectAll: (e) => {
      let { value: t, allItems: n, selected: a } = e
      return mp.select({ items: n, value: t, selected: a })
    },
  },
  hp = $(
    {
      showSelect: Boolean,
      selectStrategy: { type: [String, Object], default: 'page' },
      modelValue: { type: Array, default: () => [] },
      valueComparator: { type: Function, default: kt },
    },
    'DataTable-select'
  ),
  gp = Symbol.for('vuetify:data-table-selection')
function Qr(e, t) {
  let { allItems: n, currentPage: a } = t
  const l = we(
      e,
      'modelValue',
      e.modelValue,
      (y) =>
        new Set(nt(y).map((p) => n.value.find((S) => e.valueComparator(p, S.value))?.value ?? p)),
      (y) => [...y.values()]
    ),
    o = C(() => n.value.filter((y) => y.selectable)),
    i = C(() => a.value.filter((y) => y.selectable)),
    r = C(() => {
      if (typeof e.selectStrategy == 'object') return e.selectStrategy
      switch (e.selectStrategy) {
        case 'single':
          return zA
        case 'all':
          return mp
        case 'page':
        default:
          return vp
      }
    }),
    s = oe(null)
  function c(y) {
    return nt(y).every((p) => l.value.has(p.value))
  }
  function u(y) {
    return nt(y).some((p) => l.value.has(p.value))
  }
  function d(y, p) {
    const S = r.value.select({ items: y, value: p, selected: new Set(l.value) })
    l.value = S
  }
  function f(y, p, S) {
    const k = []
    if (
      ((p = p ?? a.value.findIndex((_) => _.value === y.value)),
      e.selectStrategy !== 'single' && S?.shiftKey && s.value !== null)
    ) {
      const [_, P] = [s.value, p].sort((A, D) => A - D)
      k.push(...a.value.slice(_, P + 1).filter((A) => A.selectable))
    } else (k.push(y), (s.value = p))
    d(k, !c([y]))
  }
  function v(y) {
    const p = r.value.selectAll({
      value: y,
      allItems: o.value,
      currentPage: i.value,
      selected: new Set(l.value),
    })
    l.value = p
  }
  const g = C(() => l.value.size > 0),
    h = C(() => {
      const y = r.value.allSelected({ allItems: o.value, currentPage: i.value })
      return !!y.length && c(y)
    }),
    m = B(() => r.value.showSelectAll),
    b = {
      toggleSelect: f,
      select: d,
      selectAll: v,
      isSelected: c,
      isSomeSelected: u,
      someSelected: g,
      allSelected: h,
      showSelectAll: m,
      lastSelectedIndex: s,
      selectStrategy: r,
    }
  return (Fe(gp, b), b)
}
function es() {
  const e = Ve(gp)
  if (!e) throw new Error('Missing selection!')
  return e
}
const yp = $(
    {
      sortBy: { type: Array, default: () => [] },
      customKeySort: Object,
      multiSort: Boolean,
      mustSort: Boolean,
    },
    'DataTable-sort'
  ),
  bp = Symbol.for('vuetify:data-table-sort')
function ts(e) {
  const t = we(e, 'sortBy'),
    n = B(() => e.mustSort),
    a = B(() => e.multiSort)
  return { sortBy: t, mustSort: n, multiSort: a }
}
function ns(e) {
  const { sortBy: t, mustSort: n, multiSort: a, page: l } = e,
    o = (s) => {
      if (s.key == null) return
      let c = t.value.map((d) => ({ ...d })) ?? []
      const u = c.find((d) => d.key === s.key)
      ;(u
        ? u.order === 'desc'
          ? n.value && c.length === 1
            ? (u.order = 'asc')
            : (c = c.filter((d) => d.key !== s.key))
          : (u.order = 'desc')
        : a.value
          ? c.push({ key: s.key, order: 'asc' })
          : (c = [{ key: s.key, order: 'asc' }]),
        (t.value = c),
        l && (l.value = 1))
    }
  function i(s) {
    return !!t.value.find((c) => c.key === s.key)
  }
  const r = { sortBy: t, toggleSort: o, isSorted: i }
  return (Fe(bp, r), r)
}
function pp() {
  const e = Ve(bp)
  if (!e) throw new Error('Missing sort!')
  return e
}
function Ld(e, t, n, a) {
  const l = ze()
  return {
    sortedItems: C(() =>
      n.value.length
        ? WA(t.value, n.value, l.current.value, {
            transform: a?.transform,
            sortFunctions: { ...e.customKeySort, ...a?.sortFunctions?.value },
            sortRawFunctions: a?.sortRawFunctions?.value,
          })
        : t.value
    ),
  }
}
function WA(e, t, n, a) {
  const l = new Intl.Collator(n, { sensitivity: 'accent', usage: 'sort' })
  return e
    .map((i) => [i, a?.transform ? a.transform(i) : i])
    .sort((i, r) => {
      for (let s = 0; s < t.length; s++) {
        let c = !1
        const u = t[s].key,
          d = t[s].order ?? 'asc'
        if (d === !1) continue
        let f = Za(i[1], u),
          v = Za(r[1], u),
          g = i[0].raw,
          h = r[0].raw
        if ((d === 'desc' && (([f, v] = [v, f]), ([g, h] = [h, g])), a?.sortRawFunctions?.[u])) {
          const m = a.sortRawFunctions[u](g, h)
          if (m == null) continue
          if (((c = !0), m)) return m
        }
        if (a?.sortFunctions?.[u]) {
          const m = a.sortFunctions[u](f, v)
          if (m == null) continue
          if (((c = !0), m)) return m
        }
        if (
          !c &&
          (f instanceof Date && v instanceof Date && ((f = f.getTime()), (v = v.getTime())),
          ([f, v] = [f, v].map((m) => (m != null ? m.toString().toLocaleLowerCase() : m))),
          f !== v)
        )
          return Vi(f) && Vi(v)
            ? 0
            : Vi(f)
              ? -1
              : Vi(v)
                ? 1
                : !isNaN(f) && !isNaN(v)
                  ? Number(f) - Number(v)
                  : l.compare(f, v)
      }
      return 0
    })
    .map((i) => {
      let [r] = i
      return r
    })
}
const UA = $(
  {
    items: { type: Array, default: () => [] },
    itemValue: { type: [String, Array, Function], default: 'id' },
    itemSelectable: { type: [String, Array, Function], default: null },
    returnObject: Boolean,
  },
  'DataIterator-items'
)
function KA(e, t) {
  const n = e.returnObject ? t : st(t, e.itemValue),
    a = st(t, e.itemSelectable, !0)
  return { type: 'item', value: n, selectable: a, raw: t }
}
function GA(e, t) {
  const n = []
  for (const a of t) n.push(KA(e, a))
  return n
}
function YA(e) {
  return { items: C(() => GA(e, e.items)) }
}
const qA = $(
    {
      search: String,
      loading: Boolean,
      ...be(),
      ...UA(),
      ...hp(),
      ...yp(),
      ...Rd({ itemsPerPage: 5 }),
      ...lp(),
      ...Ed(),
      ...lo(),
      ...Ie(),
      ...Vn({ transition: { component: Fo, hideOnLeave: !0 } }),
    },
    'VDataIterator'
  ),
  XA = J()({
    name: 'VDataIterator',
    props: qA(),
    emits: {
      'update:modelValue': (e) => !0,
      'update:groupBy': (e) => !0,
      'update:page': (e) => !0,
      'update:itemsPerPage': (e) => !0,
      'update:sortBy': (e) => !0,
      'update:options': (e) => !0,
      'update:expanded': (e) => !0,
      'update:currentItems': (e) => !0,
    },
    setup(e, t) {
      let { slots: n } = t
      const a = we(e, 'groupBy'),
        l = B(() => e.search),
        { items: o } = YA(e),
        { filteredItems: i } = oo(e, o, l, { transform: (U) => U.raw }),
        { sortBy: r, multiSort: s, mustSort: c } = ts(e),
        { page: u, itemsPerPage: d } = Md(e),
        { toggleSort: f } = ns({ sortBy: r, multiSort: s, mustSort: c, page: u }),
        {
          sortByWithGroups: v,
          opened: g,
          extractRows: h,
          isGroupOpen: m,
          toggleGroup: b,
        } = Xr({ groupBy: a, sortBy: r }),
        { sortedItems: y } = Ld(e, i, v, { transform: (U) => U.raw }),
        { flatItems: p } = Zr(y, a, g, !1),
        S = B(() => p.value.length),
        {
          startIndex: k,
          stopIndex: _,
          pageCount: P,
          prevPage: A,
          nextPage: D,
          setItemsPerPage: E,
          setPage: R,
        } = Bd({ page: u, itemsPerPage: d, itemsLength: S }),
        { paginatedItems: V } = fp({ items: p, startIndex: k, stopIndex: _, itemsPerPage: d }),
        M = C(() => h(V.value)),
        {
          isSelected: F,
          select: G,
          selectAll: W,
          toggleSelect: te,
        } = Qr(e, { allItems: o, currentPage: M }),
        { isExpanded: H, toggleExpand: O } = qr(e)
      Jr({ page: u, itemsPerPage: d, sortBy: r, groupBy: a, search: l })
      const j = C(() => ({
        page: u.value,
        itemsPerPage: d.value,
        sortBy: r.value,
        pageCount: P.value,
        toggleSort: f,
        prevPage: A,
        nextPage: D,
        setPage: R,
        setItemsPerPage: E,
        isSelected: F,
        select: G,
        selectAll: W,
        toggleSelect: te,
        isExpanded: H,
        toggleExpand: O,
        isGroupOpen: m,
        toggleGroup: b,
        items: M.value,
        itemsCount: i.value.length,
        groupedItems: V.value,
      }))
      return (
        ne(() =>
          w(
            e.tag,
            {
              class: ee(['v-data-iterator', { 'v-data-iterator--loading': e.loading }, e.class]),
              style: ce(e.style),
            },
            {
              default: () => [
                n.header?.(j.value),
                w(
                  $t,
                  { transition: e.transition },
                  {
                    default: () => [
                      e.loading
                        ? w(
                            ri,
                            { key: 'loader', name: 'v-data-iterator', active: !0 },
                            { default: (U) => n.loader?.(U) }
                          )
                        : x('div', { key: 'items' }, [
                            V.value.length ? n.default?.(j.value) : n['no-data']?.(),
                          ]),
                    ],
                  }
                ),
                n.footer?.(j.value),
              ],
            }
          )
        ),
        {}
      )
    },
  })
function ZA() {
  const e = ae([])
  yh(() => (e.value = []))
  function t(n, a) {
    e.value[a] = n
  }
  return { refs: e, updateRef: t }
}
const JA = $(
    {
      activeColor: String,
      start: { type: [Number, String], default: 1 },
      modelValue: { type: Number, default: (e) => e.start },
      disabled: Boolean,
      length: { type: [Number, String], default: 1, validator: (e) => e % 1 === 0 },
      totalVisible: [Number, String],
      firstIcon: { type: Se, default: '$first' },
      prevIcon: { type: Se, default: '$prev' },
      nextIcon: { type: Se, default: '$next' },
      lastIcon: { type: Se, default: '$last' },
      ariaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.root' },
      pageAriaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.page' },
      currentPageAriaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.currentPage' },
      firstAriaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.first' },
      previousAriaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.previous' },
      nextAriaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.next' },
      lastAriaLabel: { type: String, default: '$vuetify.pagination.ariaLabel.last' },
      ellipsis: { type: String, default: '...' },
      showFirstLastPage: Boolean,
      ...Ut(),
      ...be(),
      ...St(),
      ...yt(),
      ...Je(),
      ...Un(),
      ...Ie({ tag: 'nav' }),
      ...Be(),
      ...yn({ variant: 'text' }),
    },
    'VPagination'
  ),
  Gu = J()({
    name: 'VPagination',
    props: JA(),
    emits: {
      'update:modelValue': (e) => !0,
      first: (e) => !0,
      prev: (e) => !0,
      next: (e) => !0,
      last: (e) => !0,
    },
    setup(e, t) {
      let { slots: n, emit: a } = t
      const l = we(e, 'modelValue'),
        { t: o, n: i } = ze(),
        { isRtl: r } = gt(),
        { themeClasses: s } = $e(e),
        { width: c } = gn(),
        u = oe(-1)
      lt(void 0, { scoped: !0 })
      const { resizeRef: d } = hn((A) => {
          if (!A.length) return
          const { target: D, contentRect: E } = A[0],
            R = D.querySelector('.v-pagination__list > *')
          if (!R) return
          const V = E.width,
            M = R.offsetWidth + parseFloat(getComputedStyle(R).marginRight) * 2
          u.value = h(V, M)
        }),
        f = C(() => parseInt(e.length, 10)),
        v = C(() => parseInt(e.start, 10)),
        g = C(() =>
          e.totalVisible != null
            ? parseInt(e.totalVisible, 10)
            : u.value >= 0
              ? u.value
              : h(c.value, 58)
        )
      function h(A, D) {
        const E = e.showFirstLastPage ? 5 : 3
        return Math.max(0, Math.floor(Number(((A - D * E) / D).toFixed(2))))
      }
      const m = C(() => {
        if (f.value <= 0 || isNaN(f.value) || f.value > Number.MAX_SAFE_INTEGER) return []
        if (g.value <= 0) return []
        if (g.value === 1) return [l.value]
        if (f.value <= g.value) return ln(f.value, v.value)
        const A = g.value % 2 === 0,
          D = A ? g.value / 2 : Math.floor(g.value / 2),
          E = A ? D : D + 1,
          R = f.value - D
        if (E - l.value >= 0) return [...ln(Math.max(1, g.value - 1), v.value), e.ellipsis, f.value]
        if (l.value - R >= (A ? 1 : 0)) {
          const V = g.value - 1,
            M = f.value - V + v.value
          return [v.value, e.ellipsis, ...ln(V, M)]
        } else {
          const V = Math.max(1, g.value - 2),
            M = V === 1 ? l.value : l.value - Math.ceil(V / 2) + v.value
          return [v.value, e.ellipsis, ...ln(V, M), e.ellipsis, f.value]
        }
      })
      function b(A, D, E) {
        ;(A.preventDefault(), (l.value = D), E && a(E, D))
      }
      const { refs: y, updateRef: p } = ZA()
      lt({
        VPaginationBtn: {
          color: B(() => e.color),
          border: B(() => e.border),
          density: B(() => e.density),
          size: B(() => e.size),
          variant: B(() => e.variant),
          rounded: B(() => e.rounded),
          elevation: B(() => e.elevation),
        },
      })
      const S = C(() =>
          m.value.map((A, D) => {
            const E = (R) => p(R, D)
            if (typeof A == 'string')
              return {
                isActive: !1,
                key: `ellipsis-${D}`,
                page: A,
                props: { ref: E, ellipsis: !0, icon: !0, disabled: !0 },
              }
            {
              const R = A === l.value
              return {
                isActive: R,
                key: A,
                page: i(A),
                props: {
                  ref: E,
                  ellipsis: !1,
                  icon: !0,
                  disabled: !!e.disabled || Number(e.length) < 2,
                  color: R ? e.activeColor : e.color,
                  'aria-current': R,
                  'aria-label': o(R ? e.currentPageAriaLabel : e.pageAriaLabel, A),
                  onClick: (V) => b(V, A),
                },
              }
            }
          })
        ),
        k = C(() => {
          const A = !!e.disabled || l.value <= v.value,
            D = !!e.disabled || l.value >= v.value + f.value - 1
          return {
            first: e.showFirstLastPage
              ? {
                  icon: r.value ? e.lastIcon : e.firstIcon,
                  onClick: (E) => b(E, v.value, 'first'),
                  disabled: A,
                  'aria-label': o(e.firstAriaLabel),
                  'aria-disabled': A,
                }
              : void 0,
            prev: {
              icon: r.value ? e.nextIcon : e.prevIcon,
              onClick: (E) => b(E, l.value - 1, 'prev'),
              disabled: A,
              'aria-label': o(e.previousAriaLabel),
              'aria-disabled': A,
            },
            next: {
              icon: r.value ? e.prevIcon : e.nextIcon,
              onClick: (E) => b(E, l.value + 1, 'next'),
              disabled: D,
              'aria-label': o(e.nextAriaLabel),
              'aria-disabled': D,
            },
            last: e.showFirstLastPage
              ? {
                  icon: r.value ? e.firstIcon : e.lastIcon,
                  onClick: (E) => b(E, v.value + f.value - 1, 'last'),
                  disabled: D,
                  'aria-label': o(e.lastAriaLabel),
                  'aria-disabled': D,
                }
              : void 0,
          }
        })
      function _() {
        const A = l.value - v.value
        y.value[A]?.$el.focus()
      }
      function P(A) {
        A.key === Su.left && !e.disabled && l.value > Number(e.start)
          ? ((l.value = l.value - 1), Re(_))
          : A.key === Su.right &&
            !e.disabled &&
            l.value < v.value + f.value - 1 &&
            ((l.value = l.value + 1), Re(_))
      }
      return (
        ne(() =>
          w(
            e.tag,
            {
              ref: d,
              class: ee(['v-pagination', s.value, e.class]),
              style: ce(e.style),
              role: 'navigation',
              'aria-label': o(e.ariaLabel),
              onKeydown: P,
              'data-test': 'v-pagination-root',
            },
            {
              default: () => [
                x('ul', { class: 'v-pagination__list' }, [
                  e.showFirstLastPage &&
                    x(
                      'li',
                      {
                        key: 'first',
                        class: 'v-pagination__first',
                        'data-test': 'v-pagination-first',
                      },
                      [
                        n.first
                          ? n.first(k.value.first)
                          : w(Me, Z({ _as: 'VPaginationBtn' }, k.value.first), null),
                      ]
                    ),
                  x(
                    'li',
                    { key: 'prev', class: 'v-pagination__prev', 'data-test': 'v-pagination-prev' },
                    [
                      n.prev
                        ? n.prev(k.value.prev)
                        : w(Me, Z({ _as: 'VPaginationBtn' }, k.value.prev), null),
                    ]
                  ),
                  S.value.map((A, D) =>
                    x(
                      'li',
                      {
                        key: A.key,
                        class: ee([
                          'v-pagination__item',
                          { 'v-pagination__item--is-active': A.isActive },
                        ]),
                        'data-test': 'v-pagination-item',
                      },
                      [
                        n.item
                          ? n.item(A)
                          : w(Me, Z({ _as: 'VPaginationBtn' }, A.props), {
                              default: () => [A.page],
                            }),
                      ]
                    )
                  ),
                  x(
                    'li',
                    { key: 'next', class: 'v-pagination__next', 'data-test': 'v-pagination-next' },
                    [
                      n.next
                        ? n.next(k.value.next)
                        : w(Me, Z({ _as: 'VPaginationBtn' }, k.value.next), null),
                    ]
                  ),
                  e.showFirstLastPage &&
                    x(
                      'li',
                      {
                        key: 'last',
                        class: 'v-pagination__last',
                        'data-test': 'v-pagination-last',
                      },
                      [
                        n.last
                          ? n.last(k.value.last)
                          : w(Me, Z({ _as: 'VPaginationBtn' }, k.value.last), null),
                      ]
                    ),
                ]),
              ],
            }
          )
        ),
        {}
      )
    },
  }),
  Od = $(
    {
      prevIcon: { type: Se, default: '$prev' },
      nextIcon: { type: Se, default: '$next' },
      firstIcon: { type: Se, default: '$first' },
      lastIcon: { type: Se, default: '$last' },
      itemsPerPageText: { type: String, default: '$vuetify.dataFooter.itemsPerPageText' },
      pageText: { type: String, default: '$vuetify.dataFooter.pageText' },
      firstPageLabel: { type: String, default: '$vuetify.dataFooter.firstPage' },
      prevPageLabel: { type: String, default: '$vuetify.dataFooter.prevPage' },
      nextPageLabel: { type: String, default: '$vuetify.dataFooter.nextPage' },
      lastPageLabel: { type: String, default: '$vuetify.dataFooter.lastPage' },
      itemsPerPageOptions: {
        type: Array,
        default: () => [
          { value: 10, title: '10' },
          { value: 25, title: '25' },
          { value: 50, title: '50' },
          { value: 100, title: '100' },
          { value: -1, title: '$vuetify.dataFooter.itemsPerPageAll' },
        ],
      },
      showCurrentPage: Boolean,
    },
    'VDataTableFooter'
  ),
  Go = J()({
    name: 'VDataTableFooter',
    props: Od(),
    setup(e, t) {
      let { slots: n } = t
      const { t: a } = ze(),
        {
          page: l,
          pageCount: o,
          startIndex: i,
          stopIndex: r,
          itemsLength: s,
          itemsPerPage: c,
          setItemsPerPage: u,
        } = jA(),
        d = C(() =>
          e.itemsPerPageOptions.map((f) =>
            typeof f == 'number'
              ? { value: f, title: f === -1 ? a('$vuetify.dataFooter.itemsPerPageAll') : String(f) }
              : { ...f, title: isNaN(Number(f.title)) ? a(f.title) : f.title }
          )
        )
      return (
        ne(() => {
          const f = Gu.filterProps(e)
          return x('div', { class: 'v-data-table-footer' }, [
            n.prepend?.(),
            x('div', { class: 'v-data-table-footer__items-per-page' }, [
              x('span', { 'aria-label': a(e.itemsPerPageText) }, [a(e.itemsPerPageText)]),
              w(
                Pd,
                {
                  items: d.value,
                  modelValue: c.value,
                  'onUpdate:modelValue': (v) => u(Number(v)),
                  density: 'compact',
                  variant: 'outlined',
                  hideDetails: !0,
                },
                null
              ),
            ]),
            x('div', { class: 'v-data-table-footer__info' }, [
              x('div', null, [a(e.pageText, s.value ? i.value + 1 : 0, r.value, s.value)]),
            ]),
            x('div', { class: 'v-data-table-footer__pagination' }, [
              w(
                Gu,
                Z(
                  {
                    modelValue: l.value,
                    'onUpdate:modelValue': (v) => (l.value = v),
                    density: 'comfortable',
                    firstAriaLabel: e.firstPageLabel,
                    lastAriaLabel: e.lastPageLabel,
                    length: o.value,
                    nextAriaLabel: e.nextPageLabel,
                    previousAriaLabel: e.prevPageLabel,
                    rounded: !0,
                    showFirstLastPage: !0,
                    totalVisible: e.showCurrentPage ? 1 : 0,
                    variant: 'plain',
                  },
                  f
                ),
                null
              ),
            ]),
          ])
        }),
        {}
      )
    },
  }),
  Yo = O1(
    {
      align: { type: String, default: 'start' },
      fixed: { type: [Boolean, String], default: !1 },
      fixedOffset: [Number, String],
      fixedEndOffset: [Number, String],
      height: [Number, String],
      lastFixed: Boolean,
      firstFixedEnd: Boolean,
      noPadding: Boolean,
      indent: [Number, String],
      empty: Boolean,
      tag: String,
      width: [Number, String],
      maxWidth: [Number, String],
      nowrap: Boolean,
    },
    (e, t) => {
      let { slots: n } = t
      const a = e.tag ?? 'td',
        l = typeof e.fixed == 'string' ? e.fixed : e.fixed ? 'start' : 'none'
      return w(
        a,
        {
          class: ee([
            'v-data-table__td',
            {
              'v-data-table-column--fixed': l === 'start',
              'v-data-table-column--fixed-end': l === 'end',
              'v-data-table-column--last-fixed': e.lastFixed,
              'v-data-table-column--first-fixed-end': e.firstFixedEnd,
              'v-data-table-column--no-padding': e.noPadding,
              'v-data-table-column--nowrap': e.nowrap,
              'v-data-table-column--empty': e.empty,
            },
            `v-data-table-column--align-${e.align}`,
          ]),
          style: {
            height: fe(e.height),
            width: fe(e.width),
            maxWidth: fe(e.maxWidth),
            left: l === 'start' ? fe(e.fixedOffset || null) : void 0,
            right: l === 'end' ? fe(e.fixedEndOffset || null) : void 0,
            paddingInlineStart: e.indent ? fe(e.indent) : void 0,
          },
        },
        { default: () => [n.default?.()] }
      )
    }
  ),
  QA = $({ headers: Array }, 'DataTable-header'),
  Sp = Symbol.for('vuetify:data-table-headers'),
  wp = { title: '', sortable: !1 },
  eE = { ...wp, width: 48 }
function tE() {
  const t = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).map((n) => ({
    element: n,
    priority: 0,
  }))
  return {
    enqueue: (n, a) => {
      let l = !1
      for (let o = 0; o < t.length; o++)
        if (t[o].priority > a) {
          ;(t.splice(o, 0, { element: n, priority: a }), (l = !0))
          break
        }
      l || t.push({ element: n, priority: a })
    },
    size: () => t.length,
    count: () => {
      let n = 0
      if (!t.length) return 0
      const a = Math.floor(t[0].priority)
      for (let l = 0; l < t.length; l++) Math.floor(t[l].priority) === a && (n += 1)
      return n
    },
    dequeue: () => t.shift(),
  }
}
function Yu(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []
  if (!e.children) t.push(e)
  else for (const n of e.children) Yu(n, t)
  return t
}
function kp(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Set()
  for (const n of e) (n.key && t.add(n.key), n.children && kp(n.children, t))
  return t
}
function nE(e) {
  if (e.key) {
    if (e.key === 'data-table-group') return wp
    if (['data-table-expand', 'data-table-select'].includes(e.key)) return eE
  }
}
function $d(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0
  return e.children ? Math.max(t, ...e.children.map((n) => $d(n, t + 1))) : t
}
function aE(e) {
  let t = !1
  function n(o, i) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'none'
    if (o)
      if ((r !== 'none' && (o.fixed = r), o.fixed === !0 && (o.fixed = 'start'), o.fixed === i))
        if (o.children)
          if (i === 'start') for (let s = o.children.length - 1; s >= 0; s--) n(o.children[s], i, i)
          else for (let s = 0; s < o.children.length; s++) n(o.children[s], i, i)
        else
          (!t && i === 'start'
            ? (o.lastFixed = !0)
            : !t && i === 'end'
              ? (o.firstFixedEnd = !0)
              : isNaN(Number(o.width))
                ? (`${o.key}`, void 0)
                : (o.minWidth = Math.max(Number(o.width) || 0, Number(o.minWidth) || 0)),
            (t = !0))
      else if (o.children)
        if (i === 'start') for (let s = o.children.length - 1; s >= 0; s--) n(o.children[s], i)
        else for (let s = 0; s < o.children.length; s++) n(o.children[s], i)
      else t = !1
  }
  for (let o = e.length - 1; o >= 0; o--) n(e[o], 'start')
  for (let o = 0; o < e.length; o++) n(e[o], 'end')
  let a = 0
  for (let o = 0; o < e.length; o++) a = Cp(e[o], a)
  let l = 0
  for (let o = e.length - 1; o >= 0; o--) l = xp(e[o], l)
}
function Cp(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0
  if (!e) return t
  if (e.children) {
    e.fixedOffset = t
    for (const n of e.children) t = Cp(n, t)
  } else
    e.fixed && e.fixed !== 'end' && ((e.fixedOffset = t), (t += parseFloat(e.width || '0') || 0))
  return t
}
function xp(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0
  if (!e) return t
  if (e.children) {
    e.fixedEndOffset = t
    for (const n of e.children) t = xp(n, t)
  } else e.fixed === 'end' && ((e.fixedEndOffset = t), (t += parseFloat(e.width || '0') || 0))
  return t
}
function lE(e, t) {
  const n = []
  let a = 0
  const l = tE(e)
  for (; l.size() > 0; ) {
    let i = l.count()
    const r = []
    let s = 1
    for (; i > 0; ) {
      const { element: c, priority: u } = l.dequeue(),
        d = t - a - $d(c)
      if ((r.push({ ...c, rowspan: d ?? 1, colspan: c.children ? Yu(c).length : 1 }), c.children))
        for (const f of c.children) {
          const v = (u % 1) + s / Math.pow(10, a + 2)
          l.enqueue(f, a + d + v)
        }
      ;((s += 1), (i -= 1))
    }
    ;((a += 1), n.push(r))
  }
  return { columns: e.map((i) => Yu(i)).flat(), headers: n }
}
function _p(e) {
  const t = []
  for (const n of e) {
    const a = { ...nE(n), ...n },
      l = a.key ?? (typeof a.value == 'string' ? a.value : null),
      o = a.value ?? l ?? null,
      i = {
        ...a,
        key: l,
        value: o,
        sortable: a.sortable ?? (a.key != null || !!a.sort),
        children: a.children ? _p(a.children) : void 0,
      }
    t.push(i)
  }
  return t
}
function Fd(e, t) {
  const n = ae([]),
    a = ae([]),
    l = ae({}),
    o = ae({}),
    i = ae({})
  qe(() => {
    const c = (
        e.headers || Object.keys(e.items[0] ?? {}).map((h) => ({ key: h, title: Hn(h) }))
      ).slice(),
      u = kp(c)
    ;(t?.groupBy?.value.length &&
      !u.has('data-table-group') &&
      c.unshift({ key: 'data-table-group', title: 'Group' }),
      t?.showSelect?.value &&
        !u.has('data-table-select') &&
        c.unshift({ key: 'data-table-select' }),
      t?.showExpand?.value && !u.has('data-table-expand') && c.push({ key: 'data-table-expand' }))
    const d = _p(c)
    aE(d)
    const f = Math.max(...d.map((h) => $d(h))) + 1,
      v = lE(d, f)
    ;((n.value = v.headers), (a.value = v.columns))
    const g = v.headers.flat(1)
    for (const h of g)
      h.key &&
        (h.sortable &&
          (h.sort && (l.value[h.key] = h.sort), h.sortRaw && (o.value[h.key] = h.sortRaw)),
        h.filter && (i.value[h.key] = h.filter))
  })
  const r = { headers: n, columns: a, sortFunctions: l, sortRawFunctions: o, filterFunctions: i }
  return (Fe(Sp, r), r)
}
function as() {
  const e = Ve(Sp)
  if (!e) throw new Error('Missing headers!')
  return e
}
const Pp = $(
    {
      color: String,
      disableSort: Boolean,
      fixedHeader: Boolean,
      multiSort: Boolean,
      sortAscIcon: { type: Se, default: '$sortAsc' },
      sortDescIcon: { type: Se, default: '$sortDesc' },
      headerProps: { type: Object },
      sticky: Boolean,
      ...ol(),
      ...Hr(),
    },
    'VDataTableHeaders'
  ),
  tl = J()({
    name: 'VDataTableHeaders',
    props: Pp(),
    setup(e, t) {
      let { slots: n } = t
      const { t: a } = ze(),
        { toggleSort: l, sortBy: o, isSorted: i } = pp(),
        { someSelected: r, allSelected: s, selectAll: c, showSelectAll: u } = es(),
        { columns: d, headers: f } = as(),
        { loaderClasses: v } = ii(e)
      function g(D, E) {
        if (!(e.sticky || e.fixedHeader) && !D.fixed) return
        const R = typeof D.fixed == 'string' ? D.fixed : D.fixed ? 'start' : 'none'
        return {
          position: 'sticky',
          left: R === 'start' ? fe(D.fixedOffset) : void 0,
          right: R === 'end' ? fe(D.fixedEndOffset) : void 0,
          top: e.sticky || e.fixedHeader ? `calc(var(--v-table-header-height) * ${E})` : void 0,
        }
      }
      function h(D, E) {
        D.key === 'Enter' && !e.disableSort && l(E)
      }
      function m(D) {
        const E = o.value.find((R) => R.key === D.key)
        return E ? (E.order === 'asc' ? e.sortAscIcon : e.sortDescIcon) : e.sortAscIcon
      }
      const { backgroundColorClasses: b, backgroundColorStyles: y } = He(() => e.color),
        { displayClasses: p, mobile: S } = gn(e),
        k = C(() => ({
          headers: f.value,
          columns: d.value,
          toggleSort: l,
          isSorted: i,
          sortBy: o.value,
          someSelected: r.value,
          allSelected: s.value,
          selectAll: c,
          getSortIcon: m,
        })),
        _ = C(() => [
          'v-data-table__th',
          { 'v-data-table__th--sticky': e.sticky || e.fixedHeader },
          p.value,
          v.value,
        ]),
        P = (D) => {
          let { column: E, x: R, y: V } = D
          const M = E.key === 'data-table-select' || E.key === 'data-table-expand',
            F = E.key === 'data-table-group' && E.width === 0 && !E.title,
            G = Z(e.headerProps ?? {}, E.headerProps ?? {})
          return w(
            Yo,
            Z(
              {
                tag: 'th',
                align: E.align,
                class: [
                  {
                    'v-data-table__th--sortable': E.sortable && !e.disableSort,
                    'v-data-table__th--sorted': i(E),
                    'v-data-table__th--fixed': E.fixed,
                  },
                  ..._.value,
                ],
                style: {
                  width: fe(E.width),
                  minWidth: fe(E.minWidth),
                  maxWidth: fe(E.maxWidth),
                  ...g(E, V),
                },
                colspan: E.colspan,
                rowspan: E.rowspan,
                fixed: E.fixed,
                nowrap: E.nowrap,
                lastFixed: E.lastFixed,
                firstFixedEnd: E.firstFixedEnd,
                noPadding: M,
                empty: F,
                tabindex: E.sortable ? 0 : void 0,
                onClick: E.sortable ? () => l(E) : void 0,
                onKeydown: E.sortable ? (W) => h(W, E) : void 0,
              },
              G
            ),
            {
              default: () => {
                const W = `header.${E.key}`,
                  te = {
                    column: E,
                    selectAll: c,
                    isSorted: i,
                    toggleSort: l,
                    sortBy: o.value,
                    someSelected: r.value,
                    allSelected: s.value,
                    getSortIcon: m,
                  }
                return n[W]
                  ? n[W](te)
                  : F
                    ? ''
                    : E.key === 'data-table-select'
                      ? (n['header.data-table-select']?.(te) ??
                        (u.value &&
                          w(
                            Fn,
                            {
                              modelValue: s.value,
                              indeterminate: r.value && !s.value,
                              'onUpdate:modelValue': c,
                            },
                            null
                          )))
                      : x('div', { class: 'v-data-table-header__content' }, [
                          x('span', null, [E.title]),
                          E.sortable &&
                            !e.disableSort &&
                            w(
                              Le,
                              { key: 'icon', class: 'v-data-table-header__sort-icon', icon: m(E) },
                              null
                            ),
                          e.multiSort &&
                            i(E) &&
                            x(
                              'div',
                              {
                                key: 'badge',
                                class: ee(['v-data-table-header__sort-badge', ...b.value]),
                                style: ce(y.value),
                              },
                              [o.value.findIndex((H) => H.key === E.key) + 1]
                            ),
                        ])
              },
            }
          )
        },
        A = () => {
          const D = C(() => d.value.filter((R) => R?.sortable && !e.disableSort)),
            E = C(() => {
              if (d.value.find((V) => V.key === 'data-table-select') != null)
                return s.value ? '$checkboxOn' : r.value ? '$checkboxIndeterminate' : '$checkboxOff'
            })
          return w(
            Yo,
            Z({ tag: 'th', class: [..._.value], colspan: f.value.length + 1 }, e.headerProps),
            {
              default: () => [
                x('div', { class: 'v-data-table-header__content' }, [
                  w(
                    Pd,
                    {
                      chips: !0,
                      class: 'v-data-table__td-sort-select',
                      clearable: !0,
                      density: 'default',
                      items: D.value,
                      label: a('$vuetify.dataTable.sortBy'),
                      multiple: e.multiSort,
                      variant: 'underlined',
                      'onClick:clear': () => (o.value = []),
                      appendIcon: E.value,
                      'onClick:append': () => c(!s.value),
                    },
                    {
                      chip: (R) =>
                        w(
                          no,
                          {
                            onClick: R.item.raw?.sortable ? () => l(R.item.raw) : void 0,
                            onMousedown: (V) => {
                              ;(V.preventDefault(), V.stopPropagation())
                            },
                          },
                          {
                            default: () => [
                              R.item.title,
                              w(
                                Le,
                                {
                                  class: ee([
                                    'v-data-table__td-sort-icon',
                                    i(R.item.raw) && 'v-data-table__td-sort-icon-active',
                                  ]),
                                  icon: m(R.item.raw),
                                  size: 'small',
                                },
                                null
                              ),
                            ],
                          }
                        ),
                    }
                  ),
                ]),
              ],
            }
          )
        }
      ne(() =>
        S.value
          ? x('tr', null, [w(A, null, null)])
          : x(he, null, [
              n.headers
                ? n.headers(k.value)
                : f.value.map((D, E) =>
                    x('tr', null, [D.map((R, V) => w(P, { column: R, x: V, y: E }, null))])
                  ),
              e.loading &&
                x('tr', { class: 'v-data-table-progress' }, [
                  x('th', { colspan: d.value.length }, [
                    w(
                      ri,
                      {
                        name: 'v-data-table-progress',
                        absolute: !0,
                        active: !0,
                        color: typeof e.loading == 'boolean' ? void 0 : e.loading,
                        indeterminate: !0,
                      },
                      { default: n.loader }
                    ),
                  ]),
                ]),
            ])
      )
    },
  }),
  Vp = $(
    {
      item: { type: Object, required: !0 },
      groupCollapseIcon: { type: Se, default: '$tableGroupCollapse' },
      groupExpandIcon: { type: Se, default: '$tableGroupExpand' },
    },
    'VDataTableGroupHeaderRow'
  ),
  oE = J()({
    name: 'VDataTableGroupHeaderRow',
    props: Vp(),
    setup(e, t) {
      let { slots: n } = t
      const { isGroupOpen: a, toggleGroup: l, extractRows: o } = sp(),
        { isSelected: i, isSomeSelected: r, select: s } = es(),
        { columns: c } = as(),
        u = C(() => o([e.item])),
        d = B(() => c.value.length - (c.value.some((f) => f.key === 'data-table-select') ? 1 : 0))
      return () =>
        x(
          'tr',
          {
            class: 'v-data-table-group-header-row',
            style: { '--v-data-table-group-header-row-depth': e.item.depth },
          },
          [
            c.value.map((f) => {
              if (f.key === 'data-table-group') {
                const v = a(e.item) ? e.groupCollapseIcon : e.groupExpandIcon,
                  g = () => l(e.item)
                return (
                  n['data-table-group']?.({
                    item: e.item,
                    count: u.value.length,
                    props: { icon: v, onClick: g },
                  }) ??
                  w(
                    Yo,
                    { class: 'v-data-table-group-header-row__column', colspan: d.value },
                    {
                      default: () => [
                        w(Me, { size: 'small', variant: 'text', icon: v, onClick: g }, null),
                        x('span', null, [e.item.value]),
                        x('span', null, [qt('('), u.value.length, qt(')')]),
                      ],
                    }
                  )
                )
              } else if (f.key === 'data-table-select') {
                const v = i(u.value),
                  g = r(u.value) && !v,
                  h = (m) => s(u.value, m)
                return (
                  n['data-table-select']?.({
                    props: { modelValue: v, indeterminate: g, 'onUpdate:modelValue': h },
                  }) ??
                  w(
                    Yo,
                    { class: 'v-data-table__td--select-row', noPadding: !0 },
                    {
                      default: () => [
                        w(Fn, { modelValue: v, indeterminate: g, 'onUpdate:modelValue': h }, null),
                      ],
                    }
                  )
                )
              }
              return ''
            }),
          ]
        )
    },
  }),
  Ip = $(
    {
      index: Number,
      item: Object,
      cellProps: [Object, Function],
      collapseIcon: { type: Se, default: '$collapse' },
      expandIcon: { type: Se, default: '$expand' },
      onClick: Pt(),
      onContextmenu: Pt(),
      onDblclick: Pt(),
      ...ol(),
    },
    'VDataTableRow'
  ),
  Nd = J()({
    name: 'VDataTableRow',
    props: Ip(),
    setup(e, t) {
      let { slots: n } = t
      const { displayClasses: a, mobile: l } = gn(e, 'v-data-table__tr'),
        { isSelected: o, toggleSelect: i, someSelected: r, allSelected: s, selectAll: c } = es(),
        { isExpanded: u, toggleExpand: d } = ip(),
        { toggleSort: f, sortBy: v, isSorted: g } = pp(),
        { columns: h } = as()
      ne(() =>
        x(
          'tr',
          {
            class: ee([
              'v-data-table__tr',
              { 'v-data-table__tr--clickable': !!(e.onClick || e.onContextmenu || e.onDblclick) },
              a.value,
            ]),
            onClick: e.onClick,
            onContextmenu: e.onContextmenu,
            onDblclick: e.onDblclick,
          },
          [
            e.item &&
              h.value.map((m, b) => {
                const y = e.item,
                  p = `item.${m.key}`,
                  S = `header.${m.key}`,
                  k = {
                    index: e.index,
                    item: y.raw,
                    internalItem: y,
                    value: Za(y.columns, m.key),
                    column: m,
                    isSelected: o,
                    toggleSelect: i,
                    isExpanded: u,
                    toggleExpand: d,
                  },
                  _ = {
                    column: m,
                    selectAll: c,
                    isSorted: g,
                    toggleSort: f,
                    sortBy: v.value,
                    someSelected: r.value,
                    allSelected: s.value,
                    getSortIcon: () => '',
                  },
                  P =
                    typeof e.cellProps == 'function'
                      ? e.cellProps({
                          index: k.index,
                          item: k.item,
                          internalItem: k.internalItem,
                          value: k.value,
                          column: m,
                        })
                      : e.cellProps,
                  A =
                    typeof m.cellProps == 'function'
                      ? m.cellProps({
                          index: k.index,
                          item: k.item,
                          internalItem: k.internalItem,
                          value: k.value,
                        })
                      : m.cellProps,
                  D = m.key === 'data-table-select' || m.key === 'data-table-expand',
                  E = m.key === 'data-table-group' && m.width === 0 && !m.title
                return w(
                  Yo,
                  Z(
                    {
                      align: m.align,
                      indent: m.intent,
                      class: {
                        'v-data-table__td--expanded-row': m.key === 'data-table-expand',
                        'v-data-table__td--select-row': m.key === 'data-table-select',
                      },
                      fixed: m.fixed,
                      fixedOffset: m.fixedOffset,
                      fixedEndOffset: m.fixedEndOffset,
                      lastFixed: m.lastFixed,
                      firstFixedEnd: m.firstFixedEnd,
                      maxWidth: l.value ? void 0 : m.maxWidth,
                      noPadding: D,
                      empty: E,
                      nowrap: m.nowrap,
                      width: l.value ? void 0 : m.width,
                    },
                    P,
                    A
                  ),
                  {
                    default: () => {
                      if (m.key === 'data-table-select')
                        return (
                          n['item.data-table-select']?.({
                            ...k,
                            props: {
                              disabled: !y.selectable,
                              modelValue: o([y]),
                              onClick: ki(() => i(y), ['stop']),
                            },
                          }) ??
                          w(
                            Fn,
                            {
                              disabled: !y.selectable,
                              modelValue: o([y]),
                              onClick: ki((V) => i(y, e.index, V), ['stop']),
                            },
                            null
                          )
                        )
                      if (m.key === 'data-table-expand')
                        return (
                          n['item.data-table-expand']?.({
                            ...k,
                            props: {
                              icon: u(y) ? e.collapseIcon : e.expandIcon,
                              size: 'small',
                              variant: 'text',
                              onClick: ki(() => d(y), ['stop']),
                            },
                          }) ??
                          w(
                            Me,
                            {
                              icon: u(y) ? e.collapseIcon : e.expandIcon,
                              size: 'small',
                              variant: 'text',
                              onClick: ki(() => d(y), ['stop']),
                            },
                            null
                          )
                        )
                      if (n[p] && !l.value) return n[p](k)
                      const R = Bn(k.value)
                      return l.value
                        ? x(he, null, [
                            x('div', { class: 'v-data-table__td-title' }, [n[S]?.(_) ?? m.title]),
                            x('div', { class: 'v-data-table__td-value' }, [n[p]?.(k) ?? R]),
                          ])
                        : R
                    },
                  }
                )
              }),
          ]
        )
      )
    },
  }),
  Tp = $(
    {
      loading: [Boolean, String],
      loadingText: { type: String, default: '$vuetify.dataIterator.loadingText' },
      hideNoData: Boolean,
      items: { type: Array, default: () => [] },
      noDataText: { type: String, default: '$vuetify.noDataText' },
      rowProps: [Object, Function],
      cellProps: [Object, Function],
      ...Zt(Ip(), ['collapseIcon', 'expandIcon']),
      ...Zt(Vp(), ['groupCollapseIcon', 'groupExpandIcon']),
      ...ol(),
    },
    'VDataTableRows'
  ),
  nl = J()({
    name: 'VDataTableRows',
    inheritAttrs: !1,
    props: Tp(),
    setup(e, t) {
      let { attrs: n, slots: a } = t
      const { columns: l } = as(),
        { expandOnClick: o, toggleExpand: i, isExpanded: r } = ip(),
        { isSelected: s, toggleSelect: c } = es(),
        { toggleGroup: u, isGroupOpen: d } = sp(),
        { t: f } = ze(),
        { mobile: v } = gn(e)
      return (
        ne(() => {
          const g = Zt(e, ['groupCollapseIcon', 'groupExpandIcon'])
          return e.loading && (!e.items.length || a.loading)
            ? x('tr', { class: 'v-data-table-rows-loading', key: 'loading' }, [
                x('td', { colspan: l.value.length }, [a.loading?.() ?? f(e.loadingText)]),
              ])
            : !e.loading && !e.items.length && !e.hideNoData
              ? x('tr', { class: 'v-data-table-rows-no-data', key: 'no-data' }, [
                  x('td', { colspan: l.value.length }, [a['no-data']?.() ?? f(e.noDataText)]),
                ])
              : x(he, null, [
                  e.items.map((h, m) => {
                    if (h.type === 'group') {
                      const p = {
                        index: m,
                        item: h,
                        columns: l.value,
                        isExpanded: r,
                        toggleExpand: i,
                        isSelected: s,
                        toggleSelect: c,
                        toggleGroup: u,
                        isGroupOpen: d,
                      }
                      return a['group-header']
                        ? a['group-header'](p)
                        : w(
                            oE,
                            Z(
                              { key: `group-header_${h.id}`, item: h },
                              zv(n, ':groupHeader', () => p),
                              g
                            ),
                            a
                          )
                    }
                    if (h.type === 'group-summary') {
                      const p = { index: m, item: h, columns: l.value, toggleGroup: u }
                      return a['group-summary']?.(p) ?? ''
                    }
                    const b = {
                        index: m,
                        item: h.raw,
                        internalItem: h,
                        columns: l.value,
                        isExpanded: r,
                        toggleExpand: i,
                        isSelected: s,
                        toggleSelect: c,
                      },
                      y = {
                        ...b,
                        props: Z(
                          {
                            key: `item_${h.key ?? h.index}`,
                            onClick: o.value
                              ? () => {
                                  i(h)
                                }
                              : void 0,
                            index: m,
                            item: h,
                            cellProps: e.cellProps,
                            collapseIcon: e.collapseIcon,
                            expandIcon: e.expandIcon,
                            mobile: v.value,
                          },
                          zv(n, ':row', () => b),
                          typeof e.rowProps == 'function'
                            ? e.rowProps({
                                item: b.item,
                                index: b.index,
                                internalItem: b.internalItem,
                              })
                            : e.rowProps
                        ),
                      }
                    return x(he, { key: y.props.key }, [
                      a.item ? a.item(y) : w(Nd, y.props, a),
                      r(h) && a['expanded-row']?.(b),
                    ])
                  }),
                ])
        }),
        {}
      )
    },
  }),
  Ap = $(
    {
      fixedHeader: Boolean,
      fixedFooter: Boolean,
      height: [Number, String],
      hover: Boolean,
      striped: { type: String, default: null, validator: (e) => ['even', 'odd'].includes(e) },
      ...be(),
      ...St(),
      ...Ie(),
      ...Be(),
    },
    'VTable'
  ),
  al = J()({
    name: 'VTable',
    props: Ap(),
    setup(e, t) {
      let { slots: n, emit: a } = t
      const { themeClasses: l } = $e(e),
        { densityClasses: o } = Ht(e)
      return (
        ne(() => {
          const i = { VCheckboxBtn: { density: e.density } }
          return w(
            e.tag,
            {
              class: ee([
                'v-table',
                {
                  'v-table--fixed-height': !!e.height,
                  'v-table--fixed-header': e.fixedHeader,
                  'v-table--fixed-footer': e.fixedFooter,
                  'v-table--has-top': !!n.top,
                  'v-table--has-bottom': !!n.bottom,
                  'v-table--hover': e.hover,
                  'v-table--striped-even': e.striped === 'even',
                  'v-table--striped-odd': e.striped === 'odd',
                },
                l.value,
                o.value,
                e.class,
              ]),
              style: ce(e.style),
            },
            {
              default: () => [
                n.top?.(),
                w(
                  Ae,
                  { defaults: i },
                  {
                    default: () => [
                      n.default
                        ? x('div', { class: 'v-table__wrapper', style: { height: fe(e.height) } }, [
                            x('table', null, [n.default()]),
                          ])
                        : n.wrapper?.(),
                    ],
                  }
                ),
                n.bottom?.(),
              ],
            }
          )
        }),
        {}
      )
    },
  }),
  iE = $(
    {
      items: { type: Array, default: () => [] },
      itemValue: { type: [String, Array, Function], default: 'id' },
      itemSelectable: { type: [String, Array, Function], default: null },
      rowProps: [Object, Function],
      cellProps: [Object, Function],
      returnObject: Boolean,
    },
    'DataTable-items'
  )
function rE(e, t, n, a) {
  const l = e.returnObject ? t : st(t, e.itemValue),
    o = st(t, e.itemSelectable, !0),
    i = a.reduce((r, s) => (s.key != null && (r[s.key] = st(t, s.value)), r), {})
  return {
    type: 'item',
    key: e.returnObject ? st(t, e.itemValue) : l,
    index: n,
    value: l,
    selectable: o,
    columns: i,
    raw: t,
  }
}
function sE(e, t, n) {
  return t.map((a, l) => rE(e, a, l, n))
}
function Hd(e, t) {
  return { items: C(() => sE(e, e.items, t.value)) }
}
const jd = $(
    {
      ...Tp(),
      hideDefaultBody: Boolean,
      hideDefaultFooter: Boolean,
      hideDefaultHeader: Boolean,
      width: [String, Number],
      search: String,
      ...lp(),
      ...Ed(),
      ...QA(),
      ...iE(),
      ...hp(),
      ...yp(),
      ...Pp(),
      ...Ap(),
    },
    'DataTable'
  ),
  uE = $({ ...Rd(), ...jd(), ...lo(), ...Od() }, 'VDataTable'),
  cE = J()({
    name: 'VDataTable',
    props: uE(),
    emits: {
      'update:modelValue': (e) => !0,
      'update:page': (e) => !0,
      'update:itemsPerPage': (e) => !0,
      'update:sortBy': (e) => !0,
      'update:options': (e) => !0,
      'update:groupBy': (e) => !0,
      'update:expanded': (e) => !0,
      'update:currentItems': (e) => !0,
    },
    setup(e, t) {
      let { attrs: n, slots: a } = t
      const { groupBy: l } = Dd(e),
        { sortBy: o, multiSort: i, mustSort: r } = ts(e),
        { page: s, itemsPerPage: c } = Md(e),
        { disableSort: u } = Yl(e),
        {
          columns: d,
          headers: f,
          sortFunctions: v,
          sortRawFunctions: g,
          filterFunctions: h,
        } = Fd(e, {
          groupBy: l,
          showSelect: B(() => e.showSelect),
          showExpand: B(() => e.showExpand),
        }),
        { items: m } = Hd(e, d),
        b = B(() => e.search),
        { filteredItems: y } = oo(e, m, b, { transform: (L) => L.columns, customKeyFilter: h }),
        { toggleSort: p } = ns({ sortBy: o, multiSort: i, mustSort: r, page: s }),
        {
          sortByWithGroups: S,
          opened: k,
          extractRows: _,
          isGroupOpen: P,
          toggleGroup: A,
        } = Xr({ groupBy: l, sortBy: o, disableSort: u }),
        { sortedItems: D } = Ld(e, y, S, {
          transform: (L) => ({ ...L.raw, ...L.columns }),
          sortFunctions: v,
          sortRawFunctions: g,
        }),
        { flatItems: E } = Zr(D, l, k, () => !!a['group-summary']),
        R = C(() => E.value.length),
        {
          startIndex: V,
          stopIndex: M,
          pageCount: F,
          setItemsPerPage: G,
        } = Bd({ page: s, itemsPerPage: c, itemsLength: R }),
        { paginatedItems: W } = fp({ items: E, startIndex: V, stopIndex: M, itemsPerPage: c }),
        te = C(() => _(W.value)),
        {
          isSelected: H,
          select: O,
          selectAll: j,
          toggleSelect: U,
          someSelected: Y,
          allSelected: K,
        } = Qr(e, { allItems: m, currentPage: te }),
        { isExpanded: se, toggleExpand: de } = qr(e)
      ;(Jr({ page: s, itemsPerPage: c, sortBy: o, groupBy: l, search: b }),
        lt({
          VDataTableRows: {
            hideNoData: B(() => e.hideNoData),
            noDataText: B(() => e.noDataText),
            loading: B(() => e.loading),
            loadingText: B(() => e.loadingText),
          },
        }))
      const ye = C(() => ({
        page: s.value,
        itemsPerPage: c.value,
        sortBy: o.value,
        pageCount: F.value,
        toggleSort: p,
        setItemsPerPage: G,
        someSelected: Y.value,
        allSelected: K.value,
        isSelected: H,
        select: O,
        selectAll: j,
        toggleSelect: U,
        isExpanded: se,
        toggleExpand: de,
        isGroupOpen: P,
        toggleGroup: A,
        items: te.value.map((L) => L.raw),
        internalItems: te.value,
        groupedItems: W.value,
        columns: d.value,
        headers: f.value,
      }))
      return (
        ne(() => {
          const L = Go.filterProps(e),
            q = tl.filterProps(e),
            le = nl.filterProps(e),
            ie = al.filterProps(e)
          return w(
            al,
            Z(
              {
                class: [
                  'v-data-table',
                  { 'v-data-table--show-select': e.showSelect, 'v-data-table--loading': e.loading },
                  e.class,
                ],
                style: e.style,
              },
              ie,
              { fixedHeader: e.fixedHeader || e.sticky }
            ),
            {
              top: () => a.top?.(ye.value),
              default: () =>
                a.default
                  ? a.default(ye.value)
                  : x(he, null, [
                      a.colgroup?.(ye.value),
                      !e.hideDefaultHeader && x('thead', { key: 'thead' }, [w(tl, q, a)]),
                      a.thead?.(ye.value),
                      !e.hideDefaultBody &&
                        x('tbody', null, [
                          a['body.prepend']?.(ye.value),
                          a.body ? a.body(ye.value) : w(nl, Z(n, le, { items: W.value }), a),
                          a['body.append']?.(ye.value),
                        ]),
                      a.tbody?.(ye.value),
                      a.tfoot?.(ye.value),
                    ]),
              bottom: () =>
                a.bottom
                  ? a.bottom(ye.value)
                  : !e.hideDefaultFooter &&
                    x(he, null, [w(rn, null, null), w(Go, L, { prepend: a['footer.prepend'] })]),
            }
          )
        }),
        {}
      )
    },
  }),
  dE = $({ ...je(jd(), ['hideDefaultFooter']), ...Ed(), ...$b(), ...lo() }, 'VDataTableVirtual'),
  fE = J()({
    name: 'VDataTableVirtual',
    props: dE(),
    emits: {
      'update:modelValue': (e) => !0,
      'update:sortBy': (e) => !0,
      'update:options': (e) => !0,
      'update:groupBy': (e) => !0,
      'update:expanded': (e) => !0,
    },
    setup(e, t) {
      let { attrs: n, slots: a } = t
      const { groupBy: l } = Dd(e),
        { sortBy: o, multiSort: i, mustSort: r } = ts(e),
        { disableSort: s } = Yl(e),
        {
          columns: c,
          headers: u,
          filterFunctions: d,
          sortFunctions: f,
          sortRawFunctions: v,
        } = Fd(e, {
          groupBy: l,
          showSelect: B(() => e.showSelect),
          showExpand: B(() => e.showExpand),
        }),
        { items: g } = Hd(e, c),
        h = B(() => e.search),
        { filteredItems: m } = oo(e, g, h, { transform: (ie) => ie.columns, customKeyFilter: d }),
        { toggleSort: b } = ns({ sortBy: o, multiSort: i, mustSort: r }),
        {
          sortByWithGroups: y,
          opened: p,
          extractRows: S,
          isGroupOpen: k,
          toggleGroup: _,
        } = Xr({ groupBy: l, sortBy: o, disableSort: s }),
        { sortedItems: P } = Ld(e, m, y, {
          transform: (ie) => ({ ...ie.raw, ...ie.columns }),
          sortFunctions: f,
          sortRawFunctions: v,
        }),
        { flatItems: A } = Zr(P, l, p, () => !!a['group-summary']),
        D = C(() => S(A.value)),
        {
          isSelected: E,
          select: R,
          selectAll: V,
          toggleSelect: M,
          someSelected: F,
          allSelected: G,
        } = Qr(e, { allItems: D, currentPage: D }),
        { isExpanded: W, toggleExpand: te } = qr(e),
        {
          containerRef: H,
          markerRef: O,
          paddingTop: j,
          paddingBottom: U,
          computedItems: Y,
          handleItemResize: K,
          handleScroll: se,
          handleScrollend: de,
          calculateVisibleItems: ye,
          scrollToIndex: L,
        } = Fb(e, A),
        q = C(() => Y.value.map((ie) => ie.raw))
      ;(Jr({ sortBy: o, page: oe(1), itemsPerPage: oe(-1), groupBy: l, search: h }),
        lt({
          VDataTableRows: {
            hideNoData: B(() => e.hideNoData),
            noDataText: B(() => e.noDataText),
            loading: B(() => e.loading),
            loadingText: B(() => e.loadingText),
          },
        }))
      const le = C(() => ({
        sortBy: o.value,
        toggleSort: b,
        someSelected: F.value,
        allSelected: G.value,
        isSelected: E,
        select: R,
        selectAll: V,
        toggleSelect: M,
        isExpanded: W,
        toggleExpand: te,
        isGroupOpen: k,
        toggleGroup: _,
        items: D.value.map((ie) => ie.raw),
        internalItems: D.value,
        groupedItems: A.value,
        columns: c.value,
        headers: u.value,
      }))
      return (
        ne(() => {
          const ie = tl.filterProps(e),
            Ce = nl.filterProps(e),
            pe = al.filterProps(e)
          return w(
            al,
            Z(
              {
                class: ['v-data-table', { 'v-data-table--loading': e.loading }, e.class],
                style: e.style,
              },
              pe,
              { fixedHeader: e.fixedHeader || e.sticky }
            ),
            {
              top: () => a.top?.(le.value),
              wrapper: () =>
                x(
                  'div',
                  {
                    ref: H,
                    onScrollPassive: se,
                    onScrollend: de,
                    class: 'v-table__wrapper',
                    style: { height: fe(e.height) },
                  },
                  [
                    x('table', null, [
                      a.colgroup?.(le.value),
                      !e.hideDefaultHeader && x('thead', { key: 'thead' }, [w(tl, ie, a)]),
                      a.thead?.(le.value),
                      !e.hideDefaultBody &&
                        x('tbody', { key: 'tbody' }, [
                          x('tr', { ref: O, style: { height: fe(j.value), border: 0 } }, [
                            x(
                              'td',
                              { colspan: c.value.length, style: { height: 0, border: 0 } },
                              null
                            ),
                          ]),
                          a['body.prepend']?.(le.value),
                          w(nl, Z(n, Ce, { items: q.value }), {
                            ...a,
                            item: (I) =>
                              w(
                                Ob,
                                {
                                  key: I.internalItem.index,
                                  renderless: !0,
                                  'onUpdate:height': (T) => K(I.internalItem.index, T),
                                },
                                {
                                  default: (T) => {
                                    let { itemRef: z } = T
                                    return (
                                      a.item?.({ ...I, itemRef: z }) ??
                                      w(
                                        Nd,
                                        Z(I.props, {
                                          ref: z,
                                          key: I.internalItem.index,
                                          index: I.internalItem.index,
                                        }),
                                        a
                                      )
                                    )
                                  },
                                }
                              ),
                          }),
                          a['body.append']?.(le.value),
                          x('tr', { style: { height: fe(U.value), border: 0 } }, [
                            x(
                              'td',
                              { colspan: c.value.length, style: { height: 0, border: 0 } },
                              null
                            ),
                          ]),
                        ]),
                      a.tbody?.(le.value),
                      a.tfoot?.(le.value),
                    ]),
                  ]
                ),
              bottom: () => a.bottom?.(le.value),
            }
          )
        }),
        { calculateVisibleItems: ye, scrollToIndex: L }
      )
    },
  }),
  vE = $(
    { itemsLength: { type: [Number, String], required: !0 }, ...Rd(), ...jd(), ...Od() },
    'VDataTableServer'
  ),
  mE = J()({
    name: 'VDataTableServer',
    props: vE(),
    emits: {
      'update:modelValue': (e) => !0,
      'update:page': (e) => !0,
      'update:itemsPerPage': (e) => !0,
      'update:sortBy': (e) => !0,
      'update:options': (e) => !0,
      'update:expanded': (e) => !0,
      'update:groupBy': (e) => !0,
    },
    setup(e, t) {
      let { attrs: n, slots: a } = t
      const { groupBy: l } = Dd(e),
        { sortBy: o, multiSort: i, mustSort: r } = ts(e),
        { page: s, itemsPerPage: c } = Md(e),
        { disableSort: u } = Yl(e),
        d = C(() => parseInt(e.itemsLength, 10)),
        { columns: f, headers: v } = Fd(e, {
          groupBy: l,
          showSelect: B(() => e.showSelect),
          showExpand: B(() => e.showExpand),
        }),
        { items: g } = Hd(e, f),
        { toggleSort: h } = ns({ sortBy: o, multiSort: i, mustSort: r, page: s }),
        {
          opened: m,
          isGroupOpen: b,
          toggleGroup: y,
          extractRows: p,
        } = Xr({ groupBy: l, sortBy: o, disableSort: u }),
        { pageCount: S, setItemsPerPage: k } = Bd({ page: s, itemsPerPage: c, itemsLength: d }),
        { flatItems: _ } = Zr(g, l, m, () => !!a['group-summary']),
        {
          isSelected: P,
          select: A,
          selectAll: D,
          toggleSelect: E,
          someSelected: R,
          allSelected: V,
        } = Qr(e, { allItems: g, currentPage: g }),
        { isExpanded: M, toggleExpand: F } = qr(e),
        G = C(() => p(g.value))
      ;(Jr({ page: s, itemsPerPage: c, sortBy: o, groupBy: l, search: B(() => e.search) }),
        Fe('v-data-table', { toggleSort: h, sortBy: o }),
        lt({
          VDataTableRows: {
            hideNoData: B(() => e.hideNoData),
            noDataText: B(() => e.noDataText),
            loading: B(() => e.loading),
            loadingText: B(() => e.loadingText),
          },
        }))
      const W = C(() => ({
        page: s.value,
        itemsPerPage: c.value,
        sortBy: o.value,
        pageCount: S.value,
        toggleSort: h,
        setItemsPerPage: k,
        someSelected: R.value,
        allSelected: V.value,
        isSelected: P,
        select: A,
        selectAll: D,
        toggleSelect: E,
        isExpanded: M,
        toggleExpand: F,
        isGroupOpen: b,
        toggleGroup: y,
        items: G.value.map((te) => te.raw),
        internalItems: G.value,
        groupedItems: _.value,
        columns: f.value,
        headers: v.value,
      }))
      ne(() => {
        const te = Go.filterProps(e),
          H = tl.filterProps(e),
          O = nl.filterProps(e),
          j = al.filterProps(e)
        return w(
          al,
          Z(
            {
              class: ['v-data-table', { 'v-data-table--loading': e.loading }, e.class],
              style: e.style,
            },
            j,
            { fixedHeader: e.fixedHeader || e.sticky }
          ),
          {
            top: () => a.top?.(W.value),
            default: () =>
              a.default
                ? a.default(W.value)
                : x(he, null, [
                    a.colgroup?.(W.value),
                    !e.hideDefaultHeader &&
                      x('thead', { key: 'thead', class: 'v-data-table__thead', role: 'rowgroup' }, [
                        w(tl, H, a),
                      ]),
                    a.thead?.(W.value),
                    !e.hideDefaultBody &&
                      x('tbody', { class: 'v-data-table__tbody', role: 'rowgroup' }, [
                        a['body.prepend']?.(W.value),
                        a.body ? a.body(W.value) : w(nl, Z(n, O, { items: _.value }), a),
                        a['body.append']?.(W.value),
                      ]),
                    a.tbody?.(W.value),
                    a.tfoot?.(W.value),
                  ]),
            bottom: () =>
              a.bottom
                ? a.bottom(W.value)
                : !e.hideDefaultFooter &&
                  x(he, null, [w(rn, null, null), w(Go, te, { prepend: a['footer.prepend'] })]),
          }
        )
      })
    },
  }),
  hE = $({ fluid: { type: Boolean, default: !1 }, ...be(), ...ft(), ...Ie() }, 'VContainer'),
  Ep = J()({
    name: 'VContainer',
    props: hE(),
    setup(e, t) {
      let { slots: n } = t
      const { rtlClasses: a } = gt(),
        { dimensionStyles: l } = vt(e)
      return (
        ne(() =>
          w(
            e.tag,
            {
              class: ee(['v-container', { 'v-container--fluid': e.fluid }, a.value, e.class]),
              style: ce([l.value, e.style]),
            },
            n
          )
        ),
        {}
      )
    },
  }),
  Dp = Lr.reduce((e, t) => ((e[t] = { type: [Boolean, String, Number], default: !1 }), e), {}),
  Rp = Lr.reduce((e, t) => {
    const n = 'offset' + Hn(t)
    return ((e[n] = { type: [String, Number], default: null }), e)
  }, {}),
  Mp = Lr.reduce((e, t) => {
    const n = 'order' + Hn(t)
    return ((e[n] = { type: [String, Number], default: null }), e)
  }, {}),
  hm = { col: Object.keys(Dp), offset: Object.keys(Rp), order: Object.keys(Mp) }
function gE(e, t, n) {
  let a = e
  if (!(n == null || n === !1)) {
    if (t) {
      const l = t.replace(e, '')
      a += `-${l}`
    }
    return (
      e === 'col' && (a = 'v-' + a),
      (e === 'col' && (n === '' || n === !0)) || (a += `-${n}`),
      a.toLowerCase()
    )
  }
}
const yE = ['auto', 'start', 'end', 'center', 'baseline', 'stretch'],
  bE = $(
    {
      cols: { type: [Boolean, String, Number], default: !1 },
      ...Dp,
      offset: { type: [String, Number], default: null },
      ...Rp,
      order: { type: [String, Number], default: null },
      ...Mp,
      alignSelf: { type: String, default: null, validator: (e) => yE.includes(e) },
      ...be(),
      ...Ie(),
    },
    'VCol'
  ),
  Bp = J()({
    name: 'VCol',
    props: bE(),
    setup(e, t) {
      let { slots: n } = t
      const a = C(() => {
        const l = []
        let o
        for (o in hm)
          hm[o].forEach((r) => {
            const s = e[r],
              c = gE(o, r, s)
            c && l.push(c)
          })
        const i = l.some((r) => r.startsWith('v-col-'))
        return (
          l.push({
            'v-col': !i || !e.cols,
            [`v-col-${e.cols}`]: e.cols,
            [`offset-${e.offset}`]: e.offset,
            [`order-${e.order}`]: e.order,
            [`align-self-${e.alignSelf}`]: e.alignSelf,
          }),
          l
        )
      })
      return () => ut(e.tag, { class: [a.value, e.class], style: e.style }, n.default?.())
    },
  }),
  zd = ['start', 'end', 'center'],
  Lp = ['space-between', 'space-around', 'space-evenly']
function Wd(e, t) {
  return Lr.reduce((n, a) => {
    const l = e + Hn(a)
    return ((n[l] = t()), n)
  }, {})
}
const pE = [...zd, 'baseline', 'stretch'],
  Op = (e) => pE.includes(e),
  $p = Wd('align', () => ({ type: String, default: null, validator: Op })),
  SE = [...zd, ...Lp],
  Fp = (e) => SE.includes(e),
  Np = Wd('justify', () => ({ type: String, default: null, validator: Fp })),
  wE = [...zd, ...Lp, 'stretch'],
  Hp = (e) => wE.includes(e),
  jp = Wd('alignContent', () => ({ type: String, default: null, validator: Hp })),
  gm = { align: Object.keys($p), justify: Object.keys(Np), alignContent: Object.keys(jp) },
  kE = { align: 'align', justify: 'justify', alignContent: 'align-content' }
function CE(e, t, n) {
  let a = kE[e]
  if (n != null) {
    if (t) {
      const l = t.replace(e, '')
      a += `-${l}`
    }
    return ((a += `-${n}`), a.toLowerCase())
  }
}
const xE = $(
    {
      dense: Boolean,
      noGutters: Boolean,
      align: { type: String, default: null, validator: Op },
      ...$p,
      justify: { type: String, default: null, validator: Fp },
      ...Np,
      alignContent: { type: String, default: null, validator: Hp },
      ...jp,
      ...be(),
      ...Ie(),
    },
    'VRow'
  ),
  zp = J()({
    name: 'VRow',
    props: xE(),
    setup(e, t) {
      let { slots: n } = t
      const a = C(() => {
        const l = []
        let o
        for (o in gm)
          gm[o].forEach((i) => {
            const r = e[i],
              s = CE(o, i, r)
            s && l.push(s)
          })
        return (
          l.push({
            'v-row--no-gutters': e.noGutters,
            'v-row--dense': e.dense,
            [`align-${e.align}`]: e.align,
            [`justify-${e.justify}`]: e.justify,
            [`align-content-${e.alignContent}`]: e.alignContent,
          }),
          l
        )
      })
      return () => ut(e.tag, { class: ['v-row', a.value, e.class], style: e.style }, n.default?.())
    },
  }),
  Wp = da('v-spacer', 'div', 'VSpacer'),
  Up = $(
    {
      active: { type: [String, Array], default: void 0 },
      controlHeight: [Number, String],
      disabled: { type: [Boolean, String, Array], default: null },
      nextIcon: { type: Se, default: '$next' },
      prevIcon: { type: Se, default: '$prev' },
      modeIcon: { type: Se, default: '$subgroup' },
      text: String,
      viewMode: { type: String, default: 'month' },
    },
    'VDatePickerControls'
  ),
  qu = J()({
    name: 'VDatePickerControls',
    props: Up(),
    emits: {
      'click:year': () => !0,
      'click:month': () => !0,
      'click:prev': () => !0,
      'click:next': () => !0,
      'click:text': () => !0,
    },
    setup(e, t) {
      let { emit: n } = t
      const { t: a } = ze(),
        l = C(() => (Array.isArray(e.disabled) ? e.disabled.includes('text') : !!e.disabled)),
        o = C(() => (Array.isArray(e.disabled) ? e.disabled.includes('mode') : !!e.disabled)),
        i = C(() => (Array.isArray(e.disabled) ? e.disabled.includes('prev') : !!e.disabled)),
        r = C(() => (Array.isArray(e.disabled) ? e.disabled.includes('next') : !!e.disabled))
      function s() {
        n('click:prev')
      }
      function c() {
        n('click:next')
      }
      function u() {
        n('click:year')
      }
      function d() {
        n('click:month')
      }
      return (
        ne(() =>
          x(
            'div',
            {
              class: ee(['v-date-picker-controls']),
              style: { '--v-date-picker-controls-height': fe(e.controlHeight) },
            },
            [
              w(
                Me,
                {
                  class: 'v-date-picker-controls__month-btn',
                  'data-testid': 'month-btn',
                  disabled: l.value,
                  text: e.text,
                  variant: 'text',
                  rounded: !0,
                  onClick: d,
                },
                null
              ),
              w(
                Me,
                {
                  class: 'v-date-picker-controls__mode-btn',
                  'data-testid': 'year-btn',
                  disabled: o.value,
                  density: 'comfortable',
                  icon: e.modeIcon,
                  variant: 'text',
                  'aria-label': a('$vuetify.datePicker.ariaLabel.selectYear'),
                  onClick: u,
                },
                null
              ),
              w(Wp, null, null),
              x('div', { class: 'v-date-picker-controls__month' }, [
                w(
                  Me,
                  {
                    'data-testid': 'prev-month',
                    disabled: i.value,
                    density: 'comfortable',
                    icon: e.prevIcon,
                    variant: 'text',
                    'aria-label': a('$vuetify.datePicker.ariaLabel.previousMonth'),
                    onClick: s,
                  },
                  null
                ),
                w(
                  Me,
                  {
                    'data-testid': 'next-month',
                    disabled: r.value,
                    icon: e.nextIcon,
                    density: 'comfortable',
                    variant: 'text',
                    'aria-label': a('$vuetify.datePicker.ariaLabel.nextMonth'),
                    onClick: c,
                  },
                  null
                ),
              ]),
            ]
          )
        ),
        {}
      )
    },
  }),
  _E = $(
    { appendIcon: Se, color: String, header: String, transition: String, onClick: Pt() },
    'VDatePickerHeader'
  ),
  Xu = J()({
    name: 'VDatePickerHeader',
    props: _E(),
    emits: { click: () => !0, 'click:append': () => !0 },
    setup(e, t) {
      let { emit: n, slots: a } = t
      const { backgroundColorClasses: l, backgroundColorStyles: o } = He(() => e.color)
      function i() {
        n('click')
      }
      function r() {
        n('click:append')
      }
      return (
        ne(() => {
          const s = !!(a.default || e.header),
            c = !!(a.append || e.appendIcon)
          return x(
            'div',
            {
              class: ee([
                'v-date-picker-header',
                { 'v-date-picker-header--clickable': !!e.onClick },
                l.value,
              ]),
              style: ce(o.value),
              onClick: i,
            },
            [
              a.prepend &&
                x('div', { key: 'prepend', class: 'v-date-picker-header__prepend' }, [a.prepend()]),
              s &&
                w(
                  $t,
                  { key: 'content', name: e.transition },
                  {
                    default: () => [
                      x('div', { key: e.header, class: 'v-date-picker-header__content' }, [
                        a.default?.() ?? e.header,
                      ]),
                    ],
                  }
                ),
              c &&
                x('div', { class: 'v-date-picker-header__append' }, [
                  a.append
                    ? w(
                        Ae,
                        {
                          key: 'append-defaults',
                          disabled: !e.appendIcon,
                          defaults: { VBtn: { icon: e.appendIcon, variant: 'text' } },
                        },
                        { default: () => [a.append?.()] }
                      )
                    : w(
                        Me,
                        { key: 'append-btn', icon: e.appendIcon, variant: 'text', onClick: r },
                        null
                      ),
                ]),
            ]
          )
        }),
        {}
      )
    },
  }),
  PE = $(
    {
      allowedDates: [Array, Function],
      disabled: { type: Boolean, default: null },
      displayValue: null,
      modelValue: Array,
      month: [Number, String],
      max: null,
      min: null,
      showAdjacentMonths: Boolean,
      year: [Number, String],
      weekdays: { type: Array, default: () => [0, 1, 2, 3, 4, 5, 6] },
      weeksInMonth: { type: String, default: 'dynamic' },
      firstDayOfWeek: { type: [Number, String], default: void 0 },
      firstDayOfYear: { type: [Number, String], default: void 0 },
      weekdayFormat: String,
    },
    'calendar'
  )
function VE(e) {
  const t = li(),
    n = we(e, 'modelValue', [], (v) => nt(v).map((g) => t.date(g))),
    a = C(() =>
      e.displayValue
        ? t.date(e.displayValue)
        : n.value.length > 0
          ? t.date(n.value[0])
          : e.min
            ? t.date(e.min)
            : Array.isArray(e.allowedDates)
              ? t.date(e.allowedDates[0])
              : t.date()
    ),
    l = we(
      e,
      'year',
      void 0,
      (v) => {
        const g = v != null ? Number(v) : t.getYear(a.value)
        return t.startOfYear(t.setYear(t.date(), g))
      },
      (v) => t.getYear(v)
    ),
    o = we(
      e,
      'month',
      void 0,
      (v) => {
        const g = v != null ? Number(v) : t.getMonth(a.value),
          h = t.setYear(t.startOfMonth(t.date()), t.getYear(l.value))
        return t.setMonth(h, g)
      },
      (v) => t.getMonth(v)
    ),
    i = C(() => {
      const v = t.toJsDate(t.startOfWeek(t.date(), e.firstDayOfWeek)).getDay()
      return t
        .getWeekdays(e.firstDayOfWeek, e.weekdayFormat)
        .filter((g, h) => e.weekdays.includes((h + v) % 7))
    }),
    r = C(() => {
      const v = t.getWeekArray(o.value, e.firstDayOfWeek),
        g = v.flat(),
        h = 42
      if (e.weeksInMonth === 'static' && g.length < h) {
        const m = g[g.length - 1]
        let b = []
        for (let y = 1; y <= h - g.length; y++)
          (b.push(t.addDays(m, y)), y % 7 === 0 && (v.push(b), (b = [])))
      }
      return v
    })
  function s(v, g) {
    return v
      .filter((h) => e.weekdays.includes(t.toJsDate(h).getDay()))
      .map((h, m) => {
        const b = t.toISO(h),
          y = !t.isSameMonth(h, o.value),
          p = t.isSameDay(h, t.startOfMonth(o.value)),
          S = t.isSameDay(h, t.endOfMonth(o.value)),
          k = t.isSameDay(h, o.value),
          _ = e.weekdays.length
        return {
          date: h,
          formatted: t.format(h, 'keyboardDate'),
          isAdjacent: y,
          isDisabled: f(h),
          isEnd: S,
          isHidden: y && !e.showAdjacentMonths,
          isSame: k,
          isSelected: n.value.some((P) => t.isSameDay(h, P)),
          isStart: p,
          isToday: t.isSameDay(h, g),
          isWeekEnd: m % _ === _ - 1,
          isWeekStart: m % _ === 0,
          isoDate: b,
          localized: t.format(h, 'dayOfMonth'),
          month: t.getMonth(h),
          year: t.getYear(h),
        }
      })
  }
  const c = C(() => {
      const v = t.startOfWeek(a.value, e.firstDayOfWeek),
        g = []
      for (let m = 0; m <= 6; m++) g.push(t.addDays(v, m))
      const h = t.date()
      return s(g, h)
    }),
    u = C(() => {
      const v = r.value.flat(),
        g = t.date()
      return s(v, g)
    }),
    d = C(() =>
      r.value.map((v) => (v.length ? t.getWeek(v[0], e.firstDayOfWeek, e.firstDayOfYear) : null))
    )
  function f(v) {
    if (e.disabled) return !0
    const g = t.date(v)
    return (e.min && t.isBefore(t.endOfDay(g), t.date(e.min))) ||
      (e.max && t.isAfter(g, t.date(e.max)))
      ? !0
      : Array.isArray(e.allowedDates) && e.allowedDates.length > 0
        ? !e.allowedDates.some((h) => t.isSameDay(t.date(h), g))
        : typeof e.allowedDates == 'function'
          ? !e.allowedDates(g)
          : !1
  }
  return {
    displayValue: a,
    daysInMonth: u,
    daysInWeek: c,
    genDays: s,
    model: n,
    weeksInMonth: r,
    weekdayLabels: i,
    weekNumbers: d,
  }
}
const Kp = $(
    {
      color: String,
      hideWeekdays: Boolean,
      multiple: [Boolean, Number, String],
      showWeek: Boolean,
      transition: { type: String, default: 'picker-transition' },
      reverseTransition: { type: String, default: 'picker-reverse-transition' },
      ...je(PE(), ['displayValue']),
    },
    'VDatePickerMonth'
  ),
  Zu = J()({
    name: 'VDatePickerMonth',
    props: Kp(),
    emits: { 'update:modelValue': (e) => !0, 'update:month': (e) => !0, 'update:year': (e) => !0 },
    setup(e, t) {
      let { emit: n, slots: a } = t
      const l = ae(),
        { t: o } = ze(),
        { daysInMonth: i, model: r, weekNumbers: s, weekdayLabels: c } = VE(e),
        u = li(),
        d = oe(),
        f = oe(),
        v = oe(!1),
        g = B(() => (v.value ? e.reverseTransition : e.transition))
      e.multiple === 'range' &&
        r.value.length > 0 &&
        ((d.value = r.value[0]), r.value.length > 1 && (f.value = r.value[r.value.length - 1]))
      const h = C(() => {
        const S = ['number', 'string'].includes(typeof e.multiple) ? Number(e.multiple) : 1 / 0
        return r.value.length >= S
      })
      ue(i, (S, k) => {
        k && (v.value = u.isBefore(S[0].date, k[0].date))
      })
      function m(S) {
        const k = u.startOfDay(S)
        if (
          (r.value.length === 0
            ? (d.value = void 0)
            : r.value.length === 1 && ((d.value = r.value[0]), (f.value = void 0)),
          !d.value)
        )
          ((d.value = k), (r.value = [d.value]))
        else if (f.value) ((d.value = S), (f.value = void 0), (r.value = [d.value]))
        else {
          if (u.isSameDay(k, d.value)) {
            ;((d.value = void 0), (r.value = []))
            return
          } else
            u.isBefore(k, d.value)
              ? ((f.value = u.endOfDay(d.value)), (d.value = k))
              : (f.value = u.endOfDay(k))
          r.value = RP(u, d.value, f.value)
        }
      }
      function b(S) {
        const k = u.format(S.date, 'fullDateWithWeekday'),
          _ = S.isToday ? 'currentDate' : 'selectDate'
        return o(`$vuetify.datePicker.ariaLabel.${_}`, k)
      }
      function y(S) {
        const k = r.value.findIndex((_) => u.isSameDay(_, S))
        if (k === -1) r.value = [...r.value, S]
        else {
          const _ = [...r.value]
          ;(_.splice(k, 1), (r.value = _))
        }
      }
      function p(S) {
        e.multiple === 'range' ? m(S) : e.multiple ? y(S) : (r.value = [S])
      }
      ne(() =>
        x(
          'div',
          {
            class: 'v-date-picker-month',
            style: { '--v-date-picker-days-in-week': e.weekdays.length },
          },
          [
            e.showWeek &&
              x('div', { key: 'weeks', class: 'v-date-picker-month__weeks' }, [
                !e.hideWeekdays &&
                  x('div', { key: 'hide-week-days', class: 'v-date-picker-month__day' }, [qt(' ')]),
                s.value.map((S) =>
                  x(
                    'div',
                    {
                      class: ee(['v-date-picker-month__day', 'v-date-picker-month__day--adjacent']),
                    },
                    [S]
                  )
                ),
              ]),
            w(
              $t,
              { name: g.value },
              {
                default: () => [
                  x(
                    'div',
                    {
                      ref: l,
                      key: i.value[0].date?.toString(),
                      class: 'v-date-picker-month__days',
                    },
                    [
                      !e.hideWeekdays &&
                        c.value.map((S) =>
                          x(
                            'div',
                            {
                              class: ee([
                                'v-date-picker-month__day',
                                'v-date-picker-month__weekday',
                              ]),
                            },
                            [S]
                          )
                        ),
                      i.value.map((S, k) => {
                        const _ = {
                          props: {
                            class: 'v-date-picker-month__day-btn',
                            color: S.isSelected || S.isToday ? e.color : void 0,
                            disabled: S.isDisabled,
                            icon: !0,
                            ripple: !1,
                            text: S.localized,
                            variant: S.isSelected ? 'flat' : S.isToday ? 'outlined' : 'text',
                            'aria-label': b(S),
                            'aria-current': S.isToday ? 'date' : void 0,
                            onClick: () => p(S.date),
                          },
                          item: S,
                          i: k,
                        }
                        return (
                          h.value && !S.isSelected && (S.isDisabled = !0),
                          x(
                            'div',
                            {
                              class: ee([
                                'v-date-picker-month__day',
                                {
                                  'v-date-picker-month__day--adjacent': S.isAdjacent,
                                  'v-date-picker-month__day--hide-adjacent': S.isHidden,
                                  'v-date-picker-month__day--selected': S.isSelected,
                                  'v-date-picker-month__day--week-end': S.isWeekEnd,
                                  'v-date-picker-month__day--week-start': S.isWeekStart,
                                },
                              ]),
                              'data-v-date': S.isDisabled ? void 0 : S.isoDate,
                            },
                            [
                              (e.showAdjacentMonths || !S.isAdjacent) &&
                                (a.day?.(_) ?? w(Me, _.props, null)),
                            ]
                          )
                        )
                      }),
                    ]
                  ),
                ],
              }
            ),
          ]
        )
      )
    },
  }),
  Gp = $(
    {
      color: String,
      height: [String, Number],
      min: null,
      max: null,
      modelValue: Number,
      year: Number,
      allowedMonths: [Array, Function],
    },
    'VDatePickerMonths'
  ),
  Ju = J()({
    name: 'VDatePickerMonths',
    props: Gp(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { emit: n, slots: a } = t
      const l = li(),
        o = we(e, 'modelValue'),
        i = C(() => {
          let s = l.startOfYear(l.date())
          return (
            e.year && (s = l.setYear(s, e.year)),
            ln(12).map((c) => {
              const u = l.format(s, 'monthShort'),
                d = l.format(s, 'month'),
                f = !!(
                  !r(c) ||
                  (e.min && l.isAfter(l.startOfMonth(l.date(e.min)), s)) ||
                  (e.max && l.isAfter(s, l.startOfMonth(l.date(e.max))))
                )
              return ((s = l.getNextMonth(s)), { isDisabled: f, text: u, label: d, value: c })
            })
          )
        })
      qe(() => {
        o.value = o.value ?? l.getMonth(l.date())
      })
      function r(s) {
        return Array.isArray(e.allowedMonths) && e.allowedMonths.length
          ? e.allowedMonths.includes(s)
          : typeof e.allowedMonths == 'function'
            ? e.allowedMonths(s)
            : !0
      }
      return (
        ne(() =>
          x('div', { class: 'v-date-picker-months', style: { height: fe(e.height) } }, [
            x('div', { class: 'v-date-picker-months__content' }, [
              i.value.map((s, c) => {
                const u = {
                  active: o.value === c,
                  ariaLabel: s.label,
                  color: o.value === c ? e.color : void 0,
                  disabled: s.isDisabled,
                  rounded: !0,
                  text: s.text,
                  variant: o.value === s.value ? 'flat' : 'text',
                  onClick: () => d(c),
                }
                function d(f) {
                  if (o.value === f) {
                    n('update:modelValue', o.value)
                    return
                  }
                  o.value = f
                }
                return (
                  a.month?.({ month: s, i: c, props: u }) ?? w(Me, Z({ key: 'month' }, u), null)
                )
              }),
            ]),
          ])
        ),
        {}
      )
    },
  }),
  Yp = $(
    {
      color: String,
      height: [String, Number],
      min: null,
      max: null,
      modelValue: Number,
      allowedYears: [Array, Function],
    },
    'VDatePickerYears'
  ),
  Qu = J()({
    name: 'VDatePickerYears',
    props: Yp(),
    directives: { vIntersect: xn },
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { emit: n, slots: a } = t
      const l = li(),
        o = we(e, 'modelValue'),
        i = C(() => {
          const u = l.getYear(l.date())
          let d = u - 100,
            f = u + 52
          ;(e.min && (d = l.getYear(l.date(e.min))), e.max && (f = l.getYear(l.date(e.max))))
          let v = l.startOfYear(l.date())
          return (
            (v = l.setYear(v, d)),
            ln(f - d + 1, d).map((g) => {
              const h = l.format(v, 'year')
              return (
                (v = l.setYear(v, l.getYear(v) + 1)),
                { text: h, value: g, isDisabled: !c(g) }
              )
            })
          )
        })
      qe(() => {
        o.value = o.value ?? l.getYear(l.date())
      })
      const r = sr()
      function s() {
        ;(r.el?.focus(), r.el?.scrollIntoView({ block: 'center' }))
      }
      function c(u) {
        return Array.isArray(e.allowedYears) && e.allowedYears.length
          ? e.allowedYears.includes(u)
          : typeof e.allowedYears == 'function'
            ? e.allowedYears(u)
            : !0
      }
      return (
        ne(() =>
          tt(
            x('div', { class: 'v-date-picker-years', style: { height: fe(e.height) } }, [
              x('div', { class: 'v-date-picker-years__content' }, [
                i.value.map((u, d) => {
                  const f = {
                    ref: o.value === u.value ? r : void 0,
                    active: o.value === u.value,
                    color: o.value === u.value ? e.color : void 0,
                    rounded: !0,
                    text: u.text,
                    disabled: u.isDisabled,
                    variant: o.value === u.value ? 'flat' : 'text',
                    onClick: () => {
                      if (o.value === u.value) {
                        n('update:modelValue', o.value)
                        return
                      }
                      o.value = u.value
                    },
                  }
                  return (
                    a.year?.({ year: u, i: d, props: f }) ?? w(Me, Z({ key: 'month' }, f), null)
                  )
                }),
              ]),
            ]),
            [[xn, { handler: s }, null, { once: !0 }]]
          )
        ),
        {}
      )
    },
  }),
  IE = $(
    {
      header: { type: String, default: '$vuetify.datePicker.header' },
      headerColor: String,
      ...Up(),
      ...Kp({ weeksInMonth: 'static' }),
      ...je(Gp(), ['modelValue']),
      ...je(Yp(), ['modelValue']),
      ...Yr({ title: '$vuetify.datePicker.title' }),
      modelValue: null,
    },
    'VDatePicker'
  ),
  TE = J()({
    name: 'VDatePicker',
    props: IE(),
    emits: {
      'update:modelValue': (e) => !0,
      'update:month': (e) => !0,
      'update:year': (e) => !0,
      'update:viewMode': (e) => !0,
    },
    setup(e, t) {
      let { emit: n, slots: a } = t
      const l = li(),
        { t: o } = ze(),
        { rtlClasses: i } = gt(),
        r = we(
          e,
          'modelValue',
          void 0,
          (H) => nt(H).map((O) => l.date(O)),
          (H) => (e.multiple ? H : H[0])
        ),
        s = we(e, 'viewMode'),
        c = C(() => {
          const H = l.date(e.min)
          return e.min && l.isValid(H) ? H : null
        }),
        u = C(() => {
          const H = l.date(e.max)
          return e.max && l.isValid(H) ? H : null
        }),
        d = C(() => {
          const H = l.date()
          let O = H
          return (
            r.value?.[0]
              ? (O = l.date(r.value[0]))
              : c.value && l.isBefore(H, c.value)
                ? (O = c.value)
                : u.value && l.isAfter(H, u.value) && (O = u.value),
            O && l.isValid(O) ? O : H
          )
        }),
        f = B(() => e.headerColor ?? e.color),
        v = we(e, 'month'),
        g = C({
          get: () => Number(v.value ?? l.getMonth(l.startOfMonth(d.value))),
          set: (H) => (v.value = H),
        }),
        h = we(e, 'year'),
        m = C({
          get: () => Number(h.value ?? l.getYear(l.startOfYear(l.setMonth(d.value, g.value)))),
          set: (H) => (h.value = H),
        }),
        b = oe(!1),
        y = C(() =>
          e.multiple && r.value.length > 1
            ? o('$vuetify.datePicker.itemsSelected', r.value.length)
            : r.value[0] && l.isValid(r.value[0])
              ? l.format(l.date(r.value[0]), 'normalDateWithWeekday')
              : o(e.header)
        ),
        p = C(() => {
          let H = l.date()
          return (
            (H = l.setDate(H, 1)),
            (H = l.setMonth(H, g.value)),
            (H = l.setYear(H, m.value)),
            l.format(H, 'monthAndYear')
          )
        }),
        S = B(() => `date-picker-header${b.value ? '-reverse' : ''}-transition`),
        k = C(() => {
          if (e.disabled) return !0
          const H = []
          if (s.value !== 'month') H.push('prev', 'next')
          else {
            let O = l.date()
            if (
              ((O = l.startOfMonth(O)),
              (O = l.setMonth(O, g.value)),
              (O = l.setYear(O, m.value)),
              c.value)
            ) {
              const j = l.addDays(l.startOfMonth(O), -1)
              l.isAfter(c.value, j) && H.push('prev')
            }
            if (u.value) {
              const j = l.addDays(l.endOfMonth(O), 1)
              l.isAfter(j, u.value) && H.push('next')
            }
          }
          return H
        }),
        _ = C(() => e.allowedYears || D),
        P = C(() => e.allowedMonths || E)
      function A(H, O) {
        const j = e.allowedDates
        if (typeof j != 'function') return !0
        const U = l.getDiff(O, H, 'days')
        for (let Y = 0; Y < U; Y++) if (j(l.addDays(H, Y))) return !0
        return !1
      }
      function D(H) {
        if (typeof e.allowedDates == 'function') {
          const O = l.parseISO(`${H}-01-01`)
          return A(O, l.endOfYear(O))
        }
        if (Array.isArray(e.allowedDates) && e.allowedDates.length) {
          for (const O of e.allowedDates) if (l.getYear(l.date(O)) === H) return !0
          return !1
        }
        return !0
      }
      function E(H) {
        if (typeof e.allowedDates == 'function') {
          const O = String(H + 1).padStart(2, '0'),
            j = l.parseISO(`${m.value}-${O}-01`)
          return A(j, l.endOfMonth(j))
        }
        if (Array.isArray(e.allowedDates) && e.allowedDates.length) {
          for (const O of e.allowedDates)
            if (l.getYear(l.date(O)) === m.value && l.getMonth(l.date(O)) === H) return !0
          return !1
        }
        return !0
      }
      function R() {
        ;(g.value < 11 ? g.value++ : (m.value++, (g.value = 0), te()), W())
      }
      function V() {
        ;(g.value > 0 ? g.value-- : (m.value--, (g.value = 11), te()), W())
      }
      function M() {
        s.value = 'month'
      }
      function F() {
        s.value = s.value === 'months' ? 'month' : 'months'
      }
      function G() {
        s.value = s.value === 'year' ? 'month' : 'year'
      }
      function W() {
        s.value === 'months' && F()
      }
      function te() {
        s.value === 'year' && G()
      }
      return (
        ue(r, (H, O) => {
          const j = nt(O),
            U = nt(H)
          if (!U.length) return
          const Y = l.date(j[j.length - 1]),
            K = l.date(U[U.length - 1]),
            se = l.getMonth(K),
            de = l.getYear(K)
          ;(se !== g.value && ((g.value = se), W()),
            de !== m.value && ((m.value = de), te()),
            (b.value = l.isBefore(Y, K)))
        }),
        ne(() => {
          const H = Gl.filterProps(e),
            O = qu.filterProps(e),
            j = Xu.filterProps(e),
            U = Zu.filterProps(e),
            Y = je(Ju.filterProps(e), ['modelValue']),
            K = je(Qu.filterProps(e), ['modelValue']),
            se = { color: f.value, header: y.value, transition: S.value }
          return w(
            Gl,
            Z(H, {
              color: f.value,
              class: [
                'v-date-picker',
                `v-date-picker--${s.value}`,
                { 'v-date-picker--show-week': e.showWeek },
                i.value,
                e.class,
              ],
              style: e.style,
            }),
            {
              title: () => a.title?.() ?? x('div', { class: 'v-date-picker__title' }, [o(e.title)]),
              header: () =>
                a.header
                  ? w(
                      Ae,
                      { defaults: { VDatePickerHeader: { ...se } } },
                      { default: () => [a.header?.(se)] }
                    )
                  : w(
                      Xu,
                      Z({ key: 'header' }, j, se, { onClick: s.value !== 'month' ? M : void 0 }),
                      { prepend: a.prepend, append: a.append }
                    ),
              default: () =>
                x(he, null, [
                  w(
                    qu,
                    Z(O, {
                      disabled: k.value,
                      text: p.value,
                      'onClick:next': R,
                      'onClick:prev': V,
                      'onClick:month': F,
                      'onClick:year': G,
                    }),
                    null
                  ),
                  w(
                    Fo,
                    { hideOnLeave: !0 },
                    {
                      default: () => [
                        s.value === 'months'
                          ? w(
                              Ju,
                              Z({ key: 'date-picker-months' }, Y, {
                                modelValue: g.value,
                                'onUpdate:modelValue': [(de) => (g.value = de), W],
                                min: c.value,
                                max: u.value,
                                year: m.value,
                                allowedMonths: P.value,
                              }),
                              { month: a.month }
                            )
                          : s.value === 'year'
                            ? w(
                                Qu,
                                Z({ key: 'date-picker-years' }, K, {
                                  modelValue: m.value,
                                  'onUpdate:modelValue': [(de) => (m.value = de), te],
                                  min: c.value,
                                  max: u.value,
                                  allowedYears: _.value,
                                }),
                                { year: a.year }
                              )
                            : w(
                                Zu,
                                Z({ key: 'date-picker-month' }, U, {
                                  modelValue: r.value,
                                  'onUpdate:modelValue': (de) => (r.value = de),
                                  month: g.value,
                                  'onUpdate:month': [(de) => (g.value = de), W],
                                  year: m.value,
                                  'onUpdate:year': [(de) => (m.value = de), te],
                                  min: c.value,
                                  max: u.value,
                                }),
                                { day: a.day }
                              ),
                      ],
                    }
                  ),
                ]),
              actions: a.actions,
            }
          )
        }),
        {}
      )
    },
  }),
  AE = $(
    {
      actionText: String,
      bgColor: String,
      color: String,
      icon: Se,
      image: String,
      justify: { type: String, default: 'center' },
      headline: String,
      title: String,
      text: String,
      textWidth: { type: [Number, String], default: 500 },
      href: String,
      to: String,
      ...be(),
      ...ft(),
      ...Un({ size: void 0 }),
      ...Be(),
    },
    'VEmptyState'
  ),
  EE = J()({
    name: 'VEmptyState',
    props: AE(),
    emits: { 'click:action': (e) => !0 },
    setup(e, t) {
      let { emit: n, slots: a } = t
      const { themeClasses: l } = $e(e),
        { backgroundColorClasses: o, backgroundColorStyles: i } = He(() => e.bgColor),
        { dimensionStyles: r } = vt(e),
        { displayClasses: s } = gn()
      function c(u) {
        n('click:action', u)
      }
      return (
        ne(() => {
          const u = !!(a.actions || e.actionText),
            d = !!(a.headline || e.headline),
            f = !!(a.title || e.title),
            v = !!(a.text || e.text),
            g = !!(a.media || e.image || e.icon),
            h = e.size || (e.image ? 200 : 96)
          return x(
            'div',
            {
              class: ee([
                'v-empty-state',
                { [`v-empty-state--${e.justify}`]: !0 },
                l.value,
                o.value,
                s.value,
                e.class,
              ]),
              style: ce([i.value, r.value, e.style]),
            },
            [
              g &&
                x('div', { key: 'media', class: 'v-empty-state__media' }, [
                  a.media
                    ? w(
                        Ae,
                        {
                          key: 'media-defaults',
                          defaults: {
                            VImg: { src: e.image, height: h },
                            VIcon: { size: h, icon: e.icon },
                          },
                        },
                        { default: () => [a.media()] }
                      )
                    : x(he, null, [
                        e.image
                          ? w(oa, { key: 'image', src: e.image, height: h }, null)
                          : e.icon
                            ? w(Le, { key: 'icon', color: e.color, size: h, icon: e.icon }, null)
                            : void 0,
                      ]),
                ]),
              d &&
                x('div', { key: 'headline', class: 'v-empty-state__headline' }, [
                  a.headline?.() ?? e.headline,
                ]),
              f &&
                x('div', { key: 'title', class: 'v-empty-state__title' }, [a.title?.() ?? e.title]),
              v &&
                x(
                  'div',
                  {
                    key: 'text',
                    class: 'v-empty-state__text',
                    style: { maxWidth: fe(e.textWidth) },
                  },
                  [a.text?.() ?? e.text]
                ),
              a.default &&
                x('div', { key: 'content', class: 'v-empty-state__content' }, [a.default()]),
              u &&
                x('div', { key: 'actions', class: 'v-empty-state__actions' }, [
                  w(
                    Ae,
                    {
                      defaults: {
                        VBtn: {
                          class: 'v-empty-state__action-btn',
                          color: e.color ?? 'surface-variant',
                          href: e.href,
                          text: e.actionText,
                          to: e.to,
                        },
                      },
                    },
                    {
                      default: () => [
                        a.actions?.({ props: { onClick: c } }) ?? w(Me, { onClick: c }, null),
                      ],
                    }
                  ),
                ]),
            ]
          )
        }),
        {}
      )
    },
  }),
  qo = Symbol.for('vuetify:v-expansion-panel'),
  qp = $({ ...be(), ...wd() }, 'VExpansionPanelText'),
  ec = J()({
    name: 'VExpansionPanelText',
    props: qp(),
    setup(e, t) {
      let { slots: n } = t
      const a = Ve(qo)
      if (!a)
        throw new Error(
          '[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel'
        )
      const { hasContent: l, onAfterLeave: o } = kd(e, a.isSelected)
      return (
        ne(() =>
          w(
            Fr,
            { onAfterLeave: o },
            {
              default: () => [
                tt(
                  x('div', { class: ee(['v-expansion-panel-text', e.class]), style: ce(e.style) }, [
                    n.default &&
                      l.value &&
                      x('div', { class: 'v-expansion-panel-text__wrapper' }, [n.default?.()]),
                  ]),
                  [[Pn, a.isSelected.value]]
                ),
              ],
            }
          )
        ),
        {}
      )
    },
  }),
  Xp = $(
    {
      color: String,
      expandIcon: { type: Se, default: '$expand' },
      collapseIcon: { type: Se, default: '$collapse' },
      hideActions: Boolean,
      focusable: Boolean,
      static: Boolean,
      ripple: { type: [Boolean, Object], default: !1 },
      readonly: Boolean,
      ...be(),
      ...ft(),
    },
    'VExpansionPanelTitle'
  ),
  tc = J()({
    name: 'VExpansionPanelTitle',
    directives: { vRipple: Nt },
    props: Xp(),
    setup(e, t) {
      let { slots: n } = t
      const a = Ve(qo)
      if (!a)
        throw new Error(
          '[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel'
        )
      const { backgroundColorClasses: l, backgroundColorStyles: o } = He(() => e.color),
        { dimensionStyles: i } = vt(e),
        r = C(() => ({
          collapseIcon: e.collapseIcon,
          disabled: a.disabled.value,
          expanded: a.isSelected.value,
          expandIcon: e.expandIcon,
          readonly: e.readonly,
        })),
        s = B(() => (a.isSelected.value ? e.collapseIcon : e.expandIcon))
      return (
        ne(() =>
          tt(
            x(
              'button',
              {
                class: ee([
                  'v-expansion-panel-title',
                  {
                    'v-expansion-panel-title--active': a.isSelected.value,
                    'v-expansion-panel-title--focusable': e.focusable,
                    'v-expansion-panel-title--static': e.static,
                  },
                  l.value,
                  e.class,
                ]),
                style: ce([o.value, i.value, e.style]),
                type: 'button',
                tabindex: a.disabled.value ? -1 : void 0,
                disabled: a.disabled.value,
                'aria-expanded': a.isSelected.value,
                onClick: e.readonly ? void 0 : a.toggle,
              },
              [
                x('span', { class: 'v-expansion-panel-title__overlay' }, null),
                n.default?.(r.value),
                !e.hideActions &&
                  w(
                    Ae,
                    { defaults: { VIcon: { icon: s.value } } },
                    {
                      default: () => [
                        x('span', { class: 'v-expansion-panel-title__icon' }, [
                          n.actions?.(r.value) ?? w(Le, null, null),
                        ]),
                      ],
                    }
                  ),
              ]
            ),
            [[Nt, e.ripple]]
          )
        ),
        {}
      )
    },
  }),
  Zp = $(
    {
      title: String,
      text: String,
      bgColor: String,
      ...yt(),
      ...dl(),
      ...Je(),
      ...Ie(),
      ...Xp(),
      ...qp(),
    },
    'VExpansionPanel'
  ),
  DE = J()({
    name: 'VExpansionPanel',
    props: Zp(),
    emits: { 'group:selected': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = fl(e, qo),
        { backgroundColorClasses: l, backgroundColorStyles: o } = He(() => e.bgColor),
        { elevationClasses: i } = xt(e),
        { roundedClasses: r } = ot(e),
        s = B(() => a?.disabled.value || e.disabled),
        c = C(() =>
          a.group.items.value.reduce(
            (f, v, g) => (a.group.selected.value.includes(v.id) && f.push(g), f),
            []
          )
        ),
        u = C(() => {
          const f = a.group.items.value.findIndex((v) => v.id === a.id)
          return !a.isSelected.value && c.value.some((v) => v - f === 1)
        }),
        d = C(() => {
          const f = a.group.items.value.findIndex((v) => v.id === a.id)
          return !a.isSelected.value && c.value.some((v) => v - f === -1)
        })
      return (
        Fe(qo, a),
        ne(() => {
          const f = !!(n.text || e.text),
            v = !!(n.title || e.title),
            g = tc.filterProps(e),
            h = ec.filterProps(e)
          return w(
            e.tag,
            {
              class: ee([
                'v-expansion-panel',
                {
                  'v-expansion-panel--active': a.isSelected.value,
                  'v-expansion-panel--before-active': u.value,
                  'v-expansion-panel--after-active': d.value,
                  'v-expansion-panel--disabled': s.value,
                },
                r.value,
                l.value,
                e.class,
              ]),
              style: ce([o.value, e.style]),
            },
            {
              default: () => [
                x('div', { class: ee(['v-expansion-panel__shadow', ...i.value]) }, null),
                w(
                  Ae,
                  { defaults: { VExpansionPanelTitle: { ...g }, VExpansionPanelText: { ...h } } },
                  {
                    default: () => [
                      v &&
                        w(tc, { key: 'title' }, { default: () => [n.title ? n.title() : e.title] }),
                      f && w(ec, { key: 'text' }, { default: () => [n.text ? n.text() : e.text] }),
                      n.default?.(),
                    ],
                  }
                ),
              ],
            }
          )
        }),
        { groupItem: a }
      )
    },
  }),
  RE = ['default', 'accordion', 'inset', 'popout'],
  ME = $(
    {
      flat: Boolean,
      ...cl(),
      ...Zt(Zp(), [
        'bgColor',
        'collapseIcon',
        'color',
        'eager',
        'elevation',
        'expandIcon',
        'focusable',
        'hideActions',
        'readonly',
        'ripple',
        'rounded',
        'tile',
        'static',
      ]),
      ...Be(),
      ...be(),
      ...Ie(),
      variant: { type: String, default: 'default', validator: (e) => RE.includes(e) },
    },
    'VExpansionPanels'
  ),
  BE = J()({
    name: 'VExpansionPanels',
    props: ME(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { next: a, prev: l } = Aa(e, qo),
        { themeClasses: o } = $e(e),
        i = B(() => e.variant && `v-expansion-panels--variant-${e.variant}`)
      return (
        lt({
          VExpansionPanel: {
            bgColor: B(() => e.bgColor),
            collapseIcon: B(() => e.collapseIcon),
            color: B(() => e.color),
            eager: B(() => e.eager),
            elevation: B(() => e.elevation),
            expandIcon: B(() => e.expandIcon),
            focusable: B(() => e.focusable),
            hideActions: B(() => e.hideActions),
            readonly: B(() => e.readonly),
            ripple: B(() => e.ripple),
            rounded: B(() => e.rounded),
            static: B(() => e.static),
          },
        }),
        ne(() =>
          w(
            e.tag,
            {
              class: ee([
                'v-expansion-panels',
                { 'v-expansion-panels--flat': e.flat, 'v-expansion-panels--tile': e.tile },
                o.value,
                i.value,
                e.class,
              ]),
              style: ce(e.style),
            },
            { default: () => [n.default?.({ prev: l, next: a })] }
          )
        ),
        { next: a, prev: l }
      )
    },
  }),
  LE = $(
    {
      app: Boolean,
      appear: Boolean,
      extended: Boolean,
      layout: Boolean,
      offset: Boolean,
      modelValue: { type: Boolean, default: !0 },
      ...je(jr({ active: !0 }), ['location', 'spaced']),
      ...il(),
      ...fa(),
      ...Vn({ transition: 'fab-transition' }),
    },
    'VFab'
  ),
  OE = J()({
    name: 'VFab',
    props: LE(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = we(e, 'modelValue'),
        l = oe(56),
        o = ae(),
        { resizeRef: i } = hn((d) => {
          d.length && (l.value = d[0].target.clientHeight)
        }),
        r = B(() => e.app || e.absolute),
        s = C(() => (r.value ? (e.location?.split(' ').shift() ?? 'bottom') : !1)),
        c = C(() => (r.value ? (e.location?.split(' ')[1] ?? 'end') : !1))
      Et(
        () => e.app,
        () => {
          const d = rl({
            id: e.name,
            order: C(() => parseInt(e.order, 10)),
            position: s,
            layoutSize: C(() => (e.layout ? l.value + 24 : 0)),
            elementSize: C(() => l.value + 24),
            active: C(() => e.app && a.value),
            absolute: B(() => e.absolute),
          })
          qe(() => {
            o.value = d.layoutItemStyles.value
          })
        }
      )
      const u = ae()
      return (
        ne(() => {
          const d = Me.filterProps(e)
          return x(
            'div',
            {
              ref: u,
              class: ee([
                'v-fab',
                {
                  'v-fab--absolute': e.absolute,
                  'v-fab--app': !!e.app,
                  'v-fab--extended': e.extended,
                  'v-fab--offset': e.offset,
                  [`v-fab--${s.value}`]: r.value,
                  [`v-fab--${c.value}`]: r.value,
                },
                e.class,
              ]),
              style: ce([
                e.app ? { ...o.value } : { height: e.absolute ? '100%' : 'inherit' },
                e.style,
              ]),
            },
            [
              x('div', { class: 'v-fab__container' }, [
                w(
                  $t,
                  { appear: e.appear, transition: e.transition },
                  {
                    default: () => [
                      tt(w(Me, Z({ ref: i }, d, { active: void 0, location: void 0 }), n), [
                        [Pn, e.active],
                      ]),
                    ],
                  }
                ),
              ]),
            ]
          )
        }),
        {}
      )
    },
  })
function $E() {
  function e(n) {
    return (
      [...(n.dataTransfer?.items ?? [])]
        .filter((l) => l.kind === 'file')
        .map((l) => l.webkitGetAsEntry())
        .filter(Boolean).length > 0 || [...(n.dataTransfer?.files ?? [])].length > 0
    )
  }
  async function t(n) {
    const a = [],
      l = [...(n.dataTransfer?.items ?? [])]
        .filter((o) => o.kind === 'file')
        .map((o) => o.webkitGetAsEntry())
        .filter(Boolean)
    if (l.length)
      for (const o of l) {
        const i = await Jp(o, Qp('.', o))
        a.push(...i.map((r) => r.file))
      }
    else a.push(...(n.dataTransfer?.files ?? []))
    return a
  }
  return { handleDrop: t, hasFilesOrFolders: e }
}
function Jp(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ''
  return new Promise((n, a) => {
    e.isFile
      ? e.file((o) => n([{ file: o, path: t }]), a)
      : e.isDirectory &&
        e.createReader().readEntries(async (o) => {
          const i = []
          for (const r of o) i.push(...(await Jp(r, Qp(t, r))))
          n(i)
        })
  })
}
function Qp(e, t) {
  return t.isDirectory ? `${e}/${t.name}` : e
}
const FE = $({ filterByType: String }, 'file-accept')
function NE(e) {
  const t = C(() => (e.filterByType ? HE(e.filterByType) : null))
  function n(a) {
    if (t.value) {
      const l = a.filter(t.value)
      return { accepted: l, rejected: a.filter((o) => !l.includes(o)) }
    }
    return { accepted: a, rejected: [] }
  }
  return { filterAccepted: n }
}
function HE(e) {
  const t = e.split(',').map((o) => o.trim().toLowerCase()),
    n = t.filter((o) => o.startsWith('.')),
    a = t.filter((o) => o.endsWith('/*')),
    l = t.filter((o) => !n.includes(o) && !a.includes(o))
  return (o) => {
    const i = o.name.split('.').at(-1)?.toLowerCase() ?? '',
      r = o.type.split('/').at(0)?.toLowerCase() ?? ''
    return l.includes(o.type) || n.includes(`.${i}`) || a.includes(`${r}/*`)
  }
}
const jE = $(
    {
      chips: Boolean,
      counter: Boolean,
      counterSizeString: { type: String, default: '$vuetify.fileInput.counterSize' },
      counterString: { type: String, default: '$vuetify.fileInput.counter' },
      hideInput: Boolean,
      multiple: Boolean,
      showSize: {
        type: [Boolean, Number, String],
        default: !1,
        validator: (e) => typeof e == 'boolean' || [1e3, 1024].includes(Number(e)),
      },
      truncateLength: { type: [Number, String], default: 22 },
      ...ma({ prependIcon: '$file' }),
      modelValue: {
        type: [Array, Object],
        default: (e) => (e.multiple ? [] : null),
        validator: (e) => nt(e).every((t) => t != null && typeof t == 'object'),
      },
      ...FE(),
      ...fi({ clearable: !0 }),
    },
    'VFileInput'
  ),
  zE = J()({
    name: 'VFileInput',
    inheritAttrs: !1,
    props: jE(),
    emits: {
      'click:control': (e) => !0,
      'mousedown:control': (e) => !0,
      'update:focused': (e) => !0,
      'update:modelValue': (e) => !0,
      rejected: (e) => !0,
    },
    setup(e, t) {
      let { attrs: n, emit: a, slots: l } = t
      const { t: o } = ze(),
        { filterAccepted: i } = NE(e),
        r = we(
          e,
          'modelValue',
          e.modelValue,
          (O) => nt(O),
          (O) => (!e.multiple && Array.isArray(O) ? O[0] : O)
        ),
        { isFocused: s, focus: c, blur: u } = va(e),
        d = C(() => (typeof e.showSize != 'boolean' ? e.showSize : void 0)),
        f = C(() =>
          (r.value ?? []).reduce((O, j) => {
            let { size: U = 0 } = j
            return O + U
          }, 0)
        ),
        v = C(() => Pv(f.value, d.value)),
        g = C(() =>
          (r.value ?? []).map((O) => {
            const { name: j = '', size: U = 0 } = O,
              Y = M(j)
            return e.showSize ? `${Y} (${Pv(U, d.value)})` : Y
          })
        ),
        h = C(() => {
          const O = r.value?.length ?? 0
          return e.showSize ? o(e.counterSizeString, O, v.value) : o(e.counterString, O)
        }),
        m = ae(),
        b = ae(),
        y = ae(),
        p = B(() => s.value || e.active),
        S = C(() => ['plain', 'underlined'].includes(e.variant)),
        k = oe(!1),
        { handleDrop: _, hasFilesOrFolders: P } = $E()
      function A() {
        ;(y.value !== document.activeElement && y.value?.focus(), s.value || c())
      }
      function D(O) {
        y.value?.click()
      }
      function E(O) {
        a('mousedown:control', O)
      }
      function R(O) {
        ;(y.value?.click(), a('click:control', O))
      }
      function V(O) {
        ;(O.stopPropagation(),
          A(),
          Re(() => {
            ;((r.value = []), ti(e['onClick:clear'], O))
          }))
      }
      function M(O) {
        if (O.length < Number(e.truncateLength)) return O
        const j = Math.floor((Number(e.truncateLength) - 1) / 2)
        return `${O.slice(0, j)}…${O.slice(O.length - j)}`
      }
      function F(O) {
        ;(O.preventDefault(), O.stopImmediatePropagation(), (k.value = !0))
      }
      function G(O) {
        ;(O.preventDefault(), (k.value = !1))
      }
      async function W(O) {
        if ((O.preventDefault(), O.stopImmediatePropagation(), (k.value = !1), !y.value || !P(O)))
          return
        const j = await _(O)
        H(j)
      }
      function te(O) {
        if (!(!O.target || O.repack))
          if (e.filterByType) H([...O.target.files])
          else {
            const j = O.target
            r.value = [...(j.files ?? [])]
          }
      }
      function H(O) {
        const j = new DataTransfer(),
          { accepted: U, rejected: Y } = i(O)
        Y.length && a('rejected', Y)
        for (const se of U) j.items.add(se)
        ;((y.value.files = j.files), (r.value = [...j.files]))
        const K = new Event('change', { bubbles: !0 })
        ;((K.repack = !0), y.value.dispatchEvent(K))
      }
      return (
        ue(r, (O) => {
          ;(!Array.isArray(O) || !O.length) && y.value && (y.value.value = '')
        }),
        ne(() => {
          const O = !!(l.counter || e.counter),
            j = !!(O || l.details),
            [U, Y] = Ia(n),
            { modelValue: K, ...se } = Dt.filterProps(e),
            de = { ...Va.filterProps(e), 'onClick:clear': V },
            L =
              n.webkitdirectory !== void 0 && n.webkitdirectory !== !1
                ? void 0
                : (e.filterByType ?? String(n.accept))
          return w(
            Dt,
            Z(
              {
                ref: m,
                modelValue: e.multiple ? r.value : r.value[0],
                class: [
                  'v-file-input',
                  {
                    'v-file-input--chips': !!e.chips,
                    'v-file-input--dragging': k.value,
                    'v-file-input--hide': e.hideInput,
                    'v-input--plain-underlined': S.value,
                  },
                  e.class,
                ],
                style: e.style,
                'onClick:prepend': D,
              },
              U,
              se,
              { centerAffix: !S.value, focused: s.value }
            ),
            {
              ...l,
              default: (q) => {
                let {
                  id: le,
                  isDisabled: ie,
                  isDirty: Ce,
                  isReadonly: pe,
                  isValid: I,
                  hasDetails: T,
                } = q
                return w(
                  Va,
                  Z(
                    {
                      ref: b,
                      prependIcon: e.prependIcon,
                      onMousedown: E,
                      onClick: R,
                      'onClick:prependInner': e['onClick:prependInner'],
                      'onClick:appendInner': e['onClick:appendInner'],
                    },
                    de,
                    {
                      id: le.value,
                      active: p.value || Ce.value,
                      dirty: Ce.value || e.dirty,
                      disabled: ie.value,
                      focused: s.value,
                      details: T.value,
                      error: I.value === !1,
                      onDragover: F,
                      onDrop: W,
                    }
                  ),
                  {
                    ...l,
                    default: (z) => {
                      let {
                        props: { class: X, ...N },
                      } = z
                      return x(he, null, [
                        x(
                          'input',
                          Z(
                            {
                              ref: y,
                              type: 'file',
                              accept: L,
                              readonly: pe.value,
                              disabled: ie.value,
                              multiple: e.multiple,
                              name: e.name,
                              onClick: (Q) => {
                                ;(Q.stopPropagation(), pe.value && Q.preventDefault(), A())
                              },
                              onChange: te,
                              onDragleave: G,
                              onFocus: A,
                              onBlur: u,
                            },
                            N,
                            Y
                          ),
                          null
                        ),
                        x('div', { class: ee(X) }, [
                          !!r.value?.length &&
                            !e.hideInput &&
                            (l.selection
                              ? l.selection({
                                  fileNames: g.value,
                                  totalBytes: f.value,
                                  totalBytesReadable: v.value,
                                })
                              : e.chips
                                ? g.value.map((Q) =>
                                    w(no, { key: Q, size: 'small', text: Q }, null)
                                  )
                                : g.value.join(', ')),
                        ]),
                      ])
                    },
                  }
                )
              },
              details: j
                ? (q) =>
                    x(he, null, [
                      l.details?.(q),
                      O &&
                        x(he, null, [
                          x('span', null, null),
                          w(
                            Wr,
                            { active: !!r.value?.length, value: h.value, disabled: e.disabled },
                            l.counter
                          ),
                        ]),
                    ])
                : void 0,
            }
          )
        }),
        _t({}, m, b, y)
      )
    },
  }),
  WE = $(
    {
      app: Boolean,
      color: String,
      height: { type: [Number, String], default: 'auto' },
      ...Ut(),
      ...be(),
      ...yt(),
      ...il(),
      ...Je(),
      ...Ie({ tag: 'footer' }),
      ...Be(),
    },
    'VFooter'
  ),
  UE = J()({
    name: 'VFooter',
    props: WE(),
    setup(e, t) {
      let { slots: n } = t
      const a = ae(),
        { themeClasses: l } = $e(e),
        { backgroundColorClasses: o, backgroundColorStyles: i } = He(() => e.color),
        { borderClasses: r } = Jt(e),
        { elevationClasses: s } = xt(e),
        { roundedClasses: c } = ot(e),
        u = oe(32),
        { resizeRef: d } = hn((v) => {
          v.length && (u.value = v[0].target.clientHeight)
        }),
        f = C(() => (e.height === 'auto' ? u.value : parseInt(e.height, 10)))
      return (
        Et(
          () => e.app,
          () => {
            const v = rl({
              id: e.name,
              order: C(() => parseInt(e.order, 10)),
              position: B(() => 'bottom'),
              layoutSize: f,
              elementSize: C(() => (e.height === 'auto' ? void 0 : f.value)),
              active: B(() => e.app),
              absolute: B(() => e.absolute),
            })
            qe(() => {
              a.value = v.layoutItemStyles.value
            })
          }
        ),
        ne(() =>
          w(
            e.tag,
            {
              ref: d,
              class: ee(['v-footer', l.value, o.value, r.value, s.value, c.value, e.class]),
              style: ce([i.value, e.app ? a.value : { height: fe(e.height) }, e.style]),
            },
            n
          )
        ),
        {}
      )
    },
  }),
  KE = $({ ...be(), ...lI() }, 'VForm'),
  GE = J()({
    name: 'VForm',
    props: KE(),
    emits: { 'update:modelValue': (e) => !0, submit: (e) => !0 },
    setup(e, t) {
      let { slots: n, emit: a } = t
      const l = oI(e),
        o = ae()
      function i(s) {
        ;(s.preventDefault(), l.reset())
      }
      function r(s) {
        const c = s,
          u = l.validate()
        ;((c.then = u.then.bind(u)),
          (c.catch = u.catch.bind(u)),
          (c.finally = u.finally.bind(u)),
          a('submit', c),
          c.defaultPrevented ||
            u.then((d) => {
              let { valid: f } = d
              f && o.value?.submit()
            }),
          c.preventDefault())
      }
      return (
        ne(() =>
          x(
            'form',
            {
              ref: o,
              class: ee(['v-form', e.class]),
              style: ce(e.style),
              novalidate: !0,
              onReset: i,
              onSubmit: r,
            },
            [n.default?.(l)]
          )
        ),
        _t(l, o)
      )
    },
  }),
  YE = $({ disabled: Boolean, modelValue: { type: Boolean, default: null }, ...pd() }, 'VHover'),
  qE = J()({
    name: 'VHover',
    props: YE(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = we(e, 'modelValue'),
        { runOpenDelay: l, runCloseDelay: o } = Sd(e, (i) => !e.disabled && (a.value = i))
      return () => n.default?.({ isHovering: a.value, props: { onMouseenter: l, onMouseleave: o } })
    },
  }),
  XE = $(
    {
      color: String,
      direction: {
        type: String,
        default: 'vertical',
        validator: (e) => ['vertical', 'horizontal'].includes(e),
      },
      side: {
        type: String,
        default: 'end',
        validator: (e) => ['start', 'end', 'both'].includes(e),
      },
      mode: {
        type: String,
        default: 'intersect',
        validator: (e) => ['intersect', 'manual'].includes(e),
      },
      margin: [Number, String],
      loadMoreText: { type: String, default: '$vuetify.infiniteScroll.loadMore' },
      emptyText: { type: String, default: '$vuetify.infiniteScroll.empty' },
      ...ft(),
      ...Ie(),
    },
    'VInfiniteScroll'
  ),
  ym = un({
    name: 'VInfiniteScrollIntersect',
    props: { side: { type: String, required: !0 }, rootMargin: String },
    emits: { intersect: (e, t) => !0 },
    setup(e, t) {
      let { emit: n } = t
      const { intersectionRef: a, isIntersecting: l } = oi()
      return (
        ue(l, async (o) => {
          n('intersect', e.side, o)
        }),
        ne(() =>
          x(
            'div',
            {
              class: 'v-infinite-scroll-intersect',
              style: { '--v-infinite-margin-size': e.rootMargin },
              ref: a,
            },
            [qt(' ')]
          )
        ),
        {}
      )
    },
  }),
  ZE = J()({
    name: 'VInfiniteScroll',
    props: XE(),
    emits: { load: (e) => !0 },
    setup(e, t) {
      let { slots: n, emit: a } = t
      const l = ae(),
        o = oe('ok'),
        i = oe('ok'),
        r = C(() => fe(e.margin)),
        s = oe(!1)
      function c(_) {
        if (!l.value) return
        const P = e.direction === 'vertical' ? 'scrollTop' : 'scrollLeft'
        l.value[P] = _
      }
      function u() {
        if (!l.value) return 0
        const _ = e.direction === 'vertical' ? 'scrollTop' : 'scrollLeft'
        return l.value[_]
      }
      function d() {
        if (!l.value) return 0
        const _ = e.direction === 'vertical' ? 'scrollHeight' : 'scrollWidth'
        return l.value[_]
      }
      function f() {
        if (!l.value) return 0
        const _ = e.direction === 'vertical' ? 'clientHeight' : 'clientWidth'
        return l.value[_]
      }
      pt(() => {
        l.value && (e.side === 'start' ? c(d()) : e.side === 'both' && c(d() / 2 - f() / 2))
      })
      function v(_, P) {
        _ === 'start'
          ? (o.value = P)
          : _ === 'end'
            ? (i.value = P)
            : _ === 'both' && ((o.value = P), (i.value = P))
      }
      function g(_) {
        return _ === 'start' ? o.value : i.value
      }
      let h = 0
      function m(_, P) {
        ;((s.value = P), s.value && b(_))
      }
      function b(_) {
        if (e.mode !== 'manual' && !s.value) return
        const P = g(_)
        if (!l.value || ['empty', 'loading'].includes(P)) return
        ;((h = d()), v(_, 'loading'))
        function A(D) {
          ;(v(_, D),
            Re(() => {
              D === 'empty' ||
                D === 'error' ||
                (D === 'ok' && _ === 'start' && c(d() - h + u()),
                e.mode !== 'manual' &&
                  Re(() => {
                    window.requestAnimationFrame(() => {
                      window.requestAnimationFrame(() => {
                        window.requestAnimationFrame(() => {
                          b(_)
                        })
                      })
                    })
                  }))
            }))
        }
        a('load', { side: _, done: A })
      }
      const { t: y } = ze()
      function p(_, P) {
        if (e.side !== _ && e.side !== 'both') return
        const A = () => b(_),
          D = { side: _, props: { onClick: A, color: e.color } }
        return P === 'error'
          ? n.error?.(D)
          : P === 'empty'
            ? (n.empty?.(D) ?? x('div', null, [y(e.emptyText)]))
            : e.mode === 'manual'
              ? P === 'loading'
                ? (n.loading?.(D) ?? w(Ja, { indeterminate: !0, color: e.color }, null))
                : (n['load-more']?.(D) ??
                  w(
                    Me,
                    { variant: 'outlined', color: e.color, onClick: A },
                    { default: () => [y(e.loadMoreText)] }
                  ))
              : (n.loading?.(D) ?? w(Ja, { indeterminate: !0, color: e.color }, null))
      }
      const { dimensionStyles: S } = vt(e)
      ne(() => {
        const _ = e.tag,
          P = e.side === 'start' || e.side === 'both',
          A = e.side === 'end' || e.side === 'both',
          D = e.mode === 'intersect'
        return w(
          _,
          {
            ref: l,
            class: ee([
              'v-infinite-scroll',
              `v-infinite-scroll--${e.direction}`,
              { 'v-infinite-scroll--start': P, 'v-infinite-scroll--end': A },
            ]),
            style: ce(S.value),
          },
          {
            default: () => [
              x('div', { class: 'v-infinite-scroll__side' }, [p('start', o.value)]),
              P &&
                D &&
                w(ym, { key: 'start', side: 'start', onIntersect: m, rootMargin: r.value }, null),
              n.default?.(),
              A &&
                D &&
                w(ym, { key: 'end', side: 'end', onIntersect: m, rootMargin: r.value }, null),
              x('div', { class: 'v-infinite-scroll__side' }, [p('end', i.value)]),
            ],
          }
        )
      })
      function k(_) {
        const P = _ ?? e.side
        ;(v(P, 'ok'),
          Re(() => {
            ;(c(d() - h + u()),
              e.mode !== 'manual' &&
                Re(() => {
                  window.requestAnimationFrame(() => {
                    window.requestAnimationFrame(() => {
                      window.requestAnimationFrame(() => {
                        P === 'both' ? (b('start'), b('end')) : b(P)
                      })
                    })
                  })
                }))
          }))
      }
      return { reset: k }
    },
  }),
  eS = Symbol.for('vuetify:v-item-group'),
  JE = $({ ...be(), ...cl({ selectedClass: 'v-item--selected' }), ...Ie(), ...Be() }, 'VItemGroup'),
  QE = J()({
    name: 'VItemGroup',
    props: JE(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: a } = $e(e),
        { isSelected: l, select: o, next: i, prev: r, selected: s } = Aa(e, eS)
      return () =>
        w(
          e.tag,
          { class: ee(['v-item-group', a.value, e.class]), style: ce(e.style) },
          {
            default: () => [
              n.default?.({ isSelected: l, select: o, next: i, prev: r, selected: s.value }),
            ],
          }
        )
    },
  }),
  eD = J()({
    name: 'VItem',
    props: dl(),
    emits: { 'group:selected': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const {
        isSelected: a,
        select: l,
        toggle: o,
        selectedClass: i,
        value: r,
        disabled: s,
      } = fl(e, eS)
      return () =>
        n.default?.({
          isSelected: a.value,
          selectedClass: i.value,
          select: l,
          toggle: o,
          value: r.value,
          disabled: s.value,
        })
    },
  }),
  tD = $(
    { color: String, ...Ut(), ...be(), ...Je(), ...Ie({ tag: 'kbd' }), ...Be(), ...yt() },
    'VKbd'
  ),
  nD = J()({
    name: 'VKbd',
    props: tD(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: a } = $e(e),
        { borderClasses: l } = Jt(e),
        { roundedClasses: o } = ot(e),
        { backgroundColorClasses: i, backgroundColorStyles: r } = He(() => e.color),
        { elevationClasses: s } = xt(e)
      return (
        ne(() =>
          w(
            e.tag,
            {
              class: ee(['v-kbd', a.value, i.value, l.value, s.value, o.value, e.class]),
              style: ce([r.value, e.style]),
            },
            n
          )
        ),
        {}
      )
    },
  }),
  aD = $({ ...be(), ...ft(), ...Iy() }, 'VLayout'),
  lD = J()({
    name: 'VLayout',
    props: aD(),
    setup(e, t) {
      let { slots: n } = t
      const { layoutClasses: a, layoutStyles: l, getLayoutItem: o, items: i, layoutRef: r } = Ay(e),
        { dimensionStyles: s } = vt(e)
      return (
        ne(() =>
          x(
            'div',
            { ref: r, class: ee([a.value, e.class]), style: ce([s.value, l.value, e.style]) },
            [n.default?.()]
          )
        ),
        { getLayoutItem: o, items: i }
      )
    },
  }),
  oD = $(
    {
      position: { type: String, required: !0 },
      size: { type: [Number, String], default: 300 },
      modelValue: Boolean,
      ...be(),
      ...il(),
    },
    'VLayoutItem'
  ),
  iD = J()({
    name: 'VLayoutItem',
    props: oD(),
    setup(e, t) {
      let { slots: n } = t
      const { layoutItemStyles: a } = rl({
        id: e.name,
        order: C(() => parseInt(e.order, 10)),
        position: B(() => e.position),
        elementSize: B(() => e.size),
        layoutSize: B(() => e.size),
        active: B(() => e.modelValue),
        absolute: B(() => e.absolute),
      })
      return () =>
        x('div', { class: ee(['v-layout-item', e.class]), style: ce([a.value, e.style]) }, [
          n.default?.(),
        ])
    },
  }),
  rD = $(
    {
      modelValue: Boolean,
      options: {
        type: Object,
        default: () => ({ root: void 0, rootMargin: void 0, threshold: void 0 }),
      },
      ...be(),
      ...ft(),
      ...Ie(),
      ...Vn({ transition: 'fade-transition' }),
    },
    'VLazy'
  ),
  sD = J()({
    name: 'VLazy',
    directives: { vIntersect: xn },
    props: rD(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { dimensionStyles: a } = vt(e),
        l = we(e, 'modelValue')
      function o(i) {
        l.value || (l.value = i)
      }
      return (
        ne(() =>
          tt(
            w(
              e.tag,
              { class: ee(['v-lazy', e.class]), style: ce([a.value, e.style]) },
              {
                default: () => [
                  l.value &&
                    w(
                      $t,
                      { transition: e.transition, appear: !0 },
                      { default: () => [n.default?.()] }
                    ),
                ],
              }
            ),
            [[xn, { handler: o, options: e.options }, null]]
          )
        ),
        {}
      )
    },
  }),
  uD = $(
    {
      locale: String,
      fallbackLocale: String,
      messages: Object,
      rtl: { type: Boolean, default: void 0 },
      ...be(),
    },
    'VLocaleProvider'
  ),
  cD = J()({
    name: 'VLocaleProvider',
    props: uD(),
    setup(e, t) {
      let { slots: n } = t
      const { rtlClasses: a } = K1(e)
      return (
        ne(() =>
          x('div', { class: ee(['v-locale-provider', a.value, e.class]), style: ce(e.style) }, [
            n.default?.(),
          ])
        ),
        {}
      )
    },
  }),
  dD = $({ scrollable: Boolean, ...be(), ...ft(), ...Ie({ tag: 'main' }) }, 'VMain'),
  Ud = J()({
    name: 'VMain',
    props: dD(),
    setup(e, t) {
      let { slots: n } = t
      const { dimensionStyles: a } = vt(e),
        { mainStyles: l } = Ty(),
        { ssrBootStyles: o } = sl()
      return (
        ne(() =>
          w(
            e.tag,
            {
              class: ee(['v-main', { 'v-main--scrollable': e.scrollable }, e.class]),
              style: ce([l.value, o.value, a.value, e.style]),
            },
            {
              default: () => [
                e.scrollable
                  ? x('div', { class: 'v-main__scroller' }, [n.default?.()])
                  : n.default?.(),
              ],
            }
          )
        ),
        {}
      )
    },
  })
function fD(e) {
  let { rootEl: t, isSticky: n, layoutItemStyles: a } = e
  const l = oe(!1),
    o = oe(0),
    i = C(() => {
      const c = typeof l.value == 'boolean' ? 'top' : l.value
      return [
        n.value ? { top: 'auto', bottom: 'auto', height: void 0 } : void 0,
        l.value ? { [c]: fe(o.value) } : { top: a.value.top },
      ]
    })
  ;(pt(() => {
    ue(
      n,
      (c) => {
        c
          ? window.addEventListener('scroll', s, { passive: !0 })
          : window.removeEventListener('scroll', s)
      },
      { immediate: !0 }
    )
  }),
    dt(() => {
      window.removeEventListener('scroll', s)
    }))
  let r = 0
  function s() {
    const c = r > window.scrollY ? 'up' : 'down',
      u = t.value.getBoundingClientRect(),
      d = parseFloat(a.value.top ?? 0),
      f = window.scrollY - Math.max(0, o.value - d),
      v = u.height + Math.max(o.value, d) - window.scrollY - window.innerHeight,
      g = parseFloat(getComputedStyle(t.value).getPropertyValue('--v-body-scroll-y')) || 0
    ;(u.height < window.innerHeight - d
      ? ((l.value = 'top'), (o.value = d))
      : (c === 'up' && l.value === 'bottom') || (c === 'down' && l.value === 'top')
        ? ((o.value = window.scrollY + u.top - g), (l.value = !0))
        : c === 'down' && v <= 0
          ? ((o.value = 0), (l.value = 'bottom'))
          : c === 'up' &&
            f <= 0 &&
            (g
              ? l.value !== 'top' && ((o.value = -f + g + d), (l.value = 'top'))
              : ((o.value = u.top + f), (l.value = 'top'))),
      (r = window.scrollY))
  }
  return { isStuck: l, stickyStyles: i }
}
const vD = 100,
  mD = 20
function bm(e) {
  return (e < 0 ? -1 : 1) * Math.sqrt(Math.abs(e)) * 1.41421356237
}
function pm(e) {
  if (e.length < 2) return 0
  if (e.length === 2) return e[1].t === e[0].t ? 0 : (e[1].d - e[0].d) / (e[1].t - e[0].t)
  let t = 0
  for (let n = e.length - 1; n > 0; n--) {
    if (e[n].t === e[n - 1].t) continue
    const a = bm(t),
      l = (e[n].d - e[n - 1].d) / (e[n].t - e[n - 1].t)
    ;((t += (l - a) * Math.abs(l)), n === e.length - 1 && (t *= 0.5))
  }
  return bm(t) * 1e3
}
function hD() {
  const e = {}
  function t(l) {
    Array.from(l.changedTouches).forEach((o) => {
      ;(e[o.identifier] ?? (e[o.identifier] = new ey(mD))).push([l.timeStamp, o])
    })
  }
  function n(l) {
    Array.from(l.changedTouches).forEach((o) => {
      delete e[o.identifier]
    })
  }
  function a(l) {
    const o = e[l]?.values().reverse()
    if (!o) throw new Error(`No samples for touch id ${l}`)
    const i = o[0],
      r = [],
      s = []
    for (const c of o) {
      if (i[0] - c[0] > vD) break
      ;(r.push({ t: c[0], d: c[1].clientX }), s.push({ t: c[0], d: c[1].clientY }))
    }
    return {
      x: pm(r),
      y: pm(s),
      get direction() {
        const { x: c, y: u } = this,
          [d, f] = [Math.abs(c), Math.abs(u)]
        return d > f && c >= 0
          ? 'right'
          : d > f && c <= 0
            ? 'left'
            : f > d && u >= 0
              ? 'down'
              : f > d && u <= 0
                ? 'up'
                : gD()
      },
    }
  }
  return { addMovement: t, endTouch: n, getVelocity: a }
}
function gD() {
  throw new Error()
}
function yD(e) {
  let { el: t, isActive: n, isTemporary: a, width: l, touchless: o, position: i } = e
  ;(pt(() => {
    ;(window.addEventListener('touchstart', y, { passive: !0 }),
      window.addEventListener('touchmove', p, { passive: !1 }),
      window.addEventListener('touchend', S, { passive: !0 }))
  }),
    dt(() => {
      ;(window.removeEventListener('touchstart', y),
        window.removeEventListener('touchmove', p),
        window.removeEventListener('touchend', S))
    }))
  const r = C(() => ['left', 'right'].includes(i.value)),
    { addMovement: s, endTouch: c, getVelocity: u } = hD()
  let d = !1
  const f = oe(!1),
    v = oe(0),
    g = oe(0)
  let h
  function m(_, P) {
    return (
      (i.value === 'left'
        ? _
        : i.value === 'right'
          ? document.documentElement.clientWidth - _
          : i.value === 'top'
            ? _
            : i.value === 'bottom'
              ? document.documentElement.clientHeight - _
              : Sl()) - (P ? l.value : 0)
    )
  }
  function b(_) {
    let P = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
    const A =
      i.value === 'left'
        ? (_ - g.value) / l.value
        : i.value === 'right'
          ? (document.documentElement.clientWidth - _ - g.value) / l.value
          : i.value === 'top'
            ? (_ - g.value) / l.value
            : i.value === 'bottom'
              ? (document.documentElement.clientHeight - _ - g.value) / l.value
              : Sl()
    return P ? Ge(A) : A
  }
  function y(_) {
    if (o.value) return
    const P = _.changedTouches[0].clientX,
      A = _.changedTouches[0].clientY,
      D = 25,
      E =
        i.value === 'left'
          ? P < D
          : i.value === 'right'
            ? P > document.documentElement.clientWidth - D
            : i.value === 'top'
              ? A < D
              : i.value === 'bottom'
                ? A > document.documentElement.clientHeight - D
                : Sl(),
      R =
        n.value &&
        (i.value === 'left'
          ? P < l.value
          : i.value === 'right'
            ? P > document.documentElement.clientWidth - l.value
            : i.value === 'top'
              ? A < l.value
              : i.value === 'bottom'
                ? A > document.documentElement.clientHeight - l.value
                : Sl())
    ;(E || R || (n.value && a.value)) &&
      ((h = [P, A]),
      (g.value = m(r.value ? P : A, n.value)),
      (v.value = b(r.value ? P : A)),
      (d = g.value > -20 && g.value < 80),
      c(_),
      s(_))
  }
  function p(_) {
    const P = _.changedTouches[0].clientX,
      A = _.changedTouches[0].clientY
    if (d) {
      if (!_.cancelable) {
        d = !1
        return
      }
      const E = Math.abs(P - h[0]),
        R = Math.abs(A - h[1])
      ;(r.value ? E > R && E > 3 : R > E && R > 3)
        ? ((f.value = !0), (d = !1))
        : (r.value ? R : E) > 3 && (d = !1)
    }
    if (!f.value) return
    ;(_.preventDefault(), s(_))
    const D = b(r.value ? P : A, !1)
    ;((v.value = Math.max(0, Math.min(1, D))),
      D > 1 ? (g.value = m(r.value ? P : A, !0)) : D < 0 && (g.value = m(r.value ? P : A, !1)))
  }
  function S(_) {
    if (((d = !1), !f.value)) return
    ;(s(_), (f.value = !1))
    const P = u(_.changedTouches[0].identifier),
      A = Math.abs(P.x),
      D = Math.abs(P.y)
    ;(r.value ? A > D && A > 400 : D > A && D > 3)
      ? (n.value =
          P.direction ===
          ({ left: 'right', right: 'left', top: 'down', bottom: 'up' }[i.value] || Sl()))
      : (n.value = v.value > 0.5)
  }
  const k = C(() =>
    f.value
      ? {
          transform:
            i.value === 'left'
              ? `translateX(calc(-100% + ${v.value * l.value}px))`
              : i.value === 'right'
                ? `translateX(calc(100% - ${v.value * l.value}px))`
                : i.value === 'top'
                  ? `translateY(calc(-100% + ${v.value * l.value}px))`
                  : i.value === 'bottom'
                    ? `translateY(calc(100% - ${v.value * l.value}px))`
                    : Sl(),
          transition: 'none',
        }
      : void 0
  )
  return (
    Et(f, () => {
      const _ = t.value?.style.transform ?? null,
        P = t.value?.style.transition ?? null
      ;(qe(() => {
        ;(t.value?.style.setProperty('transform', k.value?.transform || 'none'),
          t.value?.style.setProperty('transition', k.value?.transition || null))
      }),
        bt(() => {
          ;(t.value?.style.setProperty('transform', _), t.value?.style.setProperty('transition', P))
        }))
    }),
    { isDragging: f, dragProgress: v, dragStyles: k }
  )
}
function Sl() {
  throw new Error()
}
const bD = ['start', 'end', 'left', 'right', 'top', 'bottom'],
  pD = $(
    {
      color: String,
      disableResizeWatcher: Boolean,
      disableRouteWatcher: Boolean,
      expandOnHover: Boolean,
      floating: Boolean,
      modelValue: { type: Boolean, default: null },
      permanent: Boolean,
      rail: { type: Boolean, default: null },
      railWidth: { type: [Number, String], default: 56 },
      scrim: { type: [Boolean, String], default: !0 },
      image: String,
      temporary: Boolean,
      persistent: Boolean,
      touchless: Boolean,
      width: { type: [Number, String], default: 256 },
      location: { type: String, default: 'start', validator: (e) => bD.includes(e) },
      sticky: Boolean,
      ...Ut(),
      ...be(),
      ...pd(),
      ...ol({ mobile: null }),
      ...yt(),
      ...il(),
      ...Je(),
      ...Ie({ tag: 'nav' }),
      ...Be(),
    },
    'VNavigationDrawer'
  ),
  SD = J()({
    name: 'VNavigationDrawer',
    props: pD(),
    emits: { 'update:modelValue': (e) => !0, 'update:rail': (e) => !0 },
    setup(e, t) {
      let { attrs: n, emit: a, slots: l } = t
      const { isRtl: o } = gt(),
        { themeClasses: i } = $e(e),
        { borderClasses: r } = Jt(e),
        { backgroundColorClasses: s, backgroundColorStyles: c } = He(() => e.color),
        { elevationClasses: u } = xt(e),
        { displayClasses: d, mobile: f } = gn(e),
        { roundedClasses: v } = ot(e),
        g = Hy(),
        h = we(e, 'modelValue', null, (j) => !!j),
        { ssrBootStyles: m } = sl(),
        { scopeId: b } = ml(),
        y = ae(),
        p = oe(!1),
        { runOpenDelay: S, runCloseDelay: k } = Sd(e, (j) => {
          p.value = j
        }),
        _ = C(() =>
          e.rail && e.expandOnHover && p.value
            ? Number(e.width)
            : Number(e.rail ? e.railWidth : e.width)
        ),
        P = C(() => xu(e.location, o.value)),
        A = B(() => e.persistent),
        D = C(() => !e.permanent && (f.value || e.temporary)),
        E = C(() => e.sticky && !D.value && P.value !== 'bottom')
      ;(Et(
        () => e.expandOnHover && e.rail != null,
        () => {
          ue(p, (j) => a('update:rail', !j))
        }
      ),
        Et(
          () => !e.disableResizeWatcher,
          () => {
            ue(D, (j) => !e.permanent && Re(() => (h.value = !j)))
          }
        ),
        Et(
          () => !e.disableRouteWatcher && !!g,
          () => {
            ue(g.currentRoute, () => D.value && (h.value = !1))
          }
        ),
        ue(
          () => e.permanent,
          (j) => {
            j && (h.value = !0)
          }
        ),
        e.modelValue == null && !D.value && (h.value = e.permanent || !f.value))
      const { isDragging: R, dragProgress: V } = yD({
          el: y,
          isActive: h,
          isTemporary: D,
          width: _,
          touchless: B(() => e.touchless),
          position: P,
        }),
        M = C(() => {
          const j = D.value ? 0 : e.rail && e.expandOnHover ? Number(e.railWidth) : _.value
          return R.value ? j * V.value : j
        }),
        { layoutItemStyles: F, layoutItemScrimStyles: G } = rl({
          id: e.name,
          order: C(() => parseInt(e.order, 10)),
          position: P,
          layoutSize: M,
          elementSize: _,
          active: qa(h),
          disableTransitions: B(() => R.value),
          absolute: C(() => e.absolute || (E.value && typeof W.value != 'string')),
        }),
        { isStuck: W, stickyStyles: te } = fD({ rootEl: y, isSticky: E, layoutItemStyles: F }),
        H = He(() => (typeof e.scrim == 'string' ? e.scrim : null)),
        O = C(() => ({
          ...(R.value ? { opacity: V.value * 0.2, transition: 'none' } : void 0),
          ...G.value,
        }))
      return (
        lt({ VList: { bgColor: 'transparent' } }),
        ne(() => {
          const j = l.image || e.image
          return x(he, null, [
            w(
              e.tag,
              Z(
                {
                  ref: y,
                  onMouseenter: S,
                  onMouseleave: k,
                  class: [
                    'v-navigation-drawer',
                    `v-navigation-drawer--${P.value}`,
                    {
                      'v-navigation-drawer--expand-on-hover': e.expandOnHover,
                      'v-navigation-drawer--floating': e.floating,
                      'v-navigation-drawer--is-hovering': p.value,
                      'v-navigation-drawer--rail': e.rail,
                      'v-navigation-drawer--temporary': D.value,
                      'v-navigation-drawer--persistent': A.value,
                      'v-navigation-drawer--active': h.value,
                      'v-navigation-drawer--sticky': E.value,
                    },
                    i.value,
                    s.value,
                    r.value,
                    d.value,
                    u.value,
                    v.value,
                    e.class,
                  ],
                  style: [c.value, F.value, m.value, te.value, e.style],
                },
                b,
                n
              ),
              {
                default: () => [
                  j &&
                    x('div', { key: 'image', class: 'v-navigation-drawer__img' }, [
                      l.image
                        ? w(
                            Ae,
                            {
                              key: 'image-defaults',
                              disabled: !e.image,
                              defaults: {
                                VImg: { alt: '', cover: !0, height: 'inherit', src: e.image },
                              },
                            },
                            l.image
                          )
                        : w(
                            oa,
                            {
                              key: 'image-img',
                              alt: '',
                              cover: !0,
                              height: 'inherit',
                              src: e.image,
                            },
                            null
                          ),
                    ]),
                  l.prepend && x('div', { class: 'v-navigation-drawer__prepend' }, [l.prepend?.()]),
                  x('div', { class: 'v-navigation-drawer__content' }, [l.default?.()]),
                  l.append && x('div', { class: 'v-navigation-drawer__append' }, [l.append?.()]),
                ],
              }
            ),
            w(
              la,
              { name: 'fade-transition' },
              {
                default: () => [
                  D.value &&
                    (R.value || h.value) &&
                    !!e.scrim &&
                    x(
                      'div',
                      Z(
                        {
                          class: ['v-navigation-drawer__scrim', H.backgroundColorClasses.value],
                          style: [O.value, H.backgroundColorStyles.value],
                          onClick: () => {
                            A.value || (h.value = !1)
                          },
                        },
                        b
                      ),
                      null
                    ),
                ],
              }
            ),
          ])
        }),
        { isStuck: W }
      )
    },
  }),
  wD = un({
    name: 'VNoSsr',
    setup(e, t) {
      let { slots: n } = t
      const a = Ab()
      return () => a.value && n.default?.()
    },
  }),
  kD = 50,
  CD = 500
function xD(e) {
  let { toggleUpDown: t } = e,
    n = -1,
    a = -1
  bt(o)
  function l(r) {
    ;(o(),
      i(r),
      window.addEventListener('pointerup', o),
      document.addEventListener('blur', o),
      (n = window.setTimeout(() => {
        a = window.setInterval(() => i(r), kD)
      }, CD)))
  }
  function o() {
    ;(window.clearTimeout(n),
      window.clearInterval(a),
      window.removeEventListener('pointerup', o),
      document.removeEventListener('blur', o))
  }
  function i(r) {
    t(r === 'up')
  }
  return { holdStart: l, holdStop: o }
}
const _D = $(
    {
      controlVariant: { type: String, default: 'default' },
      inset: Boolean,
      hideInput: Boolean,
      modelValue: { type: Number, default: null },
      min: { type: Number, default: Number.MIN_SAFE_INTEGER },
      max: { type: Number, default: Number.MAX_SAFE_INTEGER },
      step: { type: Number, default: 1 },
      precision: { type: Number, default: 0 },
      minFractionDigits: { type: Number, default: null },
      decimalSeparator: { type: String, validator: (e) => !e || e.length === 1 },
      ...je(vi(), ['modelValue', 'validationValue']),
    },
    'VNumberInput'
  ),
  PD = J()({
    name: 'VNumberInput',
    props: { ..._D() },
    emits: { 'update:focused': (e) => !0, 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = ae(),
        { holdStart: l, holdStop: o } = xD({ toggleUpDown: D }),
        i = to(e),
        r = C(() => i.isDisabled.value || i.isReadonly.value),
        s = oe(e.focused),
        { decimalSeparator: c } = ze(),
        u = C(() => e.decimalSeparator?.[0] || c.value)
      function d(U) {
        let Y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.precision,
          K = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0
        const se = Y == null ? String(U) : U.toFixed(Y)
        if (s.value && K) return Number(se).toString().replace('.', u.value)
        if (e.minFractionDigits === null || (Y !== null && Y < e.minFractionDigits))
          return se.replace('.', u.value)
        let [de, ye] = se.split('.')
        return (
          (ye = (ye ?? '')
            .padEnd(e.minFractionDigits, '0')
            .replace(new RegExp(`(?<=\\d{${e.minFractionDigits}})0+$`, 'g'), '')),
          [de, ye].filter(Boolean).join(u.value)
        )
      }
      const f = we(
          e,
          'modelValue',
          null,
          (U) => U ?? null,
          (U) => (U == null ? (U ?? null) : Ge(Number(U), e.min, e.max))
        ),
        v = oe(null)
      qe(() => {
        ;(s.value && !r.value && Number(v.value) === f.value) ||
          (f.value == null ? (v.value = null) : isNaN(f.value) || (v.value = d(f.value)))
      })
      const g = C({
          get: () => v.value,
          set(U) {
            if (U === null || U === '') {
              ;((f.value = null), (v.value = null))
              return
            }
            const Y = Number(U.replace(u.value, '.'))
            !isNaN(Y) && Y <= e.max && Y >= e.min && ((f.value = Y), (v.value = U))
          },
        }),
        h = C(() => (r.value ? !1 : (f.value ?? 0) + e.step <= e.max)),
        m = C(() => (r.value ? !1 : (f.value ?? 0) - e.step >= e.min)),
        b = C(() => (e.hideInput ? 'stacked' : e.controlVariant)),
        y = B(() => (b.value === 'split' ? '$plus' : '$collapse')),
        p = B(() => (b.value === 'split' ? '$minus' : '$expand')),
        S = B(() => (b.value === 'split' ? 'default' : 'small')),
        k = B(() => (b.value === 'stacked' ? 'auto' : '100%')),
        _ = { props: { onClick: V, onPointerup: M, onPointerdown: F, onPointercancel: M } },
        P = { props: { onClick: V, onPointerup: M, onPointerdown: G, onPointercancel: M } }
      ;(ue(
        () => e.precision,
        () => te()
      ),
        ue(
          () => e.minFractionDigits,
          () => te()
        ),
        pt(() => {
          W()
        }))
      function A(U) {
        if (U == null) return 0
        const Y = U.toString(),
          K = Y.indexOf('.')
        return ~K ? Y.length - K : 0
      }
      function D() {
        let U = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0
        if (r.value) return
        if (f.value == null) {
          g.value = d(Ge(0, e.min, e.max))
          return
        }
        let Y = Math.max(A(f.value), A(e.step))
        ;(e.precision != null && (Y = Math.max(Y, e.precision)),
          U
            ? h.value && (g.value = d(f.value + e.step, Y))
            : m.value && (g.value = d(f.value - e.step, Y)))
      }
      function E(U) {
        if (!U.data) return
        const Y = U.target,
          { value: K, selectionStart: se, selectionEnd: de } = Y ?? {},
          ye = K ? K.slice(0, se) + U.data + K.slice(de) : U.data,
          L = i1(ye, e.precision, u.value)
        if (
          (new RegExp(`^-?\\d*${ur(u.value)}?\\d*$`).test(ye) ||
            (U.preventDefault(), (Y.value = L)),
          e.precision != null)
        ) {
          if (ye.split(u.value)[1]?.length > e.precision) {
            ;(U.preventDefault(), (Y.value = L))
            const q = (se ?? 0) + U.data.length
            Y.setSelectionRange(q, q)
          }
          e.precision === 0 && ye.includes(u.value) && (U.preventDefault(), (Y.value = L))
        }
      }
      async function R(U) {
        ;['Enter', 'ArrowLeft', 'ArrowRight', 'Backspace', 'Delete', 'Tab'].includes(U.key) ||
          U.ctrlKey ||
          (['ArrowDown', 'ArrowUp'].includes(U.key) &&
            (U.preventDefault(),
            U.stopPropagation(),
            W(),
            await Re(),
            U.key === 'ArrowDown' ? D(!1) : D()))
      }
      function V(U) {
        U.stopPropagation()
      }
      function M(U) {
        ;(U.currentTarget?.releasePointerCapture(U.pointerId), U.preventDefault(), o())
      }
      function F(U) {
        ;(U.currentTarget?.setPointerCapture(U.pointerId),
          U.preventDefault(),
          U.stopPropagation(),
          l('up'))
      }
      function G(U) {
        ;(U.currentTarget?.setPointerCapture(U.pointerId),
          U.preventDefault(),
          U.stopPropagation(),
          l('down'))
      }
      function W() {
        if (r.value || !a.value) return
        const U = a.value.value,
          Y = Number(U.replace(u.value, '.'))
        U && !isNaN(Y) ? (g.value = d(Ge(Y, e.min, e.max))) : (g.value = null)
      }
      function te() {
        r.value ||
          (g.value = f.value !== null && !isNaN(f.value) ? d(f.value, e.precision, !1) : null)
      }
      function H() {
        if (!r.value) {
          if (f.value === null || isNaN(f.value)) {
            g.value = null
            return
          }
          g.value = f.value.toString().replace('.', u.value)
        }
      }
      function O() {
        H()
      }
      function j() {
        W()
      }
      return (
        ne(() => {
          const { modelValue: U, type: Y, ...K } = ia.filterProps(e)
          function se() {
            return n.increment
              ? w(
                  Ae,
                  {
                    key: 'increment-defaults',
                    defaults: {
                      VBtn: {
                        disabled: !h.value,
                        height: k.value,
                        size: S.value,
                        icon: y.value,
                        variant: 'text',
                      },
                    },
                  },
                  { default: () => [n.increment(_)] }
                )
              : w(
                  Me,
                  {
                    'aria-hidden': 'true',
                    'data-testid': 'increment',
                    disabled: !h.value,
                    height: k.value,
                    icon: y.value,
                    key: 'increment-btn',
                    onClick: V,
                    onPointerdown: F,
                    onPointerup: M,
                    onPointercancel: M,
                    size: S.value,
                    variant: 'text',
                    tabindex: '-1',
                  },
                  null
                )
          }
          function de() {
            return n.decrement
              ? w(
                  Ae,
                  {
                    key: 'decrement-defaults',
                    defaults: {
                      VBtn: {
                        disabled: !m.value,
                        height: k.value,
                        size: S.value,
                        icon: p.value,
                        variant: 'text',
                      },
                    },
                  },
                  { default: () => [n.decrement(P)] }
                )
              : w(
                  Me,
                  {
                    'aria-hidden': 'true',
                    'data-testid': 'decrement',
                    disabled: !m.value,
                    height: k.value,
                    icon: p.value,
                    key: 'decrement-btn',
                    onClick: V,
                    onPointerdown: G,
                    onPointerup: M,
                    onPointercancel: M,
                    size: S.value,
                    variant: 'text',
                    tabindex: '-1',
                  },
                  null
                )
          }
          function ye() {
            return x('div', { class: 'v-number-input__control' }, [
              de(),
              w(rn, { vertical: b.value !== 'stacked' }, null),
              se(),
            ])
          }
          function L() {
            return !e.hideInput && !e.inset ? w(rn, { vertical: !0 }, null) : void 0
          }
          const q =
              b.value === 'split'
                ? x('div', { class: 'v-number-input__control' }, [
                    w(rn, { vertical: !0 }, null),
                    se(),
                  ])
                : e.reverse || b.value === 'hidden'
                  ? void 0
                  : x(he, null, [L(), ye()]),
            le = n['append-inner'] || q,
            ie =
              b.value === 'split'
                ? x('div', { class: 'v-number-input__control' }, [
                    de(),
                    w(rn, { vertical: !0 }, null),
                  ])
                : e.reverse && b.value !== 'hidden'
                  ? x(he, null, [ye(), L()])
                  : void 0,
            Ce = n['prepend-inner'] || ie
          return w(
            ia,
            Z({ ref: a }, K, {
              modelValue: g.value,
              'onUpdate:modelValue': (pe) => (g.value = pe),
              focused: s.value,
              'onUpdate:focused': (pe) => (s.value = pe),
              validationValue: f.value,
              onBeforeinput: E,
              onFocus: O,
              onBlur: j,
              onKeydown: R,
              class: [
                'v-number-input',
                {
                  'v-number-input--default': b.value === 'default',
                  'v-number-input--hide-input': e.hideInput,
                  'v-number-input--inset': e.inset,
                  'v-number-input--reverse': e.reverse,
                  'v-number-input--split': b.value === 'split',
                  'v-number-input--stacked': b.value === 'stacked',
                },
                e.class,
              ],
              style: e.style,
              inputmode: 'decimal',
            }),
            {
              ...n,
              'append-inner': le
                ? function () {
                    for (var pe = arguments.length, I = new Array(pe), T = 0; T < pe; T++)
                      I[T] = arguments[T]
                    return x(he, null, [n['append-inner']?.(...I), q])
                  }
                : void 0,
              'prepend-inner': Ce
                ? function () {
                    for (var pe = arguments.length, I = new Array(pe), T = 0; T < pe; T++)
                      I[T] = arguments[T]
                    return x(he, null, [ie, n['prepend-inner']?.(...I)])
                  }
                : void 0,
            }
          )
        }),
        _t({}, a)
      )
    },
  }),
  VD = $(
    {
      autofocus: Boolean,
      divider: String,
      focusAll: Boolean,
      label: { type: String, default: '$vuetify.input.otp' },
      length: { type: [Number, String], default: 6 },
      modelValue: { type: [Number, String], default: void 0 },
      placeholder: String,
      type: { type: String, default: 'number' },
      ...ft(),
      ...ci(),
      ...Zt(fi({ variant: 'outlined' }), [
        'baseColor',
        'bgColor',
        'class',
        'color',
        'disabled',
        'error',
        'loading',
        'rounded',
        'style',
        'theme',
        'variant',
      ]),
    },
    'VOtpInput'
  ),
  ID = J()({
    name: 'VOtpInput',
    props: VD(),
    emits: { finish: (e) => !0, 'update:focused': (e) => !0, 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { attrs: n, emit: a, slots: l } = t
      const { dimensionStyles: o } = vt(e),
        { isFocused: i, focus: r, blur: s } = va(e),
        c = we(
          e,
          'modelValue',
          '',
          (E) => (E == null ? [] : String(E).split('')),
          (E) => E.join('')
        ),
        { t: u } = ze(),
        d = C(() => Number(e.length)),
        f = C(() => Array(d.value).fill(0)),
        v = ae(-1),
        g = ae(),
        h = ae([]),
        m = C(() => h.value[v.value])
      let b = !1
      Et(
        () => e.autofocus,
        () => {
          const E = Ya()
          E.run(() => {
            const { intersectionRef: R, isIntersecting: V } = oi()
            ;(qe(() => {
              R.value = h.value[0]
            }),
              ue(V, (M) => {
                M && (R.value?.focus(), E.stop())
              }))
          })
        }
      )
      function y() {
        if (D(m.value.value)) {
          m.value.value = ''
          return
        }
        if (b) return
        const E = c.value.slice(),
          R = m.value.value
        E[v.value] = R
        let V = null
        ;(v.value > c.value.length
          ? (V = c.value.length + 1)
          : v.value + 1 !== d.value && (V = 'next'),
          (c.value = E),
          V && Ua(g.value, V))
      }
      function p() {
        ;((b = !1), y())
      }
      function S(E) {
        const R = c.value.slice(),
          V = v.value
        let M = null
        ;['ArrowLeft', 'ArrowRight', 'Backspace', 'Delete'].includes(E.key) &&
          (E.preventDefault(),
          E.key === 'ArrowLeft'
            ? (M = 'prev')
            : E.key === 'ArrowRight'
              ? (M = 'next')
              : ['Backspace', 'Delete'].includes(E.key) &&
                ((R[v.value] = ''),
                (c.value = R),
                v.value > 0 && E.key === 'Backspace'
                  ? (M = 'prev')
                  : requestAnimationFrame(() => {
                      h.value[V]?.select()
                    })),
          requestAnimationFrame(() => {
            M != null && Ua(g.value, M)
          }))
      }
      function k(E, R) {
        ;(R.preventDefault(), R.stopPropagation())
        const V = R?.clipboardData?.getData('Text').trim().slice(0, d.value) ?? '',
          M = V.length - 1 === -1 ? E : V.length - 1
        D(V) || ((c.value = V.split('')), (v.value = M))
      }
      function _() {
        c.value = []
      }
      function P(E, R) {
        ;(r(), (v.value = R))
      }
      function A() {
        ;(s(), (v.value = -1))
      }
      function D(E) {
        return e.type === 'number' && /[^0-9]/g.test(E)
      }
      return (
        lt(
          {
            VField: {
              color: B(() => e.color),
              bgColor: B(() => e.color),
              baseColor: B(() => e.baseColor),
              disabled: B(() => e.disabled),
              error: B(() => e.error),
              variant: B(() => e.variant),
            },
          },
          { scoped: !0 }
        ),
        ue(
          c,
          (E) => {
            E.length === d.value && a('finish', E.join(''))
          },
          { deep: !0 }
        ),
        ue(v, (E) => {
          E < 0 ||
            Re(() => {
              h.value[E]?.select()
            })
        }),
        ne(() => {
          const [E, R] = Ia(n)
          return x(
            'div',
            Z(
              {
                class: ['v-otp-input', { 'v-otp-input--divided': !!e.divider }, e.class],
                style: [e.style],
              },
              E
            ),
            [
              x('div', { ref: g, class: 'v-otp-input__content', style: ce([o.value]) }, [
                f.value.map((V, M) =>
                  x(he, null, [
                    e.divider &&
                      M !== 0 &&
                      x('span', { class: 'v-otp-input__divider' }, [e.divider]),
                    w(
                      Va,
                      { focused: (i.value && e.focusAll) || v.value === M, key: M },
                      {
                        ...l,
                        loader: void 0,
                        default: () =>
                          x(
                            'input',
                            {
                              ref: (F) => (h.value[M] = F),
                              'aria-label': u(e.label, M + 1),
                              autofocus: M === 0 && e.autofocus,
                              autocomplete: 'one-time-code',
                              class: ee(['v-otp-input__field']),
                              disabled: e.disabled,
                              inputmode: e.type === 'number' ? 'numeric' : 'text',
                              min: e.type === 'number' ? 0 : void 0,
                              maxlength: M === 0 ? d.value : '1',
                              placeholder: e.placeholder,
                              type: e.type === 'number' ? 'text' : e.type,
                              value: c.value[M],
                              onInput: y,
                              onFocus: (F) => P(F, M),
                              onBlur: A,
                              onKeydown: S,
                              onCompositionstart: () => (b = !0),
                              onCompositionend: p,
                              onPaste: (F) => k(M, F),
                            },
                            null
                          ),
                      }
                    ),
                  ])
                ),
                x(
                  'input',
                  Z({ class: 'v-otp-input-input', type: 'hidden' }, R, { value: c.value.join('') }),
                  null
                ),
                w(
                  Nn,
                  {
                    contained: !0,
                    contentClass: 'v-otp-input__loader',
                    modelValue: !!e.loading,
                    persistent: !0,
                  },
                  {
                    default: () => [
                      l.loader?.() ??
                        w(
                          Ja,
                          {
                            color: typeof e.loading == 'boolean' ? void 0 : e.loading,
                            indeterminate: !0,
                            size: '24',
                            width: '2',
                          },
                          null
                        ),
                    ],
                  }
                ),
                l.default?.(),
              ]),
            ]
          )
        }),
        {
          blur: () => {
            h.value?.some((E) => E.blur())
          },
          focus: () => {
            h.value?.[0].focus()
          },
          reset: _,
          isFocused: i,
        }
      )
    },
  })
function TD(e) {
  return Math.floor(Math.abs(e)) * Math.sign(e)
}
const AD = $({ scale: { type: [Number, String], default: 0.5 }, ...be() }, 'VParallax'),
  ED = J()({
    name: 'VParallax',
    props: AD(),
    setup(e, t) {
      let { slots: n } = t
      const { intersectionRef: a, isIntersecting: l } = oi(),
        { resizeRef: o, contentRect: i } = hn(),
        { height: r } = gn(),
        s = ae()
      qe(() => {
        a.value = o.value = s.value?.$el
      })
      let c
      ;(ue(l, (v) => {
        v
          ? ((c = Zc(a.value)),
            (c = c === document.scrollingElement ? document : c),
            c.addEventListener('scroll', f, { passive: !0 }),
            f())
          : c.removeEventListener('scroll', f)
      }),
        dt(() => {
          c?.removeEventListener('scroll', f)
        }),
        ue(r, f),
        ue(() => i.value?.height, f))
      const u = C(() => 1 - Ge(Number(e.scale)))
      let d = -1
      function f() {
        !l.value ||
          On() ||
          (cancelAnimationFrame(d),
          (d = requestAnimationFrame(() => {
            const v = (s.value?.$el).querySelector('.v-img__img')
            if (!v) return
            const g =
                c instanceof Document ? document.documentElement.clientHeight : c.clientHeight,
              h = c instanceof Document ? window.scrollY : c.scrollTop,
              m = a.value.getBoundingClientRect().top + h,
              b = i.value.height,
              y = m + (b - g) / 2,
              p = TD((h - y) * u.value),
              S = Math.max(1, (u.value * (g - b) + b) / b)
            v.style.setProperty('transform', `translateY(${p}px) scale(${S})`)
          })))
      }
      return (
        ne(() =>
          w(
            oa,
            {
              class: ee(['v-parallax', { 'v-parallax--active': l.value }, e.class]),
              style: ce(e.style),
              ref: s,
              cover: !0,
              onLoadstart: f,
              onLoad: f,
            },
            n
          )
        ),
        {}
      )
    },
  }),
  DD = $({ ...zr({ falseIcon: '$radioOff', trueIcon: '$radioOn' }) }, 'VRadio'),
  RD = J()({
    name: 'VRadio',
    props: DD(),
    setup(e, t) {
      let { slots: n } = t
      return (
        ne(() => {
          const a = Pa.filterProps(e)
          return w(Pa, Z(a, { class: ['v-radio', e.class], style: e.style, type: 'radio' }), n)
        }),
        {}
      )
    },
  }),
  MD = $(
    {
      height: { type: [Number, String], default: 'auto' },
      ...ma(),
      ...je(fd(), ['multiple']),
      trueIcon: { type: Se, default: '$radioOn' },
      falseIcon: { type: Se, default: '$radioOff' },
      type: { type: String, default: 'radio' },
    },
    'VRadioGroup'
  ),
  BD = J()({
    name: 'VRadioGroup',
    inheritAttrs: !1,
    props: MD(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: a } = t
      const l = Rt(),
        o = C(() => e.id || `radio-group-${l}`),
        i = we(e, 'modelValue'),
        r = ae()
      return (
        ne(() => {
          const [s, c] = Ia(n),
            u = Dt.filterProps(e),
            d = Pa.filterProps(e),
            f = a.label ? a.label({ label: e.label, props: { for: o.value } }) : e.label
          return w(
            Dt,
            Z({ ref: r, class: ['v-radio-group', e.class], style: e.style }, s, u, {
              modelValue: i.value,
              'onUpdate:modelValue': (v) => (i.value = v),
              id: o.value,
            }),
            {
              ...a,
              default: (v) => {
                let { id: g, messagesId: h, isDisabled: m, isReadonly: b } = v
                return x(he, null, [
                  f && w(eo, { id: g.value }, { default: () => [f] }),
                  w(
                    Zy,
                    Z(
                      d,
                      {
                        id: g.value,
                        'aria-describedby': h.value,
                        defaultsTarget: 'VRadio',
                        trueIcon: e.trueIcon,
                        falseIcon: e.falseIcon,
                        type: e.type,
                        disabled: m.value,
                        readonly: b.value,
                        'aria-labelledby': f ? g.value : void 0,
                        multiple: !1,
                      },
                      c,
                      { modelValue: i.value, 'onUpdate:modelValue': (y) => (i.value = y) }
                    ),
                    a
                  ),
                ])
              },
            }
          )
        }),
        _t({}, r)
      )
    },
  }),
  LD = $(
    {
      ...ci(),
      ...ma(),
      ...Qb(),
      strict: Boolean,
      modelValue: { type: Array, default: () => [0, 0] },
    },
    'VRangeSlider'
  ),
  OD = J()({
    name: 'VRangeSlider',
    props: LD(),
    emits: {
      'update:focused': (e) => !0,
      'update:modelValue': (e) => !0,
      end: (e) => !0,
      start: (e) => !0,
    },
    setup(e, t) {
      let { slots: n, emit: a } = t
      const l = ae(),
        o = ae(),
        i = ae(),
        { rtlClasses: r } = gt()
      function s(E) {
        if (!l.value || !o.value) return
        const R = Wu(E, l.value.$el, e.direction),
          V = Wu(E, o.value.$el, e.direction),
          M = Math.abs(R),
          F = Math.abs(V)
        return M < F || (M === F && R < 0) ? l.value.$el : o.value.$el
      }
      const c = ep(e),
        u = we(e, 'modelValue', void 0, (E) =>
          E?.length ? E.map((R) => c.roundValue(R)) : [0, 0]
        ),
        {
          activeThumbRef: d,
          hasLabels: f,
          max: v,
          min: g,
          mousePressed: h,
          onSliderMousedown: m,
          onSliderTouchstart: b,
          position: y,
          trackContainerRef: p,
          readonly: S,
        } = tp({
          props: e,
          steps: c,
          onSliderStart: () => {
            a('start', u.value)
          },
          onSliderEnd: (E) => {
            let { value: R } = E
            const V = d.value === l.value?.$el ? [R, u.value[1]] : [u.value[0], R]
            ;(!e.strict && V[0] < V[1] && (u.value = V), a('end', u.value))
          },
          onSliderMove: (E) => {
            let { value: R } = E
            const [V, M] = u.value
            ;(!e.strict &&
              V === M &&
              V !== g.value &&
              ((d.value = R > V ? o.value?.$el : l.value?.$el), d.value?.focus()),
              d.value === l.value?.$el
                ? (u.value = [Math.min(R, M), M])
                : (u.value = [V, Math.max(V, R)]))
          },
          getActiveThumb: s,
        }),
        { isFocused: k, focus: _, blur: P } = va(e),
        A = C(() => y(u.value[0])),
        D = C(() => y(u.value[1]))
      return (
        ne(() => {
          const E = Dt.filterProps(e),
            R = !!(e.label || n.label || n.prepend)
          return w(
            Dt,
            Z(
              {
                class: [
                  'v-slider',
                  'v-range-slider',
                  {
                    'v-slider--has-labels': !!n['tick-label'] || f.value,
                    'v-slider--focused': k.value,
                    'v-slider--pressed': h.value,
                    'v-slider--disabled': e.disabled,
                  },
                  r.value,
                  e.class,
                ],
                style: e.style,
                ref: i,
              },
              E,
              { focused: k.value }
            ),
            {
              ...n,
              prepend: R
                ? (V) =>
                    x(he, null, [
                      n.label?.(V) ??
                        (e.label
                          ? w(eo, { class: 'v-slider__label', text: e.label }, null)
                          : void 0),
                      n.prepend?.(V),
                    ])
                : void 0,
              default: (V) => {
                let { id: M, messagesId: F } = V
                return x(
                  'div',
                  {
                    class: 'v-slider__container',
                    onMousedown: S.value ? void 0 : m,
                    onTouchstartPassive: S.value ? void 0 : b,
                  },
                  [
                    x(
                      'input',
                      {
                        id: `${M.value}_start`,
                        name: e.name || M.value,
                        disabled: !!e.disabled,
                        readonly: !!e.readonly,
                        tabindex: '-1',
                        value: u.value[0],
                      },
                      null
                    ),
                    x(
                      'input',
                      {
                        id: `${M.value}_stop`,
                        name: e.name || M.value,
                        disabled: !!e.disabled,
                        readonly: !!e.readonly,
                        tabindex: '-1',
                        value: u.value[1],
                      },
                      null
                    ),
                    w(
                      np,
                      { ref: p, start: A.value, stop: D.value },
                      { 'tick-label': n['tick-label'] }
                    ),
                    w(
                      Uu,
                      {
                        ref: l,
                        'aria-describedby': F.value,
                        focused: k && d.value === l.value?.$el,
                        modelValue: u.value[0],
                        'onUpdate:modelValue': (G) => (u.value = [G, u.value[1]]),
                        onFocus: (G) => {
                          ;(_(),
                            (d.value = l.value?.$el),
                            v.value !== g.value &&
                              u.value[0] === u.value[1] &&
                              u.value[1] === g.value &&
                              G.relatedTarget !== o.value?.$el &&
                              (l.value?.$el.blur(), o.value?.$el.focus()))
                        },
                        onBlur: () => {
                          ;(P(), (d.value = void 0))
                        },
                        min: g.value,
                        max: u.value[1],
                        position: A.value,
                        ripple: e.ripple,
                      },
                      { 'thumb-label': n['thumb-label'] }
                    ),
                    w(
                      Uu,
                      {
                        ref: o,
                        'aria-describedby': F.value,
                        focused: k && d.value === o.value?.$el,
                        modelValue: u.value[1],
                        'onUpdate:modelValue': (G) => (u.value = [u.value[0], G]),
                        onFocus: (G) => {
                          ;(_(),
                            (d.value = o.value?.$el),
                            v.value !== g.value &&
                              u.value[0] === u.value[1] &&
                              u.value[0] === v.value &&
                              G.relatedTarget !== l.value?.$el &&
                              (o.value?.$el.blur(), l.value?.$el.focus()))
                        },
                        onBlur: () => {
                          ;(P(), (d.value = void 0))
                        },
                        min: u.value[0],
                        max: v.value,
                        position: D.value,
                        ripple: e.ripple,
                      },
                      { 'thumb-label': n['thumb-label'] }
                    ),
                  ]
                )
              },
            }
          )
        }),
        _t({ focus: () => l.value?.$el.focus() }, i)
      )
    },
  }),
  $D = $(
    {
      name: String,
      itemAriaLabel: { type: String, default: '$vuetify.rating.ariaLabel.item' },
      activeColor: String,
      color: String,
      clearable: Boolean,
      disabled: Boolean,
      emptyIcon: { type: Se, default: '$ratingEmpty' },
      fullIcon: { type: Se, default: '$ratingFull' },
      halfIncrements: Boolean,
      hover: Boolean,
      length: { type: [Number, String], default: 5 },
      readonly: Boolean,
      modelValue: { type: [Number, String], default: 0 },
      itemLabels: Array,
      itemLabelPosition: {
        type: String,
        default: 'top',
        validator: (e) => ['top', 'bottom'].includes(e),
      },
      ripple: Boolean,
      ...be(),
      ...St(),
      ...Un(),
      ...Ie(),
      ...Be(),
    },
    'VRating'
  ),
  FD = J()({
    name: 'VRating',
    props: $D(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { t: a } = ze(),
        { themeClasses: l } = $e(e),
        o = we(e, 'modelValue'),
        i = C(() => Ge(parseFloat(o.value), 0, Number(e.length))),
        r = C(() => ln(Number(e.length), 1)),
        s = C(() => r.value.flatMap((m) => (e.halfIncrements ? [m - 0.5, m] : [m]))),
        c = oe(-1),
        u = C(() =>
          s.value.map((m) => {
            const b = e.hover && c.value > -1,
              y = i.value >= m,
              p = c.value >= m,
              k = (b ? p : y) ? e.fullIcon : e.emptyIcon,
              _ = e.activeColor ?? e.color,
              P = y || p ? _ : e.color
            return { isFilled: y, isHovered: p, icon: k, color: P }
          })
        ),
        d = C(() =>
          [0, ...s.value].map((m) => {
            function b() {
              c.value = m
            }
            function y() {
              c.value = -1
            }
            function p() {
              e.disabled || e.readonly || (o.value = i.value === m && e.clearable ? 0 : m)
            }
            return {
              onMouseenter: e.hover ? b : void 0,
              onMouseleave: e.hover ? y : void 0,
              onClick: p,
            }
          })
        ),
        f = Rt(),
        v = C(() => e.name ?? `v-rating-${f}`)
      function g(m) {
        let { value: b, index: y, showStar: p = !0 } = m
        const { onMouseenter: S, onMouseleave: k, onClick: _ } = d.value[y + 1],
          P = `${v.value}-${String(b).replace('.', '-')}`,
          A = {
            color: u.value[y]?.color,
            density: e.density,
            disabled: e.disabled,
            icon: u.value[y]?.icon,
            ripple: e.ripple,
            size: e.size,
            variant: 'plain',
          }
        return x(he, null, [
          x(
            'label',
            {
              for: P,
              class: ee({
                'v-rating__item--half': e.halfIncrements && b % 1 > 0,
                'v-rating__item--full': e.halfIncrements && b % 1 === 0,
              }),
              onMouseenter: S,
              onMouseleave: k,
              onClick: _,
            },
            [
              x('span', { class: 'v-rating__hidden' }, [a(e.itemAriaLabel, b, e.length)]),
              p
                ? n.item
                  ? n.item({ ...u.value[y], props: A, value: b, index: y, rating: i.value })
                  : w(Me, Z({ 'aria-label': a(e.itemAriaLabel, b, e.length) }, A), null)
                : void 0,
            ]
          ),
          x(
            'input',
            {
              class: 'v-rating__hidden',
              name: v.value,
              id: P,
              type: 'radio',
              value: b,
              checked: i.value === b,
              tabindex: -1,
              readonly: e.readonly,
              disabled: e.disabled,
            },
            null
          ),
        ])
      }
      function h(m) {
        return n['item-label']
          ? n['item-label'](m)
          : m.label
            ? x('span', null, [m.label])
            : x('span', null, [qt(' ')])
      }
      return (
        ne(() => {
          const m = !!e.itemLabels?.length || n['item-label']
          return w(
            e.tag,
            {
              class: ee([
                'v-rating',
                { 'v-rating--hover': e.hover, 'v-rating--readonly': e.readonly },
                l.value,
                e.class,
              ]),
              style: ce(e.style),
            },
            {
              default: () => [
                w(g, { value: 0, index: -1, showStar: !1 }, null),
                r.value.map((b, y) =>
                  x('div', { class: 'v-rating__wrapper' }, [
                    m && e.itemLabelPosition === 'top'
                      ? h({ value: b, index: y, label: e.itemLabels?.[y] })
                      : void 0,
                    x('div', { class: 'v-rating__item' }, [
                      e.halfIncrements
                        ? x(he, null, [
                            w(g, { value: b - 0.5, index: y * 2 }, null),
                            w(g, { value: b, index: y * 2 + 1 }, null),
                          ])
                        : w(g, { value: b, index: y }, null),
                    ]),
                    m && e.itemLabelPosition === 'bottom'
                      ? h({ value: b, index: y, label: e.itemLabels?.[y] })
                      : void 0,
                  ])
                ),
              ],
            }
          )
        }),
        {}
      )
    },
  }),
  ND = {
    actions: 'button@2',
    article: 'heading, paragraph',
    avatar: 'avatar',
    button: 'button',
    card: 'image, heading',
    'card-avatar': 'image, list-item-avatar',
    chip: 'chip',
    'date-picker': 'list-item, heading, divider, date-picker-options, date-picker-days, actions',
    'date-picker-options': 'text, avatar@2',
    'date-picker-days': 'avatar@28',
    divider: 'divider',
    heading: 'heading',
    image: 'image',
    'list-item': 'text',
    'list-item-avatar': 'avatar, text',
    'list-item-two-line': 'sentences',
    'list-item-avatar-two-line': 'avatar, sentences',
    'list-item-three-line': 'paragraph',
    'list-item-avatar-three-line': 'avatar, paragraph',
    ossein: 'ossein',
    paragraph: 'text@3',
    sentences: 'text@2',
    subtitle: 'text',
    table: 'table-heading, table-thead, table-tbody, table-tfoot',
    'table-heading': 'chip, text',
    'table-thead': 'heading@6',
    'table-tbody': 'table-row-divider@6',
    'table-row-divider': 'table-row, divider',
    'table-row': 'text@6',
    'table-tfoot': 'text@2, avatar@2',
    text: 'text',
  }
function HD(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []
  return x('div', { class: ee(['v-skeleton-loader__bone', `v-skeleton-loader__${e}`]) }, [t])
}
function Sm(e) {
  const [t, n] = e.split('@')
  return Array.from({ length: n }).map(() => ls(t))
}
function ls(e) {
  let t = []
  if (!e) return t
  const n = ND[e]
  if (e !== n) {
    if (e.includes(',')) return wm(e)
    if (e.includes('@')) return Sm(e)
    n.includes(',') ? (t = wm(n)) : n.includes('@') ? (t = Sm(n)) : n && t.push(ls(n))
  }
  return [HD(e, t)]
}
function wm(e) {
  return e.replace(/\s/g, '').split(',').map(ls)
}
const jD = $(
    {
      boilerplate: Boolean,
      color: String,
      loading: Boolean,
      loadingText: { type: String, default: '$vuetify.loading' },
      type: { type: [String, Array], default: 'ossein' },
      ...ft(),
      ...yt(),
      ...Be(),
    },
    'VSkeletonLoader'
  ),
  zD = J()({
    name: 'VSkeletonLoader',
    inheritAttrs: !1,
    props: jD(),
    setup(e, t) {
      let { attrs: n, slots: a } = t
      const { backgroundColorClasses: l, backgroundColorStyles: o } = He(() => e.color),
        { dimensionStyles: i } = vt(e),
        { elevationClasses: r } = xt(e),
        { themeClasses: s } = $e(e),
        { t: c } = ze(),
        u = C(() => ls(nt(e.type).join(',')))
      return (
        ne(() => {
          const d = !a.default || e.loading,
            f =
              e.boilerplate || !d
                ? {}
                : { ariaLive: 'polite', ariaLabel: c(e.loadingText), role: 'alert' }
          return x(he, null, [
            d
              ? x(
                  'div',
                  Z(
                    {
                      class: [
                        'v-skeleton-loader',
                        { 'v-skeleton-loader--boilerplate': e.boilerplate },
                        s.value,
                        l.value,
                        r.value,
                      ],
                      style: [o.value, i.value],
                    },
                    f,
                    n
                  ),
                  [u.value]
                )
              : a.default?.(),
          ])
        }),
        {}
      )
    },
  }),
  WD = J()({
    name: 'VSlideGroupItem',
    props: dl(),
    emits: { 'group:selected': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = fl(e, ib)
      return () =>
        n.default?.({
          isSelected: a.isSelected.value,
          select: a.select,
          toggle: a.toggle,
          selectedClass: a.selectedClass.value,
        })
    },
  })
function UD(e) {
  const t = oe(e())
  let n = -1
  function a() {
    clearInterval(n)
  }
  function l() {
    ;(a(), Re(() => (t.value = e())))
  }
  function o(i) {
    const r = i ? getComputedStyle(i) : { transitionDuration: 0.2 },
      s = parseFloat(r.transitionDuration) * 1e3 || 200
    if ((a(), t.value <= 0)) return
    const c = performance.now()
    n = window.setInterval(() => {
      const u = performance.now() - c + s
      ;((t.value = Math.max(e() - u, 0)), t.value <= 0 && a())
    }, s)
  }
  return (bt(a), { clear: a, time: t, start: o, reset: l })
}
const tS = $(
    {
      multiLine: Boolean,
      text: String,
      timer: [Boolean, String],
      timeout: { type: [Number, String], default: 5e3 },
      vertical: Boolean,
      ...fa({ location: 'bottom' }),
      ...Jl(),
      ...Je(),
      ...yn(),
      ...Be(),
      ...je(di({ transition: 'v-snackbar-transition' }), [
        'persistent',
        'noClickAnimation',
        'scrim',
        'scrollStrategy',
        'stickToTarget',
      ]),
    },
    'VSnackbar'
  ),
  nc = J()({
    name: 'VSnackbar',
    props: tS(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = we(e, 'modelValue'),
        { positionClasses: l } = Ql(e),
        { scopeId: o } = ml(),
        { themeClasses: i } = $e(e),
        { colorClasses: r, colorStyles: s, variantClasses: c } = ul(e),
        { roundedClasses: u } = ot(e),
        d = UD(() => Number(e.timeout)),
        f = ae(),
        v = ae(),
        g = oe(!1),
        h = oe(0),
        m = ae(),
        b = Ve($o, void 0)
      ;(Et(
        () => !!b,
        () => {
          const R = Ty()
          qe(() => {
            m.value = R.mainStyles.value
          })
        }
      ),
        ue(a, p),
        ue(() => e.timeout, p),
        pt(() => {
          a.value && p()
        }))
      let y = -1
      function p() {
        ;(d.reset(), window.clearTimeout(y))
        const R = Number(e.timeout)
        if (!a.value || R === -1) return
        const V = Wc(v.value)
        ;(d.start(V),
          (y = window.setTimeout(() => {
            a.value = !1
          }, R)))
      }
      function S() {
        ;(d.reset(), window.clearTimeout(y))
      }
      function k() {
        ;((g.value = !0), S())
      }
      function _() {
        ;((g.value = !1), p())
      }
      function P(R) {
        h.value = R.touches[0].clientY
      }
      function A(R) {
        Math.abs(h.value - R.changedTouches[0].clientY) > 50 && (a.value = !1)
      }
      function D() {
        g.value && _()
      }
      const E = C(() =>
        e.location.split(' ').reduce((R, V) => ((R[`v-snackbar--${V}`] = !0), R), {})
      )
      return (
        ne(() => {
          const R = Nn.filterProps(e),
            V = !!(n.default || n.text || e.text)
          return w(
            Nn,
            Z(
              {
                ref: f,
                class: [
                  'v-snackbar',
                  {
                    'v-snackbar--active': a.value,
                    'v-snackbar--multi-line': e.multiLine && !e.vertical,
                    'v-snackbar--timer': !!e.timer,
                    'v-snackbar--vertical': e.vertical,
                  },
                  E.value,
                  l.value,
                  e.class,
                ],
                style: [m.value, e.style],
              },
              R,
              {
                modelValue: a.value,
                'onUpdate:modelValue': (M) => (a.value = M),
                contentProps: Z(
                  {
                    class: ['v-snackbar__wrapper', i.value, r.value, u.value, c.value],
                    style: [s.value],
                    onPointerenter: k,
                    onPointerleave: _,
                  },
                  R.contentProps
                ),
                persistent: !0,
                noClickAnimation: !0,
                scrim: !1,
                scrollStrategy: 'none',
                _disableGlobalStack: !0,
                onTouchstartPassive: P,
                onTouchend: A,
                onAfterLeave: D,
              },
              o
            ),
            {
              default: () => [
                Ta(!1, 'v-snackbar'),
                e.timer &&
                  !g.value &&
                  x('div', { key: 'timer', class: 'v-snackbar__timer' }, [
                    w(
                      Nr,
                      {
                        ref: v,
                        color: typeof e.timer == 'string' ? e.timer : 'info',
                        max: e.timeout,
                        modelValue: d.time.value,
                      },
                      null
                    ),
                  ]),
                V &&
                  x(
                    'div',
                    {
                      key: 'content',
                      class: 'v-snackbar__content',
                      role: 'status',
                      'aria-live': 'polite',
                    },
                    [n.text?.() ?? e.text, n.default?.()]
                  ),
                n.actions &&
                  w(
                    Ae,
                    { defaults: { VBtn: { variant: 'text', ripple: !1, slim: !0 } } },
                    {
                      default: () => [
                        x('div', { class: 'v-snackbar__actions' }, [n.actions({ isActive: a })]),
                      ],
                    }
                  ),
              ],
              activator: n.activator,
            }
          )
        }),
        _t({}, f)
      )
    },
  }),
  KD = $(
    {
      closable: [Boolean, String],
      closeText: { type: String, default: '$vuetify.dismiss' },
      modelValue: { type: Array, default: () => [] },
      ...je(tS(), ['modelValue']),
    },
    'VSnackbarQueue'
  ),
  GD = J()({
    name: 'VSnackbarQueue',
    props: KD(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { emit: n, slots: a } = t
      const { t: l } = ze(),
        o = oe(!1),
        i = oe(!1),
        r = oe()
      ;(ue(
        () => e.modelValue.length,
        (f, v) => {
          !i.value && f > v && c()
        }
      ),
        ue(o, (f) => {
          f && (i.value = !0)
        }))
      function s() {
        e.modelValue.length ? c() : ((r.value = void 0), (i.value = !1))
      }
      function c() {
        const [f, ...v] = e.modelValue
        ;(n('update:modelValue', v),
          (r.value = typeof f == 'string' ? { text: f } : f),
          Re(() => {
            o.value = !0
          }))
      }
      function u() {
        o.value = !1
      }
      const d = C(() => ({
        color: typeof e.closable == 'string' ? e.closable : void 0,
        text: l(e.closeText),
      }))
      ne(() => {
        const f = !!(e.closable || a.actions),
          { modelValue: v, ...g } = nc.filterProps(e)
        return x(he, null, [
          i.value &&
            !!r.value &&
            (a.default
              ? w(
                  Ae,
                  { defaults: { VSnackbar: r.value } },
                  { default: () => [a.default({ item: r.value })] }
                )
              : w(
                  nc,
                  Z(g, r.value, {
                    modelValue: o.value,
                    'onUpdate:modelValue': (h) => (o.value = h),
                    onAfterLeave: s,
                  }),
                  {
                    text: a.text ? () => a.text?.({ item: r.value }) : void 0,
                    actions: f
                      ? () =>
                          x(he, null, [
                            a.actions
                              ? w(
                                  Ae,
                                  { defaults: { VBtn: d.value } },
                                  {
                                    default: () => [
                                      a.actions({ item: r.value, props: { onClick: u } }),
                                    ],
                                  }
                                )
                              : w(Me, Z(d.value, { onClick: u }), null),
                          ])
                      : void 0,
                  }
                )),
        ])
      })
    },
  }),
  nS = $(
    {
      autoDraw: Boolean,
      autoDrawDuration: [Number, String],
      autoDrawEasing: { type: String, default: 'ease' },
      color: String,
      gradient: { type: Array, default: () => [] },
      gradientDirection: {
        type: String,
        validator: (e) => ['top', 'bottom', 'left', 'right'].includes(e),
        default: 'top',
      },
      height: { type: [String, Number], default: 75 },
      labels: { type: Array, default: () => [] },
      labelSize: { type: [Number, String], default: 7 },
      lineWidth: { type: [String, Number], default: 4 },
      id: String,
      itemValue: { type: String, default: 'value' },
      modelValue: { type: Array, default: () => [] },
      min: [String, Number],
      max: [String, Number],
      padding: { type: [String, Number], default: 8 },
      showLabels: Boolean,
      smooth: [Boolean, String, Number],
      width: { type: [Number, String], default: 300 },
    },
    'Line'
  ),
  aS = $({ autoLineWidth: Boolean, ...nS() }, 'VBarline'),
  km = J()({
    name: 'VBarline',
    props: aS(),
    setup(e, t) {
      let { slots: n } = t
      const a = Rt(),
        l = C(() => e.id || `barline-${a}`),
        o = C(() => Number(e.autoDrawDuration) || 500),
        i = C(() => !!(e.showLabels || e.labels.length > 0 || n?.label)),
        r = C(() => parseFloat(e.lineWidth) || 4),
        s = C(() => Math.max(e.modelValue.length * r.value, Number(e.width))),
        c = C(() => ({ minX: 0, maxX: s.value, minY: 0, maxY: parseInt(e.height, 10) })),
        u = C(() => e.modelValue.map((m) => st(m, e.itemValue, m)))
      function d(m, b) {
        const { minX: y, maxX: p, minY: S, maxY: k } = b,
          _ = m.length
        let P = e.max != null ? Number(e.max) : Math.max(...m),
          A = e.min != null ? Number(e.min) : Math.min(...m)
        ;(A > 0 && e.min == null && (A = 0), P < 0 && e.max == null && (P = 0))
        const D = p / (_ === 1 ? 2 : _),
          E = (k - S) / (P - A || 1),
          R = k - Math.abs(A * E)
        return m.map((V, M) => {
          const F = Math.abs(E * V)
          return { x: y + M * D, y: R - F + +(V < 0) * F, height: F, value: V }
        })
      }
      const f = C(() => {
          const m = [],
            b = d(u.value, c.value),
            y = b.length
          for (let p = 0; m.length < y; p++) {
            const S = b[p]
            let k = e.labels[p]
            ;(k || (k = typeof S == 'object' ? S.value : S), m.push({ x: S.x, value: String(k) }))
          }
          return m
        }),
        v = C(() => d(u.value, c.value)),
        g = C(() =>
          v.value.length === 1
            ? (c.value.maxX - r.value) / 2
            : (Math.abs(v.value[0].x - v.value[1].x) - r.value) / 2
        ),
        h = C(() => (typeof e.smooth == 'boolean' ? (e.smooth ? 2 : 0) : Number(e.smooth)))
      ne(() => {
        const m = e.gradient.slice().length ? e.gradient.slice().reverse() : ['']
        return x('svg', { display: 'block' }, [
          x('defs', null, [
            x(
              'linearGradient',
              {
                id: l.value,
                gradientUnits: 'userSpaceOnUse',
                x1: e.gradientDirection === 'left' ? '100%' : '0',
                y1: e.gradientDirection === 'top' ? '100%' : '0',
                x2: e.gradientDirection === 'right' ? '100%' : '0',
                y2: e.gradientDirection === 'bottom' ? '100%' : '0',
              },
              [
                m.map((b, y) =>
                  x(
                    'stop',
                    { offset: y / Math.max(m.length - 1, 1), 'stop-color': b || 'currentColor' },
                    null
                  )
                ),
              ]
            ),
          ]),
          x('clipPath', { id: `${l.value}-clip` }, [
            v.value.map((b) =>
              x(
                'rect',
                {
                  x: b.x + g.value,
                  y: b.y,
                  width: r.value,
                  height: b.height,
                  rx: h.value,
                  ry: h.value,
                },
                [
                  e.autoDraw &&
                    !On() &&
                    x(he, null, [
                      x(
                        'animate',
                        {
                          attributeName: 'y',
                          from: b.y + b.height,
                          to: b.y,
                          dur: `${o.value}ms`,
                          fill: 'freeze',
                        },
                        null
                      ),
                      x(
                        'animate',
                        {
                          attributeName: 'height',
                          from: '0',
                          to: b.height,
                          dur: `${o.value}ms`,
                          fill: 'freeze',
                        },
                        null
                      ),
                    ]),
                ]
              )
            ),
          ]),
          i.value &&
            x(
              'g',
              {
                key: 'labels',
                style: {
                  textAnchor: 'middle',
                  dominantBaseline: 'mathematical',
                  fill: 'currentColor',
                },
              },
              [
                f.value.map((b, y) =>
                  x(
                    'text',
                    {
                      x: b.x + g.value + r.value / 2,
                      y: parseInt(e.height, 10) - 2 + (parseInt(e.labelSize, 10) || 7 * 0.75),
                      'font-size': Number(e.labelSize) || 7,
                    },
                    [n.label?.({ index: y, value: b.value }) ?? b.value]
                  )
                ),
              ]
            ),
          x('g', { 'clip-path': `url(#${l.value}-clip)`, fill: `url(#${l.value})` }, [
            x(
              'rect',
              {
                x: 0,
                y: 0,
                width: Math.max(e.modelValue.length * r.value, Number(e.width)),
                height: e.height,
              },
              null
            ),
          ]),
        ])
      })
    },
  })
function YD(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
    a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 75
  if (e.length === 0) return ''
  const l = e.shift(),
    o = e[e.length - 1]
  return (
    (n ? `M${l.x} ${a - l.x + 2} L${l.x} ${l.y}` : `M${l.x} ${l.y}`) +
    e
      .map((i, r) => {
        const s = e[r + 1],
          c = e[r - 1] || l,
          u = s && qD(s, i, c)
        if (!s || u) return `L${i.x} ${i.y}`
        const d = Math.min(Cm(c, i), Cm(s, i)),
          v = d / 2 < t ? d / 2 : t,
          g = xm(c, i, v),
          h = xm(s, i, v)
        return `L${g.x} ${g.y}S${i.x} ${i.y} ${h.x} ${h.y}`
      })
      .join('') +
    (n ? `L${o.x} ${a - l.x + 2} Z` : '')
  )
}
function Di(e) {
  return parseInt(e, 10)
}
function qD(e, t, n) {
  return Di(e.x + n.x) === Di(2 * t.x) && Di(e.y + n.y) === Di(2 * t.y)
}
function Cm(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2))
}
function xm(e, t, n) {
  const a = { x: e.x - t.x, y: e.y - t.y },
    l = Math.sqrt(a.x * a.x + a.y * a.y),
    o = { x: a.x / l, y: a.y / l }
  return { x: t.x + o.x * n, y: t.y + o.y * n }
}
const lS = $({ fill: Boolean, ...nS() }, 'VTrendline'),
  _m = J()({
    name: 'VTrendline',
    props: lS(),
    setup(e, t) {
      let { slots: n } = t
      const a = Rt(),
        l = C(() => e.id || `trendline-${a}`),
        o = C(() => Number(e.autoDrawDuration) || (e.fill ? 500 : 2e3)),
        i = ae(0),
        r = ae(null)
      function s(m, b) {
        const { minX: y, maxX: p, minY: S, maxY: k } = b
        m.length === 1 && (m = [m[0], m[0]])
        const _ = m.length,
          P = e.max != null ? Number(e.max) : Math.max(...m),
          A = e.min != null ? Number(e.min) : Math.min(...m),
          D = (p - y) / (_ - 1),
          E = (k - S) / (P - A || 1)
        return m.map((R, V) => ({ x: y + V * D, y: k - (R - A) * E, value: R }))
      }
      const c = C(() => !!(e.showLabels || e.labels.length > 0 || n?.label)),
        u = C(() => parseFloat(e.lineWidth) || 4),
        d = C(() => Number(e.width)),
        f = C(() => {
          const m = Number(e.padding)
          return { minX: m, maxX: d.value - m, minY: m, maxY: parseInt(e.height, 10) - m }
        }),
        v = C(() => e.modelValue.map((m) => st(m, e.itemValue, m))),
        g = C(() => {
          const m = [],
            b = s(v.value, f.value),
            y = b.length
          for (let p = 0; m.length < y; p++) {
            const S = b[p]
            let k = e.labels[p]
            ;(k || (k = typeof S == 'object' ? S.value : S), m.push({ x: S.x, value: String(k) }))
          }
          return m
        })
      ue(
        () => e.modelValue,
        async () => {
          if ((await Re(), !e.autoDraw || !r.value || On())) return
          const m = r.value,
            b = m.getTotalLength()
          ;(e.fill
            ? ((m.style.transformOrigin = 'bottom center'),
              (m.style.transition = 'none'),
              (m.style.transform = 'scaleY(0)'),
              m.getBoundingClientRect(),
              (m.style.transition = `transform ${o.value}ms ${e.autoDrawEasing}`),
              (m.style.transform = 'scaleY(1)'))
            : ((m.style.strokeDasharray = `${b}`),
              (m.style.strokeDashoffset = `${b}`),
              m.getBoundingClientRect(),
              (m.style.transition = `stroke-dashoffset ${o.value}ms ${e.autoDrawEasing}`),
              (m.style.strokeDashoffset = '0')),
            (i.value = b))
        },
        { immediate: !0 }
      )
      function h(m) {
        const b = typeof e.smooth == 'boolean' ? (e.smooth ? 8 : 0) : Number(e.smooth)
        return YD(s(v.value, f.value), b, m, parseInt(e.height, 10))
      }
      ne(() => {
        const m = e.gradient.slice().length ? e.gradient.slice().reverse() : ['']
        return x('svg', { display: 'block', 'stroke-width': parseFloat(e.lineWidth) ?? 4 }, [
          x('defs', null, [
            x(
              'linearGradient',
              {
                id: l.value,
                gradientUnits: 'userSpaceOnUse',
                x1: e.gradientDirection === 'left' ? '100%' : '0',
                y1: e.gradientDirection === 'top' ? '100%' : '0',
                x2: e.gradientDirection === 'right' ? '100%' : '0',
                y2: e.gradientDirection === 'bottom' ? '100%' : '0',
              },
              [
                m.map((b, y) =>
                  x(
                    'stop',
                    { offset: y / Math.max(m.length - 1, 1), 'stop-color': b || 'currentColor' },
                    null
                  )
                ),
              ]
            ),
          ]),
          c.value &&
            x(
              'g',
              {
                key: 'labels',
                style: {
                  textAnchor: 'middle',
                  dominantBaseline: 'mathematical',
                  fill: 'currentColor',
                },
              },
              [
                g.value.map((b, y) =>
                  x(
                    'text',
                    {
                      x: b.x + u.value / 2 + u.value / 2,
                      y: parseInt(e.height, 10) - 4 + (parseInt(e.labelSize, 10) || 7 * 0.75),
                      'font-size': Number(e.labelSize) || 7,
                    },
                    [n.label?.({ index: y, value: b.value }) ?? b.value]
                  )
                ),
              ]
            ),
          x(
            'path',
            {
              ref: r,
              d: h(e.fill),
              fill: e.fill ? `url(#${l.value})` : 'none',
              stroke: e.fill ? 'none' : `url(#${l.value})`,
            },
            null
          ),
          e.fill && x('path', { d: h(!1), fill: 'none', stroke: e.color ?? e.gradient?.[0] }, null),
        ])
      })
    },
  }),
  XD = $({ type: { type: String, default: 'trend' }, ...aS(), ...lS() }, 'VSparkline'),
  ZD = J()({
    name: 'VSparkline',
    props: XD(),
    setup(e, t) {
      let { slots: n } = t
      const { textColorClasses: a, textColorStyles: l } = Vt(() => e.color),
        o = C(() => !!(e.showLabels || e.labels.length > 0 || n?.label)),
        i = C(() => {
          let r = parseInt(e.height, 10)
          return (o.value && (r += parseInt(e.labelSize, 10) * 1.5), r)
        })
      ne(() => {
        const r = e.type === 'trend' ? _m : km,
          s = e.type === 'trend' ? _m.filterProps(e) : km.filterProps(e)
        return w(
          r,
          Z(
            {
              key: e.type,
              class: a.value,
              style: l.value,
              viewBox: `0 0 ${e.width} ${parseInt(i.value, 10)}`,
            },
            s
          ),
          n
        )
      })
    },
  }),
  JD = $(
    {
      ...be(),
      ...Rb({
        offset: 8,
        minWidth: 0,
        openDelay: 0,
        closeDelay: 100,
        location: 'top center',
        transition: 'scale-transition',
      }),
    },
    'VSpeedDial'
  ),
  QD = J()({
    name: 'VSpeedDial',
    props: JD(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = we(e, 'modelValue'),
        l = ae(),
        o = C(() => {
          const [r, s = 'center'] = e.location?.split(' ') ?? []
          return `${r} ${s}`
        }),
        i = C(() => ({ [`v-speed-dial__content--${o.value.replace(' ', '-')}`]: !0 }))
      return (
        ne(() => {
          const r = Kl.filterProps(e)
          return w(
            Kl,
            Z(r, {
              modelValue: a.value,
              'onUpdate:modelValue': (s) => (a.value = s),
              class: e.class,
              style: e.style,
              contentClass: ['v-speed-dial__content', i.value, e.contentClass],
              location: o.value,
              ref: l,
              transition: 'fade-transition',
            }),
            {
              ...n,
              default: (s) =>
                w(
                  Ae,
                  { defaults: { VBtn: { size: 'small' } } },
                  {
                    default: () => [
                      w(
                        $t,
                        { appear: !0, group: !0, transition: e.transition },
                        { default: () => [n.default?.(s)] }
                      ),
                    ],
                  }
                ),
            }
          )
        }),
        {}
      )
    },
  }),
  Kd = Symbol.for('vuetify:v-stepper'),
  oS = $(
    {
      color: String,
      disabled: { type: [Boolean, String], default: !1 },
      prevText: { type: String, default: '$vuetify.stepper.prev' },
      nextText: { type: String, default: '$vuetify.stepper.next' },
    },
    'VStepperActions'
  ),
  iS = J()({
    name: 'VStepperActions',
    props: oS(),
    emits: { 'click:prev': () => !0, 'click:next': () => !0 },
    setup(e, t) {
      let { emit: n, slots: a } = t
      const { t: l } = ze()
      function o() {
        n('click:prev')
      }
      function i() {
        n('click:next')
      }
      return (
        ne(() => {
          const r = { onClick: o },
            s = { onClick: i }
          return x('div', { class: 'v-stepper-actions' }, [
            w(
              Ae,
              {
                defaults: {
                  VBtn: {
                    disabled: ['prev', !0].includes(e.disabled),
                    text: l(e.prevText),
                    variant: 'text',
                  },
                },
              },
              { default: () => [a.prev?.({ props: r }) ?? w(Me, r, null)] }
            ),
            w(
              Ae,
              {
                defaults: {
                  VBtn: {
                    color: e.color,
                    disabled: ['next', !0].includes(e.disabled),
                    text: l(e.nextText),
                    variant: 'tonal',
                  },
                },
              },
              { default: () => [a.next?.({ props: s }) ?? w(Me, s, null)] }
            ),
          ])
        }),
        {}
      )
    },
  }),
  rS = da('v-stepper-header'),
  eR = $(
    {
      color: String,
      title: String,
      subtitle: String,
      complete: Boolean,
      completeIcon: { type: Se, default: '$complete' },
      editable: Boolean,
      editIcon: { type: Se, default: '$edit' },
      error: Boolean,
      errorIcon: { type: Se, default: '$error' },
      icon: Se,
      ripple: { type: [Boolean, Object], default: !0 },
      rules: { type: Array, default: () => [] },
    },
    'StepperItem'
  ),
  tR = $({ ...eR(), ...dl() }, 'VStepperItem'),
  sS = J()({
    name: 'VStepperItem',
    directives: { vRipple: Nt },
    props: tR(),
    emits: { 'group:selected': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = fl(e, Kd, !0),
        l = C(() => a?.value.value ?? e.value),
        o = C(() => e.rules.every((f) => f() === !0)),
        i = C(() => !e.disabled && e.editable),
        r = C(() => !e.disabled && e.editable),
        s = C(() => e.error || !o.value),
        c = C(() => e.complete || (e.rules.length > 0 && o.value)),
        u = C(() =>
          s.value
            ? e.errorIcon
            : c.value
              ? e.completeIcon
              : a.isSelected.value && e.editable
                ? e.editIcon
                : e.icon
        ),
        d = C(() => ({
          canEdit: r.value,
          hasError: s.value,
          hasCompleted: c.value,
          title: e.title,
          subtitle: e.subtitle,
          step: l.value,
          value: e.value,
        }))
      return (
        ne(() => {
          const f = (!a || a.isSelected.value || c.value || r.value) && !s.value && !e.disabled,
            v = !!(e.title != null || n.title),
            g = !!(e.subtitle != null || n.subtitle)
          function h() {
            a?.toggle()
          }
          return tt(
            x(
              'button',
              {
                class: ee([
                  'v-stepper-item',
                  {
                    'v-stepper-item--complete': c.value,
                    'v-stepper-item--disabled': e.disabled,
                    'v-stepper-item--error': s.value,
                  },
                  a?.selectedClass.value,
                ]),
                disabled: !e.editable,
                type: 'button',
                onClick: h,
              },
              [
                i.value && Ta(!0, 'v-stepper-item'),
                w(
                  sn,
                  {
                    key: 'stepper-avatar',
                    class: 'v-stepper-item__avatar',
                    color: f ? e.color : void 0,
                    size: 24,
                  },
                  {
                    default: () => [
                      n.icon?.(d.value) ?? (u.value ? w(Le, { icon: u.value }, null) : l.value),
                    ],
                  }
                ),
                x('div', { class: 'v-stepper-item__content' }, [
                  v &&
                    x('div', { key: 'title', class: 'v-stepper-item__title' }, [
                      n.title?.(d.value) ?? e.title,
                    ]),
                  g &&
                    x('div', { key: 'subtitle', class: 'v-stepper-item__subtitle' }, [
                      n.subtitle?.(d.value) ?? e.subtitle,
                    ]),
                  n.default?.(d.value),
                ]),
              ]
            ),
            [[Nt, e.editable && e.ripple, null]]
          )
        }),
        {}
      )
    },
  }),
  nR = $(
    { ...je(Kr(), ['continuous', 'nextIcon', 'prevIcon', 'showArrows', 'touch', 'mandatory']) },
    'VStepperWindow'
  ),
  uS = J()({
    name: 'VStepperWindow',
    props: nR(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = Ve(Kd, null),
        l = we(e, 'modelValue'),
        o = C({
          get() {
            return l.value != null || !a
              ? l.value
              : a.items.value.find((i) => a.selected.value.includes(i.id))?.value
          },
          set(i) {
            l.value = i
          },
        })
      return (
        ne(() => {
          const i = Qa.filterProps(e)
          return w(
            Qa,
            Z({ _as: 'VStepperWindow' }, i, {
              modelValue: o.value,
              'onUpdate:modelValue': (r) => (o.value = r),
              class: ['v-stepper-window', e.class],
              style: e.style,
              mandatory: !1,
              touch: !1,
            }),
            n
          )
        }),
        {}
      )
    },
  }),
  aR = $({ ...Gr() }, 'VStepperWindowItem'),
  cS = J()({
    name: 'VStepperWindowItem',
    props: aR(),
    setup(e, t) {
      let { slots: n } = t
      return (
        ne(() => {
          const a = el.filterProps(e)
          return w(
            el,
            Z({ _as: 'VStepperWindowItem' }, a, {
              class: ['v-stepper-window-item', e.class],
              style: e.style,
            }),
            n
          )
        }),
        {}
      )
    },
  }),
  lR = $(
    {
      altLabels: Boolean,
      bgColor: String,
      completeIcon: Se,
      editIcon: Se,
      editable: Boolean,
      errorIcon: Se,
      hideActions: Boolean,
      items: { type: Array, default: () => [] },
      itemTitle: { type: String, default: 'title' },
      itemValue: { type: String, default: 'value' },
      nonLinear: Boolean,
      flat: Boolean,
      ...ol(),
    },
    'Stepper'
  ),
  oR = $(
    {
      ...lR(),
      ...cl({ mandatory: 'force', selectedClass: 'v-stepper-item--selected' }),
      ...Ad(),
      ...Zt(oS(), ['prevText', 'nextText']),
    },
    'VStepper'
  ),
  iR = J()({
    name: 'VStepper',
    props: oR(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const { items: a, next: l, prev: o, selected: i } = Aa(e, Kd),
        { displayClasses: r, mobile: s } = gn(e),
        {
          completeIcon: c,
          editIcon: u,
          errorIcon: d,
          color: f,
          editable: v,
          prevText: g,
          nextText: h,
        } = Yl(e),
        m = C(() =>
          e.items.map((p, S) => {
            const k = st(p, e.itemTitle, p),
              _ = st(p, e.itemValue, S + 1)
            return { title: k, value: _, raw: p }
          })
        ),
        b = C(() => a.value.findIndex((p) => i.value.includes(p.id))),
        y = C(() =>
          e.disabled
            ? e.disabled
            : b.value === 0
              ? 'prev'
              : b.value === a.value.length - 1
                ? 'next'
                : !1
        )
      return (
        lt({
          VStepperItem: {
            editable: v,
            errorIcon: d,
            completeIcon: c,
            editIcon: u,
            prevText: g,
            nextText: h,
          },
          VStepperActions: { color: f, disabled: y, prevText: g, nextText: h },
        }),
        ne(() => {
          const p = Ko.filterProps(e),
            S = !!(n.header || e.items.length),
            k = e.items.length > 0,
            _ = !e.hideActions && !!(k || n.actions)
          return w(
            Ko,
            Z(p, {
              color: e.bgColor,
              class: [
                'v-stepper',
                {
                  'v-stepper--alt-labels': e.altLabels,
                  'v-stepper--flat': e.flat,
                  'v-stepper--non-linear': e.nonLinear,
                  'v-stepper--mobile': s.value,
                },
                r.value,
                e.class,
              ],
              style: e.style,
            }),
            {
              default: () => [
                S &&
                  w(
                    rS,
                    { key: 'stepper-header' },
                    {
                      default: () => [
                        m.value.map((P, A) => {
                          let { raw: D, ...E } = P
                          return x(he, null, [
                            !!A && w(rn, null, null),
                            w(sS, E, {
                              default: n[`header-item.${E.value}`] ?? n.header,
                              icon: n.icon,
                              title: n.title,
                              subtitle: n.subtitle,
                            }),
                          ])
                        }),
                      ],
                    }
                  ),
                k &&
                  w(
                    uS,
                    { key: 'stepper-window' },
                    {
                      default: () => [
                        m.value.map((P) =>
                          w(
                            cS,
                            { value: P.value },
                            { default: () => n[`item.${P.value}`]?.(P) ?? n.item?.(P) }
                          )
                        ),
                      ],
                    }
                  ),
                n.default?.({ prev: o, next: l }),
                _ &&
                  (n.actions?.({ next: l, prev: o }) ??
                    w(iS, { key: 'stepper-actions', 'onClick:prev': o, 'onClick:next': l }, n)),
              ],
            }
          )
        }),
        { prev: o, next: l }
      )
    },
  }),
  rR = $(
    {
      indeterminate: Boolean,
      inset: Boolean,
      flat: Boolean,
      loading: { type: [Boolean, String], default: !1 },
      ...ma(),
      ...zr(),
    },
    'VSwitch'
  ),
  sR = J()({
    name: 'VSwitch',
    inheritAttrs: !1,
    props: rR(),
    emits: {
      'update:focused': (e) => !0,
      'update:modelValue': (e) => !0,
      'update:indeterminate': (e) => !0,
    },
    setup(e, t) {
      let { attrs: n, slots: a } = t
      const l = we(e, 'indeterminate'),
        o = we(e, 'modelValue'),
        { loaderClasses: i } = ii(e),
        { isFocused: r, focus: s, blur: c } = va(e),
        u = ae(),
        d = ae(),
        f = zc && window.matchMedia('(forced-colors: active)').matches,
        v = B(() => (typeof e.loading == 'string' && e.loading !== '' ? e.loading : e.color)),
        g = Rt(),
        h = B(() => e.id || `switch-${g}`)
      function m() {
        l.value && (l.value = !1)
      }
      function b(y) {
        ;(y.stopPropagation(), y.preventDefault(), u.value?.input?.click())
      }
      return (
        ne(() => {
          const [y, p] = Ia(n),
            S = Dt.filterProps(e),
            k = Pa.filterProps(e)
          return w(
            Dt,
            Z(
              {
                ref: d,
                class: [
                  'v-switch',
                  { 'v-switch--flat': e.flat },
                  { 'v-switch--inset': e.inset },
                  { 'v-switch--indeterminate': l.value },
                  i.value,
                  e.class,
                ],
              },
              y,
              S,
              {
                modelValue: o.value,
                'onUpdate:modelValue': (_) => (o.value = _),
                id: h.value,
                focused: r.value,
                style: e.style,
              }
            ),
            {
              ...a,
              default: (_) => {
                let { id: P, messagesId: A, isDisabled: D, isReadonly: E, isValid: R } = _
                const V = { model: o, isValid: R }
                return w(
                  Pa,
                  Z(
                    { ref: u },
                    k,
                    {
                      modelValue: o.value,
                      'onUpdate:modelValue': [(M) => (o.value = M), m],
                      id: P.value,
                      'aria-describedby': A.value,
                      type: 'checkbox',
                      'aria-checked': l.value ? 'mixed' : void 0,
                      disabled: D.value,
                      readonly: E.value,
                      onFocus: s,
                      onBlur: c,
                    },
                    p
                  ),
                  {
                    ...a,
                    default: (M) => {
                      let { backgroundColorClasses: F, backgroundColorStyles: G } = M
                      return x(
                        'div',
                        {
                          class: ee(['v-switch__track', f ? void 0 : F.value]),
                          style: ce(G.value),
                          onClick: b,
                        },
                        [
                          a['track-true'] &&
                            x('div', { key: 'prepend', class: 'v-switch__track-true' }, [
                              a['track-true'](V),
                            ]),
                          a['track-false'] &&
                            x('div', { key: 'append', class: 'v-switch__track-false' }, [
                              a['track-false'](V),
                            ]),
                        ]
                      )
                    },
                    input: (M) => {
                      let {
                        inputNode: F,
                        icon: G,
                        backgroundColorClasses: W,
                        backgroundColorStyles: te,
                      } = M
                      return x(he, null, [
                        F,
                        x(
                          'div',
                          {
                            class: ee([
                              'v-switch__thumb',
                              { 'v-switch__thumb--filled': G || e.loading },
                              e.inset || f ? void 0 : W.value,
                            ]),
                            style: ce(e.inset ? void 0 : te.value),
                          },
                          [
                            a.thumb
                              ? w(
                                  Ae,
                                  { defaults: { VIcon: { icon: G, size: 'x-small' } } },
                                  { default: () => [a.thumb({ ...V, icon: G })] }
                                )
                              : w(rd, null, {
                                  default: () => [
                                    e.loading
                                      ? w(
                                          ri,
                                          {
                                            name: 'v-switch',
                                            active: !0,
                                            color: R.value === !1 ? void 0 : v.value,
                                          },
                                          {
                                            default: (H) =>
                                              a.loader
                                                ? a.loader(H)
                                                : w(
                                                    Ja,
                                                    {
                                                      active: H.isActive,
                                                      color: H.color,
                                                      indeterminate: !0,
                                                      size: '16',
                                                      width: '2',
                                                    },
                                                    null
                                                  ),
                                          }
                                        )
                                      : G &&
                                        w(Le, { key: String(G), icon: G, size: 'x-small' }, null),
                                  ],
                                }),
                          ]
                        ),
                      ])
                    },
                  }
                )
              },
            }
          )
        }),
        _t({}, d)
      )
    },
  }),
  uR = $(
    {
      color: String,
      height: [Number, String],
      window: Boolean,
      ...be(),
      ...yt(),
      ...il(),
      ...Je(),
      ...Ie(),
      ...Be(),
    },
    'VSystemBar'
  ),
  cR = J()({
    name: 'VSystemBar',
    props: uR(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: a } = $e(e),
        { backgroundColorClasses: l, backgroundColorStyles: o } = He(() => e.color),
        { elevationClasses: i } = xt(e),
        { roundedClasses: r } = ot(e),
        { ssrBootStyles: s } = sl(),
        c = C(() => e.height ?? (e.window ? 32 : 24)),
        { layoutItemStyles: u } = rl({
          id: e.name,
          order: C(() => parseInt(e.order, 10)),
          position: oe('top'),
          layoutSize: c,
          elementSize: c,
          active: C(() => !0),
          absolute: B(() => e.absolute),
        })
      return (
        ne(() =>
          w(
            e.tag,
            {
              class: ee([
                'v-system-bar',
                { 'v-system-bar--window': e.window },
                a.value,
                l.value,
                i.value,
                r.value,
                e.class,
              ]),
              style: ce([o.value, u.value, s.value, e.style]),
            },
            n
          )
        ),
        {}
      )
    },
  }),
  Gd = Symbol.for('vuetify:v-tabs'),
  dS = $(
    {
      fixed: Boolean,
      sliderColor: String,
      hideSlider: Boolean,
      direction: { type: String, default: 'horizontal' },
      ...je(jr({ selectedClass: 'v-tab--selected', variant: 'text' }), [
        'active',
        'block',
        'flat',
        'location',
        'position',
        'symbol',
      ]),
    },
    'VTab'
  ),
  fS = J()({
    name: 'VTab',
    props: dS(),
    setup(e, t) {
      let { slots: n, attrs: a } = t
      const { textColorClasses: l, textColorStyles: o } = Vt(() => e.sliderColor),
        i = ae(),
        r = ae(),
        s = C(() => e.direction === 'horizontal'),
        c = C(() => i.value?.group?.isSelected.value ?? !1)
      function u(d) {
        let { value: f } = d
        if (f) {
          const v = i.value?.$el.parentElement?.querySelector('.v-tab--selected .v-tab__slider'),
            g = r.value
          if (!v || !g) return
          const h = getComputedStyle(v).color,
            m = v.getBoundingClientRect(),
            b = g.getBoundingClientRect(),
            y = s.value ? 'x' : 'y',
            p = s.value ? 'X' : 'Y',
            S = s.value ? 'right' : 'bottom',
            k = s.value ? 'width' : 'height',
            _ = m[y],
            P = b[y],
            A = _ > P ? m[S] - b[S] : m[y] - b[y],
            D =
              Math.sign(A) > 0
                ? s.value
                  ? 'right'
                  : 'bottom'
                : Math.sign(A) < 0
                  ? s.value
                    ? 'left'
                    : 'top'
                  : 'center',
            R = (Math.abs(A) + (Math.sign(A) < 0 ? m[k] : b[k])) / Math.max(m[k], b[k]) || 0,
            V = m[k] / b[k] || 0,
            M = 1.5
          Zn(
            g,
            {
              backgroundColor: [h, 'currentcolor'],
              transform: [
                `translate${p}(${A}px) scale${p}(${V})`,
                `translate${p}(${A / M}px) scale${p}(${(R - 1) / M + 1})`,
                'none',
              ],
              transformOrigin: Array(3).fill(D),
            },
            { duration: 225, easing: Mo }
          )
        }
      }
      return (
        ne(() => {
          const d = Me.filterProps(e)
          return w(
            Me,
            Z(
              {
                symbol: Gd,
                ref: i,
                class: ['v-tab', e.class],
                style: e.style,
                tabindex: c.value ? 0 : -1,
                role: 'tab',
                'aria-selected': String(c.value),
                active: !1,
              },
              d,
              a,
              { block: e.fixed, maxWidth: e.fixed ? 300 : void 0, 'onGroup:selected': u }
            ),
            {
              ...n,
              default: () =>
                x(he, null, [
                  n.default?.() ?? e.text,
                  !e.hideSlider &&
                    x(
                      'div',
                      { ref: r, class: ee(['v-tab__slider', l.value]), style: ce(o.value) },
                      null
                    ),
                ]),
            }
          )
        }),
        _t({}, i)
      )
    },
  }),
  dR = $(
    { ...je(Kr(), ['continuous', 'nextIcon', 'prevIcon', 'showArrows', 'touch', 'mandatory']) },
    'VTabsWindow'
  ),
  vS = J()({
    name: 'VTabsWindow',
    props: dR(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = Ve(Gd, null),
        l = we(e, 'modelValue'),
        o = C({
          get() {
            return l.value != null || !a
              ? l.value
              : a.items.value.find((i) => a.selected.value.includes(i.id))?.value
          },
          set(i) {
            l.value = i
          },
        })
      return (
        ne(() => {
          const i = Qa.filterProps(e)
          return w(
            Qa,
            Z({ _as: 'VTabsWindow' }, i, {
              modelValue: o.value,
              'onUpdate:modelValue': (r) => (o.value = r),
              class: ['v-tabs-window', e.class],
              style: e.style,
              mandatory: !1,
              touch: !1,
            }),
            n
          )
        }),
        {}
      )
    },
  }),
  fR = $({ ...Gr() }, 'VTabsWindowItem'),
  mS = J()({
    name: 'VTabsWindowItem',
    props: fR(),
    setup(e, t) {
      let { slots: n } = t
      return (
        ne(() => {
          const a = el.filterProps(e)
          return w(
            el,
            Z({ _as: 'VTabsWindowItem' }, a, {
              class: ['v-tabs-window-item', e.class],
              style: e.style,
            }),
            n
          )
        }),
        {}
      )
    },
  })
function vR(e) {
  return e ? e.map((t) => (Do(t) ? t : { text: t, value: t })) : []
}
const mR = $(
    {
      alignTabs: { type: String, default: 'start' },
      color: String,
      fixedTabs: Boolean,
      items: { type: Array, default: () => [] },
      stacked: Boolean,
      bgColor: String,
      grow: Boolean,
      height: { type: [Number, String], default: void 0 },
      hideSlider: Boolean,
      sliderColor: String,
      ...Zt(dS(), ['spaced']),
      ...vd({ mandatory: 'force', selectedClass: 'v-tab-item--selected' }),
      ...St(),
      ...Ie(),
    },
    'VTabs'
  ),
  hR = J()({
    name: 'VTabs',
    props: mR(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { attrs: n, slots: a } = t
      const l = we(e, 'modelValue'),
        o = C(() => vR(e.items)),
        { densityClasses: i } = Ht(e),
        { backgroundColorClasses: r, backgroundColorStyles: s } = He(() => e.bgColor),
        { scopeId: c } = ml()
      return (
        lt({
          VTab: {
            color: B(() => e.color),
            direction: B(() => e.direction),
            stacked: B(() => e.stacked),
            fixed: B(() => e.fixedTabs),
            sliderColor: B(() => e.sliderColor),
            hideSlider: B(() => e.hideSlider),
          },
        }),
        ne(() => {
          const u = zo.filterProps(e),
            d = !!(a.window || e.items.length > 0)
          return x(he, null, [
            w(
              zo,
              Z(
                u,
                {
                  modelValue: l.value,
                  'onUpdate:modelValue': (f) => (l.value = f),
                  class: [
                    'v-tabs',
                    `v-tabs--${e.direction}`,
                    `v-tabs--align-tabs-${e.alignTabs}`,
                    {
                      'v-tabs--fixed-tabs': e.fixedTabs,
                      'v-tabs--grow': e.grow,
                      'v-tabs--stacked': e.stacked,
                    },
                    i.value,
                    r.value,
                    e.class,
                  ],
                  style: [{ '--v-tabs-height': fe(e.height) }, s.value, e.style],
                  role: 'tablist',
                  symbol: Gd,
                },
                c,
                n
              ),
              {
                default: () => [
                  a.default?.() ??
                    o.value.map(
                      (f) =>
                        a.tab?.({ item: f }) ??
                        w(fS, Z(f, { key: f.text, value: f.value, spaced: e.spaced }), {
                          default: a[`tab.${f.value}`]
                            ? () => a[`tab.${f.value}`]?.({ item: f })
                            : void 0,
                        })
                    ),
                ],
              }
            ),
            d &&
              w(
                vS,
                Z(
                  {
                    modelValue: l.value,
                    'onUpdate:modelValue': (f) => (l.value = f),
                    key: 'tabs-window',
                  },
                  c
                ),
                {
                  default: () => [
                    o.value.map(
                      (f) =>
                        a.item?.({ item: f }) ??
                        w(
                          mS,
                          { value: f.value },
                          { default: () => a[`item.${f.value}`]?.({ item: f }) }
                        )
                    ),
                    a.window?.(),
                  ],
                }
              ),
          ])
        }),
        {}
      )
    },
  }),
  gR = $(
    {
      autoGrow: Boolean,
      autofocus: Boolean,
      counter: [Boolean, Number, String],
      counterValue: Function,
      prefix: String,
      placeholder: String,
      persistentPlaceholder: Boolean,
      persistentCounter: Boolean,
      noResize: Boolean,
      rows: { type: [Number, String], default: 5, validator: (e) => !isNaN(parseFloat(e)) },
      maxRows: { type: [Number, String], validator: (e) => !isNaN(parseFloat(e)) },
      suffix: String,
      modelModifiers: Object,
      ...Mb(),
      ...ma(),
      ...fi(),
    },
    'VTextarea'
  ),
  yR = J()({
    name: 'VTextarea',
    directives: { vIntersect: xn },
    inheritAttrs: !1,
    props: gR(),
    emits: {
      'click:control': (e) => !0,
      'mousedown:control': (e) => !0,
      'update:focused': (e) => !0,
      'update:modelValue': (e) => !0,
      'update:rows': (e) => !0,
    },
    setup(e, t) {
      let { attrs: n, emit: a, slots: l } = t
      const o = we(e, 'modelValue'),
        { isFocused: i, focus: r, blur: s } = va(e),
        { onIntersect: c } = Lb(e),
        u = C(() =>
          typeof e.counterValue == 'function'
            ? e.counterValue(o.value)
            : (o.value || '').toString().length
        ),
        d = C(() => {
          if (n.maxlength) return n.maxlength
          if (!(!e.counter || (typeof e.counter != 'number' && typeof e.counter != 'string')))
            return e.counter
        }),
        f = ae(),
        v = ae(),
        g = oe(''),
        h = ae(),
        m = Bb(e),
        b = C(() => e.persistentPlaceholder || i.value || e.active)
      function y() {
        ;(m.isSuppressing.value && m.update(),
          h.value !== document.activeElement && h.value?.focus(),
          i.value || r())
      }
      function p(V) {
        ;(y(), a('click:control', V))
      }
      function S(V) {
        a('mousedown:control', V)
      }
      function k(V) {
        ;(V.stopPropagation(),
          y(),
          Re(() => {
            ;((o.value = ''), ti(e['onClick:clear'], V))
          }))
      }
      function _(V) {
        const M = V.target
        if (((o.value = M.value), e.modelModifiers?.trim)) {
          const F = [M.selectionStart, M.selectionEnd]
          Re(() => {
            ;((M.selectionStart = F[0]), (M.selectionEnd = F[1]))
          })
        }
      }
      const P = ae(),
        A = ae(Number(e.rows)),
        D = C(() => ['plain', 'underlined'].includes(e.variant))
      qe(() => {
        e.autoGrow || (A.value = Number(e.rows))
      })
      function E() {
        e.autoGrow &&
          Re(() => {
            if (!P.value || !v.value) return
            const V = getComputedStyle(P.value),
              M = getComputedStyle(v.value.$el),
              F =
                parseFloat(V.getPropertyValue('--v-field-padding-top')) +
                parseFloat(V.getPropertyValue('--v-input-padding-top')) +
                parseFloat(V.getPropertyValue('--v-field-padding-bottom')),
              G = P.value.scrollHeight,
              W = parseFloat(V.lineHeight),
              te = Math.max(
                parseFloat(e.rows) * W + F,
                parseFloat(M.getPropertyValue('--v-input-control-height'))
              ),
              H = parseFloat(e.maxRows) * W + F || 1 / 0,
              O = Ge(G ?? 0, te, H)
            ;((A.value = Math.floor((O - F) / W)), (g.value = fe(O)))
          })
      }
      ;(pt(E),
        ue(o, E),
        ue(() => e.rows, E),
        ue(() => e.maxRows, E),
        ue(() => e.density, E),
        ue(A, (V) => {
          a('update:rows', V)
        }))
      let R
      return (
        ue(P, (V) => {
          V ? ((R = new ResizeObserver(E)), R.observe(P.value)) : R?.disconnect()
        }),
        dt(() => {
          R?.disconnect()
        }),
        ne(() => {
          const V = !!(l.counter || e.counter || e.counterValue),
            M = !!(V || l.details),
            [F, G] = Ia(n),
            { modelValue: W, ...te } = Dt.filterProps(e),
            H = { ...Va.filterProps(e), 'onClick:clear': k }
          return w(
            Dt,
            Z(
              {
                ref: f,
                modelValue: o.value,
                'onUpdate:modelValue': (O) => (o.value = O),
                class: [
                  'v-textarea v-text-field',
                  {
                    'v-textarea--prefixed': e.prefix,
                    'v-textarea--suffixed': e.suffix,
                    'v-text-field--prefixed': e.prefix,
                    'v-text-field--suffixed': e.suffix,
                    'v-textarea--auto-grow': e.autoGrow,
                    'v-textarea--no-resize': e.noResize || e.autoGrow,
                    'v-input--plain-underlined': D.value,
                  },
                  e.class,
                ],
                style: e.style,
              },
              F,
              te,
              { centerAffix: A.value === 1 && !D.value, focused: i.value }
            ),
            {
              ...l,
              default: (O) => {
                let {
                  id: j,
                  isDisabled: U,
                  isDirty: Y,
                  isReadonly: K,
                  isValid: se,
                  hasDetails: de,
                } = O
                return w(
                  Va,
                  Z(
                    {
                      ref: v,
                      style: { '--v-textarea-control-height': g.value },
                      onClick: p,
                      onMousedown: S,
                      'onClick:prependInner': e['onClick:prependInner'],
                      'onClick:appendInner': e['onClick:appendInner'],
                    },
                    H,
                    {
                      id: j.value,
                      active: b.value || Y.value,
                      centerAffix: A.value === 1 && !D.value,
                      dirty: Y.value || e.dirty,
                      disabled: U.value,
                      focused: i.value,
                      details: de.value,
                      error: se.value === !1,
                    }
                  ),
                  {
                    ...l,
                    default: (ye) => {
                      let {
                        props: { class: L, ...q },
                      } = ye
                      return x(he, null, [
                        e.prefix && x('span', { class: 'v-text-field__prefix' }, [e.prefix]),
                        tt(
                          x(
                            'textarea',
                            Z(
                              {
                                ref: h,
                                class: L,
                                value: o.value,
                                onInput: _,
                                autofocus: e.autofocus,
                                readonly: K.value,
                                disabled: U.value,
                                placeholder: e.placeholder,
                                rows: e.rows,
                                name: m.fieldName.value,
                                autocomplete: m.fieldAutocomplete.value,
                                onFocus: y,
                                onBlur: s,
                              },
                              q,
                              G
                            ),
                            null
                          ),
                          [[xn, { handler: c }, null, { once: !0 }]]
                        ),
                        e.autoGrow &&
                          tt(
                            x(
                              'textarea',
                              {
                                class: ee([L, 'v-textarea__sizer']),
                                id: `${q.id}-sizer`,
                                'onUpdate:modelValue': (le) => (o.value = le),
                                ref: P,
                                readonly: !0,
                                'aria-hidden': 'true',
                              },
                              null
                            ),
                            [[K0, o.value]]
                          ),
                        e.suffix && x('span', { class: 'v-text-field__suffix' }, [e.suffix]),
                      ])
                    },
                  }
                )
              },
              details: M
                ? (O) =>
                    x(he, null, [
                      l.details?.(O),
                      V &&
                        x(he, null, [
                          x('span', null, null),
                          w(
                            Wr,
                            {
                              active: e.persistentCounter || i.value,
                              value: u.value,
                              max: d.value,
                              disabled: e.disabled,
                            },
                            l.counter
                          ),
                        ]),
                    ])
                : void 0,
            }
          )
        }),
        _t({}, f, v, h)
      )
    },
  }),
  bR = $({ withBackground: Boolean, ...be(), ...Be(), ...Ie() }, 'VThemeProvider'),
  pR = J()({
    name: 'VThemeProvider',
    props: bR(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: a } = $e(e)
      return () =>
        e.withBackground
          ? w(
              e.tag,
              { class: ee(['v-theme-provider', a.value, e.class]), style: ce(e.style) },
              { default: () => [n.default?.()] }
            )
          : n.default?.()
    },
  }),
  SR = $(
    {
      dotColor: String,
      fillDot: Boolean,
      hideDot: Boolean,
      icon: Se,
      iconColor: String,
      lineColor: String,
      ...be(),
      ...Je(),
      ...Un(),
      ...yt(),
    },
    'VTimelineDivider'
  ),
  wR = J()({
    name: 'VTimelineDivider',
    props: SR(),
    setup(e, t) {
      let { slots: n } = t
      const { sizeClasses: a, sizeStyles: l } = Zl(e, 'v-timeline-divider__dot'),
        { backgroundColorStyles: o, backgroundColorClasses: i } = He(() => e.dotColor),
        { roundedClasses: r } = ot(e, 'v-timeline-divider__dot'),
        { elevationClasses: s } = xt(e),
        { backgroundColorClasses: c, backgroundColorStyles: u } = He(() => e.lineColor)
      return (
        ne(() =>
          x(
            'div',
            {
              class: ee([
                'v-timeline-divider',
                { 'v-timeline-divider--fill-dot': e.fillDot },
                e.class,
              ]),
              style: ce(e.style),
            },
            [
              x(
                'div',
                { class: ee(['v-timeline-divider__before', c.value]), style: ce(u.value) },
                null
              ),
              !e.hideDot &&
                x(
                  'div',
                  {
                    key: 'dot',
                    class: ee(['v-timeline-divider__dot', s.value, r.value, a.value]),
                    style: ce(l.value),
                  },
                  [
                    x(
                      'div',
                      {
                        class: ee(['v-timeline-divider__inner-dot', i.value, r.value]),
                        style: ce(o.value),
                      },
                      [
                        n.default
                          ? w(
                              Ae,
                              {
                                key: 'icon-defaults',
                                disabled: !e.icon,
                                defaults: {
                                  VIcon: { color: e.iconColor, icon: e.icon, size: e.size },
                                },
                              },
                              n.default
                            )
                          : w(
                              Le,
                              { key: 'icon', color: e.iconColor, icon: e.icon, size: e.size },
                              null
                            ),
                      ]
                    ),
                  ]
                ),
              x(
                'div',
                { class: ee(['v-timeline-divider__after', c.value]), style: ce(u.value) },
                null
              ),
            ]
          )
        ),
        {}
      )
    },
  }),
  hS = $(
    {
      density: String,
      dotColor: String,
      fillDot: Boolean,
      hideDot: Boolean,
      hideOpposite: { type: Boolean, default: void 0 },
      icon: Se,
      iconColor: String,
      lineInset: [Number, String],
      side: { type: String, validator: (e) => e == null || ['start', 'end'].includes(e) },
      ...be(),
      ...ft(),
      ...yt(),
      ...Je(),
      ...Un(),
      ...Ie(),
    },
    'VTimelineItem'
  ),
  kR = J()({
    name: 'VTimelineItem',
    props: hS(),
    setup(e, t) {
      let { slots: n } = t
      const { dimensionStyles: a } = vt(e),
        l = oe(0),
        o = ae()
      return (
        ue(
          o,
          (i) => {
            i &&
              (l.value =
                i.$el.querySelector('.v-timeline-divider__dot')?.getBoundingClientRect().width ?? 0)
          },
          { flush: 'post' }
        ),
        ne(() =>
          x(
            'div',
            {
              class: ee([
                'v-timeline-item',
                {
                  'v-timeline-item--fill-dot': e.fillDot,
                  'v-timeline-item--side-start': e.side === 'start',
                  'v-timeline-item--side-end': e.side === 'end',
                },
                e.class,
              ]),
              style: ce([
                {
                  '--v-timeline-dot-size': fe(l.value),
                  '--v-timeline-line-inset': e.lineInset
                    ? `calc(var(--v-timeline-dot-size) / 2 + ${fe(e.lineInset)})`
                    : fe(0),
                },
                e.style,
              ]),
            },
            [
              x('div', { class: 'v-timeline-item__body', style: ce(a.value) }, [n.default?.()]),
              w(
                wR,
                {
                  ref: o,
                  hideDot: e.hideDot,
                  icon: e.icon,
                  iconColor: e.iconColor,
                  size: e.size,
                  elevation: e.elevation,
                  dotColor: e.dotColor,
                  fillDot: e.fillDot,
                  rounded: e.rounded,
                },
                { default: n.icon }
              ),
              e.density !== 'compact' &&
                x('div', { class: 'v-timeline-item__opposite' }, [
                  !e.hideOpposite && n.opposite?.(),
                ]),
            ]
          )
        ),
        {}
      )
    },
  }),
  CR = $(
    {
      align: { type: String, default: 'center', validator: (e) => ['center', 'start'].includes(e) },
      direction: {
        type: String,
        default: 'vertical',
        validator: (e) => ['vertical', 'horizontal'].includes(e),
      },
      justify: { type: String, default: 'auto', validator: (e) => ['auto', 'center'].includes(e) },
      side: { type: String, validator: (e) => e == null || ['start', 'end'].includes(e) },
      lineThickness: { type: [String, Number], default: 2 },
      lineColor: String,
      truncateLine: { type: String, validator: (e) => ['start', 'end', 'both'].includes(e) },
      ...Zt(hS({ lineInset: 0 }), [
        'dotColor',
        'fillDot',
        'hideOpposite',
        'iconColor',
        'lineInset',
        'size',
      ]),
      ...be(),
      ...St(),
      ...Ie(),
      ...Be(),
    },
    'VTimeline'
  ),
  xR = J()({
    name: 'VTimeline',
    props: CR(),
    setup(e, t) {
      let { slots: n } = t
      const { themeClasses: a } = $e(e),
        { densityClasses: l } = Ht(e),
        { rtlClasses: o } = gt()
      lt({
        VTimelineDivider: { lineColor: B(() => e.lineColor) },
        VTimelineItem: {
          density: B(() => e.density),
          dotColor: B(() => e.dotColor),
          fillDot: B(() => e.fillDot),
          hideOpposite: B(() => e.hideOpposite),
          iconColor: B(() => e.iconColor),
          lineColor: B(() => e.lineColor),
          lineInset: B(() => e.lineInset),
          size: B(() => e.size),
        },
      })
      const i = C(() => {
          const s = e.side ? e.side : e.density !== 'default' ? 'end' : null
          return s && `v-timeline--side-${s}`
        }),
        r = C(() => {
          const s = ['v-timeline--truncate-line-start', 'v-timeline--truncate-line-end']
          switch (e.truncateLine) {
            case 'both':
              return s
            case 'start':
              return s[0]
            case 'end':
              return s[1]
            default:
              return null
          }
        })
      return (
        ne(() =>
          w(
            e.tag,
            {
              class: ee([
                'v-timeline',
                `v-timeline--${e.direction}`,
                `v-timeline--align-${e.align}`,
                `v-timeline--justify-${e.justify}`,
                r.value,
                { 'v-timeline--inset-line': !!e.lineInset },
                a.value,
                l.value,
                i.value,
                o.value,
                e.class,
              ]),
              style: ce([{ '--v-timeline-line-thickness': fe(e.lineThickness) }, e.style]),
            },
            n
          )
        ),
        {}
      )
    },
  })
function Fa(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2
  return String(e).padStart(t, '0')
}
const _R = $(
    {
      allowedValues: Function,
      ampm: Boolean,
      color: String,
      disabled: Boolean,
      displayedValue: null,
      double: Boolean,
      format: { type: Function, default: (e) => e },
      max: { type: Number, required: !0 },
      min: { type: Number, required: !0 },
      scrollable: Boolean,
      readonly: Boolean,
      rotate: { type: Number, default: 0 },
      step: { type: Number, default: 1 },
      modelValue: { type: Number },
    },
    'VTimePickerClock'
  ),
  ac = J()({
    name: 'VTimePickerClock',
    props: _R(),
    emits: { change: (e) => !0, input: (e) => !0 },
    setup(e, t) {
      let { emit: n } = t
      const a = ae(null),
        l = ae(null),
        o = ae(void 0),
        i = ae(!1),
        r = ae(null),
        s = ae(null),
        c = Jg((O) => n('change', O), 750),
        { textColorClasses: u, textColorStyles: d } = Vt(() => e.color),
        { backgroundColorClasses: f, backgroundColorStyles: v } = He(() => e.color),
        g = C(() => e.max - e.min + 1),
        h = C(() => (e.double ? g.value / 2 : g.value)),
        m = C(() => 360 / h.value),
        b = C(() => (m.value * Math.PI) / 180),
        y = C(() => (e.modelValue == null ? e.min : e.modelValue)),
        p = C(() => 0.62),
        S = C(() => {
          const O = []
          for (let j = e.min; j <= e.max; j = j + e.step) O.push(j)
          return O
        })
      ue(
        () => e.modelValue,
        (O) => {
          o.value = O
        }
      )
      function k(O) {
        ;(o.value !== O && (o.value = O), n('input', O))
      }
      function _(O) {
        return !e.allowedValues || e.allowedValues(O)
      }
      function P(O) {
        if (!e.scrollable || e.disabled) return
        O.preventDefault()
        const j = Math.sign(-O.deltaY || 1)
        let U = y.value
        do ((U = U + j), (U = ((U - e.min + g.value) % g.value) + e.min))
        while (!_(U) && U !== y.value)
        ;(U !== e.displayedValue && k(U), c(U))
      }
      function A(O) {
        return e.double && O - e.min >= h.value
      }
      function D(O) {
        return A(O) ? p.value : 1
      }
      function E(O) {
        const j = (e.rotate * Math.PI) / 180
        return {
          x: Math.sin((O - e.min) * b.value + j) * D(O),
          y: -Math.cos((O - e.min) * b.value + j) * D(O),
        }
      }
      function R(O, j) {
        const U = ((Math.round(O / m.value) + (j ? h.value : 0)) % g.value) + e.min
        return O < 360 - m.value / 2 ? U : j ? e.max - h.value + 1 : e.min
      }
      function V(O) {
        const { x: j, y: U } = E(O)
        return { left: `${Math.round(50 + j * 50)}%`, top: `${Math.round(50 + U * 50)}%` }
      }
      function M(O, j) {
        const U = j.x - O.x,
          Y = j.y - O.y
        return Math.sqrt(U * U + Y * Y)
      }
      function F(O, j) {
        const U = 2 * Math.atan2(j.y - O.y - M(O, j), j.x - O.x)
        return Math.abs((U * 180) / Math.PI)
      }
      function G(O) {
        ;(r.value === null && (r.value = O), (s.value = O), k(O))
      }
      function W(O) {
        if ((O.preventDefault(), (!i.value && O.type !== 'click') || !a.value)) return
        const { width: j, top: U, left: Y } = a.value?.getBoundingClientRect(),
          { width: K } = l.value?.getBoundingClientRect() ?? { width: 0 },
          { clientX: se, clientY: de } = 'touches' in O ? O.touches[0] : O,
          ye = { x: j / 2, y: -j / 2 },
          L = { x: se - Y, y: U - de },
          q = Math.round(F(ye, L) - e.rotate + 360) % 360,
          le = e.double && M(ye, L) < (K + K * p.value) / 4,
          ie = Math.ceil(15 / m.value)
        let Ce
        for (let pe = 0; pe < ie; pe++)
          if (((Ce = R(q + pe * m.value, le)), _(Ce) || ((Ce = R(q - pe * m.value, le)), _(Ce))))
            return G(Ce)
      }
      function te(O) {
        e.disabled ||
          (O.preventDefault(),
          window.addEventListener('mousemove', W),
          window.addEventListener('touchmove', W),
          window.addEventListener('mouseup', H),
          window.addEventListener('touchend', H),
          (r.value = null),
          (s.value = null),
          (i.value = !0),
          W(O))
      }
      function H(O) {
        ;(O.stopPropagation(),
          window.removeEventListener('mousemove', W),
          window.removeEventListener('touchmove', W),
          window.removeEventListener('mouseup', H),
          window.removeEventListener('touchend', H),
          (i.value = !1),
          s.value !== null && _(s.value) && n('change', s.value))
      }
      ne(() =>
        x(
          'div',
          {
            class: ee([
              {
                'v-time-picker-clock': !0,
                'v-time-picker-clock--indeterminate': e.modelValue == null,
                'v-time-picker-clock--readonly': e.readonly,
              },
            ]),
            onMousedown: te,
            onTouchstart: te,
            onWheel: P,
            ref: a,
          },
          [
            x('div', { class: 'v-time-picker-clock__inner', ref: l }, [
              x(
                'div',
                {
                  class: ee([
                    {
                      'v-time-picker-clock__hand': !0,
                      'v-time-picker-clock__hand--inner': A(e.modelValue),
                    },
                    u.value,
                  ]),
                  style: ce([
                    {
                      transform: `rotate(${e.rotate + m.value * (y.value - e.min)}deg) scaleY(${D(y.value)})`,
                    },
                    d.value,
                  ]),
                },
                null
              ),
              S.value.map((O) => {
                const j = O === y.value
                return x(
                  'div',
                  {
                    class: ee([
                      {
                        'v-time-picker-clock__item': !0,
                        'v-time-picker-clock__item--active': j,
                        'v-time-picker-clock__item--disabled': e.disabled || !_(O),
                      },
                      j && f.value,
                    ]),
                    style: ce([V(O), j && v.value]),
                  },
                  [x('span', null, [e.format(O)])]
                )
              }),
            ]),
          ]
        )
      )
    },
  }),
  PR = $(
    {
      ampm: Boolean,
      color: String,
      disabled: Boolean,
      hour: Number,
      minute: Number,
      second: Number,
      period: String,
      readonly: Boolean,
      useSeconds: Boolean,
      value: Number,
      viewMode: String,
    },
    'VTimePickerControls'
  ),
  lc = J()({
    name: 'VTimePickerControls',
    props: PR(),
    emits: { 'update:period': (e) => !0, 'update:viewMode': (e) => !0 },
    setup(e, t) {
      let { emit: n, slots: a } = t
      const { t: l } = ze()
      return (
        ne(() => {
          let o = e.hour
          return (
            e.ampm && (o = o ? ((o - 1) % 12) + 1 : 12),
            x('div', { class: 'v-time-picker-controls' }, [
              x(
                'div',
                {
                  class: ee({
                    'v-time-picker-controls__time': !0,
                    'v-time-picker-controls__time--with-seconds': e.useSeconds,
                  }),
                },
                [
                  w(
                    Me,
                    {
                      active: e.viewMode === 'hour',
                      color: e.viewMode === 'hour' ? e.color : void 0,
                      disabled: e.disabled,
                      variant: 'tonal',
                      class: ee({
                        'v-time-picker-controls__time__btn': !0,
                        'v-time-picker-controls__time--with-ampm__btn': e.ampm,
                        'v-time-picker-controls__time--with-seconds__btn': e.useSeconds,
                      }),
                      text: e.hour == null ? '--' : Fa(`${o}`),
                      onClick: () => n('update:viewMode', 'hour'),
                    },
                    null
                  ),
                  x(
                    'span',
                    {
                      class: ee([
                        'v-time-picker-controls__time__separator',
                        { 'v-time-picker-controls--with-seconds__time__separator': e.useSeconds },
                      ]),
                    },
                    [qt(':')]
                  ),
                  w(
                    Me,
                    {
                      active: e.viewMode === 'minute',
                      color: e.viewMode === 'minute' ? e.color : void 0,
                      class: ee({
                        'v-time-picker-controls__time__btn': !0,
                        'v-time-picker-controls__time__btn__active': e.viewMode === 'minute',
                        'v-time-picker-controls__time--with-ampm__btn': e.ampm,
                        'v-time-picker-controls__time--with-seconds__btn': e.useSeconds,
                      }),
                      disabled: e.disabled,
                      variant: 'tonal',
                      text: e.minute == null ? '--' : Fa(e.minute),
                      onClick: () => n('update:viewMode', 'minute'),
                    },
                    null
                  ),
                  e.useSeconds &&
                    x(
                      'span',
                      {
                        class: ee([
                          'v-time-picker-controls__time__separator',
                          { 'v-time-picker-controls--with-seconds__time__separator': e.useSeconds },
                        ]),
                        key: 'secondsDivider',
                      },
                      [qt(':')]
                    ),
                  e.useSeconds &&
                    w(
                      Me,
                      {
                        key: 'secondsVal',
                        active: e.viewMode === 'second',
                        color: e.viewMode === 'second' ? e.color : void 0,
                        variant: 'tonal',
                        onClick: () => n('update:viewMode', 'second'),
                        class: ee({
                          'v-time-picker-controls__time__btn': !0,
                          'v-time-picker-controls__time__btn__active': e.viewMode === 'second',
                          'v-time-picker-controls__time--with-seconds__btn': e.useSeconds,
                        }),
                        disabled: e.disabled,
                        text: e.second == null ? '--' : Fa(e.second),
                      },
                      null
                    ),
                  e.ampm &&
                    x('div', { class: 'v-time-picker-controls__ampm' }, [
                      w(
                        Me,
                        {
                          active: e.period === 'am',
                          color: e.period === 'am' ? e.color : void 0,
                          class: ee({
                            'v-time-picker-controls__ampm__am': !0,
                            'v-time-picker-controls__ampm__btn': !0,
                            'v-time-picker-controls__ampm__btn__active': e.period === 'am',
                          }),
                          disabled: e.disabled,
                          text: l('$vuetify.timePicker.am'),
                          variant: e.disabled && e.period === 'am' ? 'elevated' : 'tonal',
                          onClick: () => (e.period !== 'am' ? n('update:period', 'am') : null),
                        },
                        null
                      ),
                      w(
                        Me,
                        {
                          active: e.period === 'pm',
                          color: e.period === 'pm' ? e.color : void 0,
                          class: ee({
                            'v-time-picker-controls__ampm__pm': !0,
                            'v-time-picker-controls__ampm__btn': !0,
                            'v-time-picker-controls__ampm__btn__active': e.period === 'pm',
                          }),
                          disabled: e.disabled,
                          text: l('$vuetify.timePicker.pm'),
                          variant: e.disabled && e.period === 'pm' ? 'elevated' : 'tonal',
                          onClick: () => (e.period !== 'pm' ? n('update:period', 'pm') : null),
                        },
                        null
                      ),
                    ]),
                ]
              ),
            ])
          )
        }),
        {}
      )
    },
  }),
  VR = ln(24),
  gS = ln(12),
  IR = gS.map((e) => e + 12)
ln(60)
const TR = $(
    {
      allowedHours: [Function, Array],
      allowedMinutes: [Function, Array],
      allowedSeconds: [Function, Array],
      disabled: Boolean,
      format: { type: String, default: 'ampm' },
      max: String,
      min: String,
      viewMode: { type: String, default: 'hour' },
      period: { type: String, default: 'am', validator: (e) => ['am', 'pm'].includes(e) },
      modelValue: null,
      readonly: Boolean,
      scrollable: Boolean,
      useSeconds: Boolean,
      ...je(Yr({ title: '$vuetify.timePicker.title' }), ['landscape']),
    },
    'VTimePicker'
  ),
  AR = J()({
    name: 'VTimePicker',
    props: TR(),
    emits: {
      'update:hour': (e) => !0,
      'update:minute': (e) => !0,
      'update:period': (e) => !0,
      'update:second': (e) => !0,
      'update:modelValue': (e) => !0,
      'update:viewMode': (e) => !0,
    },
    setup(e, t) {
      let { emit: n, slots: a } = t
      const { t: l } = ze(),
        o = ae(null),
        i = ae(null),
        r = ae(null),
        s = ae(null),
        c = ae(null),
        u = ae(null),
        d = we(e, 'period', 'am'),
        f = we(e, 'viewMode', 'hour'),
        v = ae(null),
        g = ae(null),
        h = C(() => {
          let V
          if (
            (e.allowedHours instanceof Array
              ? (V = (G) => e.allowedHours.includes(G))
              : (V = e.allowedHours),
            !e.min && !e.max)
          )
            return V
          const M = e.min ? Number(e.min.split(':')[0]) : 0,
            F = e.max ? Number(e.max.split(':')[0]) : 23
          return (G) => G >= Number(M) && G <= Number(F) && (!V || V(G))
        }),
        m = C(() => {
          let V
          const M = !h.value || o.value === null || h.value(o.value)
          if (
            (e.allowedMinutes instanceof Array
              ? (V = (j) => e.allowedMinutes.includes(j))
              : (V = e.allowedMinutes),
            !e.min && !e.max)
          )
            return M ? V : () => !1
          const [F, G] = e.min ? e.min.split(':').map(Number) : [0, 0],
            [W, te] = e.max ? e.max.split(':').map(Number) : [23, 59],
            H = F * 60 + Number(G),
            O = W * 60 + Number(te)
          return (j) => {
            const U = 60 * o.value + j
            return U >= H && U <= O && M && (!V || V(j))
          }
        }),
        b = C(() => {
          let V
          const F =
            (!h.value || o.value === null || h.value(o.value)) &&
            (!m.value || i.value === null || m.value(i.value))
          if (
            (e.allowedSeconds instanceof Array
              ? (V = (K) => e.allowedSeconds.includes(K))
              : (V = e.allowedSeconds),
            !e.min && !e.max)
          )
            return F ? V : () => !1
          const [G, W, te] = e.min ? e.min.split(':').map(Number) : [0, 0, 0],
            [H, O, j] = e.max ? e.max.split(':').map(Number) : [23, 59, 59],
            U = G * 3600 + W * 60 + Number(te || 0),
            Y = H * 3600 + O * 60 + Number(j || 0)
          return (K) => {
            const se = 3600 * o.value + 60 * i.value + K
            return se >= U && se <= Y && F && (!V || V(K))
          }
        }),
        y = C(() => e.format === 'ampm')
      ;(ue(
        () => e.period,
        (V) => D(V)
      ),
        ue(
          () => e.modelValue,
          (V) => P(V)
        ),
        pt(() => {
          P(e.modelValue)
        }))
      function p() {
        return o.value != null && i.value != null && (!e.useSeconds || r.value != null)
          ? `${Fa(o.value)}:${Fa(i.value)}` + (e.useSeconds ? `:${Fa(r.value)}` : '')
          : null
      }
      function S() {
        const V = p()
        V !== null && n('update:modelValue', V)
      }
      function k(V) {
        return V ? ((V - 1) % 12) + 1 : 12
      }
      function _(V, M) {
        return (V % 12) + (M === 'pm' ? 12 : 0)
      }
      function P(V) {
        if (V == null || V === '') ((o.value = null), (i.value = null), (r.value = null))
        else if (V instanceof Date)
          ((o.value = V.getHours()), (i.value = V.getMinutes()), (r.value = V.getSeconds()))
        else {
          const [M, , F, , G, W] =
            V.trim()
              .toLowerCase()
              .match(/^(\d+):(\d+)(:(\d+))?([ap]m)?$/) || new Array(6)
          ;((o.value = W ? _(parseInt(M, 10), W) : parseInt(M, 10)),
            (i.value = parseInt(F, 10)),
            (r.value = parseInt(G || 0, 10)))
        }
        d.value = o.value == null || o.value < 12 ? 'am' : 'pm'
      }
      function A(V, M) {
        const F = h.value
        if (!F) return M
        const G = y.value ? (M < 12 ? gS : IR) : VR
        return (((G.find((te) => F(((te + M) % G.length) + G[0])) || 0) + M) % G.length) + G[0]
      }
      function D(V) {
        if (((d.value = V), o.value != null)) {
          const M = o.value + (d.value === 'am' ? -12 : 12)
          o.value = A('hour', M)
        }
        return (n('update:period', V), S(), !0)
      }
      function E(V) {
        f.value === 'hour'
          ? (o.value = y.value ? _(V, d.value) : V)
          : f.value === 'minute'
            ? (i.value = V)
            : (r.value = V)
      }
      function R(V) {
        switch (f.value || 'hour') {
          case 'hour':
            n('update:hour', V)
            break
          case 'minute':
            n('update:minute', V)
            break
          case 'second':
            n('update:second', V)
            break
        }
        const M = o.value !== null && i.value !== null && (e.useSeconds ? r.value !== null : !0)
        ;(f.value === 'hour'
          ? (f.value = 'minute')
          : e.useSeconds && f.value === 'minute' && (f.value = 'second'),
          !(
            (o.value === s.value &&
              i.value === c.value &&
              (!e.useSeconds || r.value === u.value)) ||
            p() === null
          ) &&
            ((s.value = o.value),
            (c.value = i.value),
            e.useSeconds && (u.value = r.value),
            M && S()))
      }
      ne(() => {
        const V = Gl.filterProps(e),
          M = lc.filterProps(e),
          F = ac.filterProps(je(e, ['format', 'modelValue', 'min', 'max']))
        return w(Gl, Z(V, { color: void 0, class: ['v-time-picker', e.class], style: e.style }), {
          title: () => a.title?.() ?? x('div', { class: 'v-time-picker__title' }, [l(e.title)]),
          header: () =>
            w(
              lc,
              Z(M, {
                ampm: y.value,
                hour: o.value,
                minute: i.value,
                period: d.value,
                second: r.value,
                viewMode: f.value,
                'onUpdate:period': (G) => D(G),
                'onUpdate:viewMode': (G) => (f.value = G),
                ref: v,
              }),
              null
            ),
          default: () =>
            w(
              ac,
              Z(F, {
                allowedValues:
                  f.value === 'hour' ? h.value : f.value === 'minute' ? m.value : b.value,
                double: f.value === 'hour' && !y.value,
                format: f.value === 'hour' ? (y.value ? k : (G) => G) : (G) => Fa(G, 2),
                max: f.value === 'hour' ? (y.value && d.value === 'am' ? 11 : 23) : 59,
                min: f.value === 'hour' && y.value && d.value === 'pm' ? 12 : 0,
                size: 20,
                step: f.value === 'hour' ? 1 : 5,
                modelValue: f.value === 'hour' ? o.value : f.value === 'minute' ? i.value : r.value,
                onChange: R,
                onInput: E,
                ref: g,
              }),
              null
            ),
          actions: a.actions,
        })
      })
    },
  }),
  ER = $({ ...be(), ...yn({ variant: 'text' }) }, 'VToolbarItems'),
  DR = J()({
    name: 'VToolbarItems',
    props: ER(),
    setup(e, t) {
      let { slots: n } = t
      return (
        lt({ VBtn: { color: B(() => e.color), height: 'inherit', variant: B(() => e.variant) } }),
        ne(() =>
          x('div', { class: ee(['v-toolbar-items', e.class]), style: ce(e.style) }, [n.default?.()])
        ),
        {}
      )
    },
  }),
  RR = $(
    {
      id: String,
      interactive: Boolean,
      text: String,
      ...je(
        di({
          closeOnBack: !1,
          location: 'end',
          locationStrategy: 'connected',
          eager: !0,
          minWidth: 0,
          offset: 10,
          openOnClick: !1,
          openOnHover: !0,
          origin: 'auto',
          scrim: !1,
          scrollStrategy: 'reposition',
          transition: null,
        }),
        ['absolute', 'persistent']
      ),
    },
    'VTooltip'
  ),
  yS = J()({
    name: 'VTooltip',
    props: RR(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = we(e, 'modelValue'),
        { scopeId: l } = ml(),
        o = Rt(),
        i = B(() => e.id || `v-tooltip-${o}`),
        r = ae(),
        s = C(() => (e.location.split(' ').length > 1 ? e.location : e.location + ' center')),
        c = C(() =>
          e.origin === 'auto' ||
          e.origin === 'overlap' ||
          e.origin.split(' ').length > 1 ||
          e.location.split(' ').length > 1
            ? e.origin
            : e.origin + ' center'
        ),
        u = B(() =>
          e.transition != null ? e.transition : a.value ? 'scale-transition' : 'fade-transition'
        ),
        d = C(() => Z({ 'aria-describedby': i.value }, e.activatorProps))
      return (
        ne(() => {
          const f = Nn.filterProps(e)
          return w(
            Nn,
            Z(
              {
                ref: r,
                class: ['v-tooltip', { 'v-tooltip--interactive': e.interactive }, e.class],
                style: e.style,
                id: i.value,
              },
              f,
              {
                modelValue: a.value,
                'onUpdate:modelValue': (v) => (a.value = v),
                transition: u.value,
                absolute: !0,
                location: s.value,
                origin: c.value,
                persistent: !0,
                role: 'tooltip',
                activatorProps: d.value,
                _disableGlobalStack: !0,
              },
              l
            ),
            {
              activator: n.activator,
              default: function () {
                for (var v = arguments.length, g = new Array(v), h = 0; h < v; h++)
                  g[h] = arguments[h]
                return n.default?.(...g) ?? e.text
              },
            }
          )
        }),
        _t({}, r)
      )
    },
  }),
  MR = $(
    {
      ...je(gb({ collapseIcon: '$treeviewCollapse', expandIcon: '$treeviewExpand' }), ['subgroup']),
    },
    'VTreeviewGroup'
  ),
  oc = J()({
    name: 'VTreeviewGroup',
    props: MR(),
    setup(e, t) {
      let { slots: n } = t
      const a = ae(),
        l = C(() => (a.value?.isOpen ? e.collapseIcon : e.expandIcon)),
        o = C(() => ({
          VTreeviewItem: { prependIcon: void 0, appendIcon: void 0, toggleIcon: l.value },
        }))
      return (
        ne(() => {
          const i = Uo.filterProps(e)
          return w(Uo, Z(i, { ref: a, class: ['v-treeview-group', e.class], subgroup: !0 }), {
            ...n,
            activator: n.activator
              ? (r) =>
                  x(he, null, [w(Ae, { defaults: o.value }, { default: () => [n.activator?.(r)] })])
              : void 0,
          })
        }),
        {}
      )
    },
  }),
  bS = Symbol.for('vuetify:v-treeview'),
  pS = $(
    {
      loading: Boolean,
      hideActions: Boolean,
      hasCustomPrepend: Boolean,
      indentLines: Array,
      toggleIcon: Se,
      ...pb({ slim: !0 }),
    },
    'VTreeviewItem'
  ),
  ic = J()({
    name: 'VTreeviewItem',
    props: pS(),
    emits: { toggleExpand: (e) => !0 },
    setup(e, t) {
      let { slots: n, emit: a } = t
      const l = Ve(bS, { visibleIds: ae() }).visibleIds,
        o = ae(),
        i = C(() => o.value?.root.activatable.value && o.value?.isGroupActivator),
        r = C(() => o.value?.link.isClickable.value || (e.value != null && !!o.value?.list)),
        s = C(() => !e.disabled && e.link !== !1 && (e.link || r.value || i.value)),
        c = C(() => l.value && !l.value.has(_e(o.value?.id)))
      function u(f) {
        s.value && i.value && o.value?.activate(!o.value?.isActivated, f)
      }
      function d(f) {
        ;(f.preventDefault(), f.stopPropagation(), a('toggleExpand', f))
      }
      return (
        ne(() => {
          const f = _n.filterProps(e),
            v = n.prepend || e.toggleIcon || e.indentLines || e.prependIcon || e.prependAvatar
          return w(
            _n,
            Z({ ref: o }, f, {
              active: o.value?.isActivated || void 0,
              class: [
                'v-treeview-item',
                {
                  'v-treeview-item--activatable-group-activator': i.value,
                  'v-treeview-item--filtered': c.value,
                },
                e.class,
              ],
              ripple: !1,
              onClick: u,
            }),
            {
              ...n,
              prepend: v
                ? (g) =>
                    x(he, null, [
                      e.indentLines && e.indentLines.length > 0
                        ? x(
                            'div',
                            {
                              key: 'indent-lines',
                              class: 'v-treeview-indent-lines',
                              style: { '--v-indent-parts': e.indentLines.length },
                            },
                            [
                              e.indentLines.map((h) =>
                                x(
                                  'div',
                                  {
                                    class: ee(
                                      `v-treeview-indent-line v-treeview-indent-line--${h}`
                                    ),
                                  },
                                  null
                                )
                              ),
                            ]
                          )
                        : '',
                      !e.hideActions &&
                        w(
                          yd,
                          { start: !0 },
                          {
                            default: () => [
                              e.toggleIcon
                                ? x(he, null, [
                                    n.toggle
                                      ? w(
                                          Ae,
                                          {
                                            key: 'prepend-defaults',
                                            defaults: {
                                              VBtn: {
                                                density: 'compact',
                                                icon: e.toggleIcon,
                                                variant: 'text',
                                                loading: e.loading,
                                              },
                                              VProgressCircular: {
                                                indeterminate: 'disable-shrink',
                                                size: 20,
                                                width: 2,
                                              },
                                            },
                                          },
                                          {
                                            default: () => [
                                              n.toggle({
                                                ...g,
                                                loading: e.loading,
                                                props: { onClick: d },
                                              }),
                                            ],
                                          }
                                        )
                                      : w(
                                          Me,
                                          {
                                            key: 'prepend-toggle',
                                            density: 'compact',
                                            icon: e.toggleIcon,
                                            loading: e.loading,
                                            variant: 'text',
                                            onClick: d,
                                          },
                                          {
                                            loader: () =>
                                              w(
                                                Ja,
                                                {
                                                  indeterminate: 'disable-shrink',
                                                  size: '20',
                                                  width: '2',
                                                },
                                                null
                                              ),
                                          }
                                        ),
                                  ])
                                : x('div', { class: 'v-treeview-item__level' }, null),
                            ],
                          }
                        ),
                      e.hasCustomPrepend
                        ? w(
                            Ae,
                            {
                              key: 'prepend-defaults',
                              defaults: {
                                VAvatar: { density: e.density, image: e.appendAvatar },
                                VIcon: { density: e.density, icon: e.appendIcon },
                                VListItemAction: { start: !0 },
                              },
                            },
                            { default: () => [n.prepend?.(g)] }
                          )
                        : x(he, null, [
                            n.prepend?.(g),
                            e.prependAvatar &&
                              w(
                                sn,
                                {
                                  key: 'prepend-avatar',
                                  density: e.density,
                                  image: e.prependAvatar,
                                },
                                null
                              ),
                            e.prependIcon &&
                              w(
                                Le,
                                { key: 'prepend-icon', density: e.density, icon: e.prependIcon },
                                null
                              ),
                          ]),
                    ])
                : void 0,
            }
          )
        }),
        _t({}, o)
      )
    },
  }),
  SS = $(
    {
      fluid: Boolean,
      disabled: Boolean,
      loadChildren: Function,
      loadingIcon: { type: String, default: '$loading' },
      items: Array,
      openOnClick: { type: Boolean, default: void 0 },
      indeterminateIcon: { type: Se, default: '$checkboxIndeterminate' },
      falseIcon: Se,
      trueIcon: Se,
      returnObject: Boolean,
      activatable: Boolean,
      selectable: Boolean,
      selectedColor: String,
      selectStrategy: [String, Function, Object],
      index: Number,
      isLastGroup: Boolean,
      separateRoots: Boolean,
      parentIndentLines: Array,
      indentLinesVariant: String,
      path: { type: Array, default: () => [] },
      ...Zt(pS(), ['hideActions']),
      ...St(),
    },
    'VTreeviewChildren'
  ),
  br = J()({
    name: 'VTreeviewChildren',
    props: SS(),
    setup(e, t) {
      let { slots: n } = t
      const a = it(new Set()),
        l = ae([]),
        o = C(
          () =>
            !e.disabled && (e.openOnClick != null ? e.openOnClick : e.selectable && !e.activatable)
        )
      async function i(s) {
        try {
          if (!e.items?.length || !e.loadChildren) return
          s?.children?.length === 0 && (a.add(s.value), await e.loadChildren(s.raw))
        } finally {
          a.delete(s.value)
        }
      }
      function r(s, c) {
        e.selectable && s(c)
      }
      return () =>
        n.default?.() ??
        e.items?.map((s, c, u) => {
          const { children: d, props: f } = s,
            v = a.has(s.value),
            g = !!u.at(c + 1)?.children,
            h = e.path?.length ?? 0,
            m = u.length - 1 === c,
            b = {
              index: c,
              depth: h,
              isFirst: c === 0,
              isLast: m,
              path: [...e.path, c],
              hideAction: e.hideActions,
            },
            y = N1({
              depth: h,
              isLast: m,
              isLastGroup: e.isLastGroup,
              leafLinks: !e.hideActions && !e.fluid,
              separateRoots: e.separateRoots,
              parentIndentLines: e.parentIndentLines,
              variant: e.indentLinesVariant,
            }),
            p = {
              toggle: n.toggle
                ? (_) => n.toggle?.({ ..._, ...b, item: s.raw, internalItem: s, loading: v })
                : void 0,
              prepend: (_) =>
                x(he, null, [
                  e.selectable &&
                    (!d || (d && !['leaf', 'single-leaf'].includes(e.selectStrategy))) &&
                    w(
                      yd,
                      { start: !0 },
                      {
                        default: () => [
                          w(
                            Fn,
                            {
                              key: s.value,
                              modelValue: _.isSelected,
                              disabled: e.disabled,
                              loading: v,
                              color: e.selectedColor,
                              density: e.density,
                              indeterminate: _.isIndeterminate,
                              indeterminateIcon: e.indeterminateIcon,
                              falseIcon: e.falseIcon,
                              trueIcon: e.trueIcon,
                              'onUpdate:modelValue': (P) => r(_.select, P),
                              onClick: (P) => P.stopPropagation(),
                              onKeydown: (P) => {
                                ;['Enter', 'Space'].includes(P.key) &&
                                  (P.stopPropagation(), r(_.select, _.isSelected))
                              },
                            },
                            null
                          ),
                        ],
                      }
                    ),
                  n.prepend?.({ ..._, ...b, item: s.raw, internalItem: s }),
                ]),
              append: n.append
                ? (_) => n.append?.({ ..._, ...b, item: s.raw, internalItem: s })
                : void 0,
              title: n.title ? (_) => n.title?.({ ..._, item: s.raw, internalItem: s }) : void 0,
              subtitle: n.subtitle
                ? (_) => n.subtitle?.({ ..._, item: s.raw, internalItem: s })
                : void 0,
            },
            S = oc.filterProps(f),
            k = br.filterProps({ ...e, ...b })
          return d
            ? w(oc, Z(S, { value: e.returnObject ? s.raw : S?.value, rawId: S?.value }), {
                activator: (_) => {
                  let { props: P } = _
                  const A = {
                    ...f,
                    ...P,
                    value: f?.value,
                    onToggleExpand: [() => i(s), P.onClick],
                    onClick: o.value
                      ? [() => i(s), P.onClick]
                      : () => r(l.value[c]?.select, !l.value[c]?.isSelected),
                  }
                  return Ii(n.header, { props: A, item: s.raw, internalItem: s, loading: v }, () =>
                    w(
                      ic,
                      Z({ ref: (D) => (l.value[c] = D) }, A, {
                        hasCustomPrepend: !!n.prepend,
                        hideActions: e.hideActions,
                        indentLines: y.node,
                        value: e.returnObject ? s.raw : f.value,
                        loading: v,
                      }),
                      p
                    )
                  )
                },
                default: () =>
                  w(
                    br,
                    Z(k, {
                      items: d,
                      indentLinesVariant: e.indentLinesVariant,
                      parentIndentLines: y.children,
                      isLastGroup: g,
                      returnObject: e.returnObject,
                    }),
                    n
                  ),
              })
            : Ii(n.item, { props: f, item: s.raw, internalItem: s }, () =>
                s.type === 'divider'
                  ? Ii(n.divider, { props: s.raw }, () => w(rn, s.props, null))
                  : s.type === 'subheader'
                    ? Ii(n.subheader, { props: s.raw }, () => w(ao, s.props, null))
                    : w(
                        ic,
                        Z(f, {
                          hasCustomPrepend: !!n.prepend,
                          hideActions: e.hideActions,
                          indentLines: y.leaf,
                          value: e.returnObject ? _e(s.raw) : f.value,
                        }),
                        p
                      )
              )
        })
    },
  })
function wS(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []
  for (const n of e) (t.push(n), n.children && wS(n.children, t))
  return t
}
const BR = $(
    {
      openAll: Boolean,
      indentLines: [Boolean, String],
      search: String,
      ...lo({ filterKeys: ['title'] }),
      ...je(SS(), ['index', 'path', 'indentLinesVariant', 'parentIndentLines', 'isLastGroup']),
      ...je(_b({ collapseIcon: '$treeviewCollapse', expandIcon: '$treeviewExpand', slim: !0 }), [
        'nav',
        'openStrategy',
      ]),
      modelValue: Array,
    },
    'VTreeview'
  ),
  LR = J()({
    name: 'VTreeview',
    props: BR(),
    emits: {
      'update:opened': (e) => !0,
      'update:activated': (e) => !0,
      'update:selected': (e) => !0,
      'update:modelValue': (e) => !0,
      'click:open': (e) => !0,
      'click:select': (e) => !0,
    },
    setup(e, t) {
      let { slots: n, emit: a } = t
      const { items: l } = xb(e),
        o = B(() => e.activeColor),
        i = B(() => e.baseColor),
        r = B(() => e.color),
        s = we(e, 'activated'),
        c = we(e, 'selected'),
        u = C({
          get: () => e.modelValue ?? c.value,
          set(p) {
            ;((c.value = p), a('update:modelValue', p))
          },
        }),
        d = ae(),
        f = C(() => (e.openAll ? y(l.value) : e.opened)),
        v = C(() => wS(l.value)),
        g = B(() => e.search),
        { filteredItems: h } = oo(e, v, g),
        m = C(() => {
          if (!g.value) return null
          const p = d.value?.getPath
          return p
            ? new Set(
                h.value.flatMap((S) => {
                  const k = e.returnObject ? S.raw : S.props.value
                  return [...p(k), ...b(k)].map(_e)
                })
              )
            : null
        })
      function b(p) {
        const S = [],
          k = (d.value?.children.get(p) ?? []).slice()
        for (; k.length; ) {
          const _ = k.shift()
          _ && (S.push(_), k.push(...(d.value?.children.get(_) ?? []).slice()))
        }
        return S
      }
      function y(p) {
        let S = []
        for (const k of p)
          k.children &&
            (S.push(e.returnObject ? _e(k.raw) : k.value),
            k.children && (S = S.concat(y(k.children))))
        return S
      }
      return (
        Fe(bS, { visibleIds: m }),
        lt({
          VTreeviewGroup: {
            activeColor: o,
            baseColor: i,
            color: r,
            collapseIcon: B(() => e.collapseIcon),
            expandIcon: B(() => e.expandIcon),
          },
          VTreeviewItem: {
            activeClass: B(() => e.activeClass),
            activeColor: o,
            baseColor: i,
            color: r,
            density: B(() => e.density),
            disabled: B(() => e.disabled),
            lines: B(() => e.lines),
            variant: B(() => e.variant),
          },
        }),
        ne(() => {
          const p = Ul.filterProps(e),
            S = br.filterProps(e),
            k = typeof e.indentLines == 'boolean' ? 'default' : e.indentLines
          return w(
            Ul,
            Z({ ref: d }, p, {
              class: ['v-treeview', { 'v-treeview--fluid': e.fluid }, e.class],
              openStrategy: 'multiple',
              style: e.style,
              opened: f.value,
              activated: s.value,
              'onUpdate:activated': (_) => (s.value = _),
              selected: u.value,
              'onUpdate:selected': (_) => (u.value = _),
            }),
            {
              default: () => [
                w(
                  br,
                  Z(S, {
                    density: e.density,
                    returnObject: e.returnObject,
                    items: l.value,
                    parentIndentLines: e.indentLines ? [] : void 0,
                    indentLinesVariant: k,
                  }),
                  n
                ),
              ],
            }
          )
        }),
        {}
      )
    },
  }),
  OR = J()({
    name: 'VValidation',
    props: nb(),
    emits: { 'update:modelValue': (e) => !0 },
    setup(e, t) {
      let { slots: n } = t
      const a = ab(e, 'validation')
      return () => n.default?.(a)
    },
  }),
  $R = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        VAlert: JV,
        VAlertTitle: qy,
        VApp: od,
        VAppBar: CV,
        VAppBarNavIcon: KV,
        VAppBarTitle: GV,
        VAutocomplete: bT,
        VAvatar: sn,
        VBadge: ST,
        VBanner: CT,
        VBannerActions: Hb,
        VBannerText: jb,
        VBottomNavigation: _T,
        VBottomSheet: VT,
        VBreadcrumbs: ET,
        VBreadcrumbsDivider: Wb,
        VBreadcrumbsItem: Ub,
        VBtn: Me,
        VBtnGroup: Ru,
        VBtnToggle: TV,
        VCard: qb,
        VCardActions: Kb,
        VCardItem: Yb,
        VCardSubtitle: Gb,
        VCardText: Id,
        VCardTitle: Vd,
        VCarousel: UT,
        VCarouselItem: GT,
        VCheckbox: uI,
        VCheckboxBtn: Fn,
        VChip: no,
        VChipGroup: mI,
        VClassIcon: ad,
        VCode: YT,
        VCol: Bp,
        VColorPicker: LA,
        VCombobox: $A,
        VComponentIcon: Au,
        VConfirmEdit: NA,
        VContainer: Ep,
        VCounter: Wr,
        VDataIterator: XA,
        VDataTable: cE,
        VDataTableFooter: Go,
        VDataTableHeaders: tl,
        VDataTableRow: Nd,
        VDataTableRows: nl,
        VDataTableServer: mE,
        VDataTableVirtual: fE,
        VDatePicker: TE,
        VDatePickerControls: qu,
        VDatePickerHeader: Xu,
        VDatePickerMonth: Zu,
        VDatePickerMonths: Ju,
        VDatePickerYears: Qu,
        VDefaultsProvider: Ae,
        VDialog: Hu,
        VDialogBottomTransition: iV,
        VDialogTopTransition: rV,
        VDialogTransition: $r,
        VDivider: rn,
        VEmptyState: EE,
        VExpandTransition: Fr,
        VExpandXTransition: ud,
        VExpansionPanel: DE,
        VExpansionPanelText: ec,
        VExpansionPanelTitle: tc,
        VExpansionPanels: BE,
        VFab: OE,
        VFabTransition: oV,
        VFadeTransition: Fo,
        VField: Va,
        VFieldLabel: go,
        VFileInput: zE,
        VFooter: UE,
        VForm: GE,
        VHover: qE,
        VIcon: Le,
        VImg: oa,
        VInfiniteScroll: ZE,
        VInput: Dt,
        VItem: eD,
        VItemGroup: QE,
        VKbd: nD,
        VLabel: eo,
        VLayout: lD,
        VLayoutItem: iD,
        VLazy: sD,
        VLigatureIcon: jP,
        VList: Ul,
        VListGroup: Uo,
        VListImg: MI,
        VListItem: _n,
        VListItemAction: yd,
        VListItemMedia: OI,
        VListItemSubtitle: yb,
        VListItemTitle: bb,
        VListSubheader: ao,
        VLocaleProvider: cD,
        VMain: Ud,
        VMenu: Kl,
        VMessages: eb,
        VNavigationDrawer: SD,
        VNoSsr: wD,
        VNumberInput: PD,
        VOtpInput: ID,
        VOverlay: Nn,
        VPagination: Gu,
        VParallax: ED,
        VProgressCircular: Ja,
        VProgressLinear: Nr,
        VRadio: RD,
        VRadioGroup: BD,
        VRangeSlider: OD,
        VRating: FD,
        VResponsive: Eu,
        VRow: zp,
        VScaleTransition: rd,
        VScrollXReverseTransition: uV,
        VScrollXTransition: sV,
        VScrollYReverseTransition: dV,
        VScrollYTransition: cV,
        VSelect: Pd,
        VSelectionControl: Pa,
        VSelectionControlGroup: Zy,
        VSheet: Ko,
        VSkeletonLoader: zD,
        VSlideGroup: zo,
        VSlideGroupItem: WD,
        VSlideXReverseTransition: vV,
        VSlideXTransition: fV,
        VSlideYReverseTransition: mV,
        VSlideYTransition: sd,
        VSlider: Ku,
        VSnackbar: nc,
        VSnackbarQueue: GD,
        VSpacer: Wp,
        VSparkline: ZD,
        VSpeedDial: QD,
        VStepper: iR,
        VStepperActions: iS,
        VStepperHeader: rS,
        VStepperItem: sS,
        VStepperWindow: uS,
        VStepperWindowItem: cS,
        VSvgIcon: nd,
        VSwitch: sR,
        VSystemBar: cR,
        VTab: fS,
        VTable: al,
        VTabs: hR,
        VTabsWindow: vS,
        VTabsWindowItem: mS,
        VTextField: ia,
        VTextarea: yR,
        VThemeProvider: pR,
        VTimePicker: AR,
        VTimePickerClock: ac,
        VTimePickerControls: lc,
        VTimeline: xR,
        VTimelineItem: kR,
        VToolbar: Du,
        VToolbarItems: DR,
        VToolbarTitle: id,
        VTooltip: yS,
        VTreeview: LR,
        VTreeviewGroup: oc,
        VTreeviewItem: ic,
        VValidation: OR,
        VVirtualScroll: Ur,
        VWindow: Qa,
        VWindowItem: el,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  )
function FR(e, t) {
  const n = t.modifiers || {},
    a = t.value,
    { once: l, immediate: o, ...i } = n,
    r = !Object.keys(i).length,
    { handler: s, options: c } =
      typeof a == 'object'
        ? a
        : {
            handler: a,
            options: {
              attributes: i?.attr ?? r,
              characterData: i?.char ?? r,
              childList: i?.child ?? r,
              subtree: i?.sub ?? r,
            },
          },
    u = new MutationObserver(function () {
      let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
        f = arguments.length > 1 ? arguments[1] : void 0
      ;(s?.(d, f), l && kS(e, t))
    })
  ;(o && s?.([], u),
    (e._mutate = Object(e._mutate)),
    (e._mutate[t.instance.$.uid] = { observer: u }),
    u.observe(e, c))
}
function kS(e, t) {
  e._mutate?.[t.instance.$.uid] &&
    (e._mutate[t.instance.$.uid].observer.disconnect(), delete e._mutate[t.instance.$.uid])
}
const NR = { mounted: FR, unmounted: kS }
function HR(e, t) {
  const n = t.value,
    a = { passive: !t.modifiers?.active }
  ;(window.addEventListener('resize', n, a),
    (e._onResize = Object(e._onResize)),
    (e._onResize[t.instance.$.uid] = { handler: n, options: a }),
    t.modifiers?.quiet || n())
}
function jR(e, t) {
  if (!e._onResize?.[t.instance.$.uid]) return
  const { handler: n, options: a } = e._onResize[t.instance.$.uid]
  ;(window.removeEventListener('resize', n, a), delete e._onResize[t.instance.$.uid])
}
const zR = { mounted: HR, unmounted: jR }
function CS(e, t) {
  const { self: n = !1 } = t.modifiers ?? {},
    a = t.value,
    l = (typeof a == 'object' && a.options) || { passive: !0 },
    o = typeof a == 'function' || 'handleEvent' in a ? a : a.handler,
    i = n ? e : t.arg ? document.querySelector(t.arg) : window
  i &&
    (i.addEventListener('scroll', o, l),
    (e._onScroll = Object(e._onScroll)),
    (e._onScroll[t.instance.$.uid] = { handler: o, options: l, target: n ? void 0 : i }))
}
function xS(e, t) {
  if (!e._onScroll?.[t.instance.$.uid]) return
  const { handler: n, options: a, target: l = e } = e._onScroll[t.instance.$.uid]
  ;(l.removeEventListener('scroll', n, a), delete e._onScroll[t.instance.$.uid])
}
function WR(e, t) {
  t.value !== t.oldValue && (xS(e, t), CS(e, t))
}
const UR = { mounted: CS, unmounted: xS, updated: WR }
function KR(e, t) {
  const n = typeof e == 'string' ? Ks(e) : e,
    a = GR(n, t)
  return {
    mounted: a,
    updated: a,
    unmounted(l) {
      og(null, l)
    },
  }
}
function GR(e, t) {
  return function (n, a, l) {
    const o = typeof t == 'function' ? t(a) : t,
      i = a.value?.text ?? a.value ?? o?.text,
      r = Do(a.value) ? a.value : {},
      s = () => i ?? n.textContent,
      c =
        (l.ctx === a.instance.$ ? YR(l, a.instance.$)?.provides : l.ctx?.provides) ??
        a.instance.$.provides,
      u = ut(e, Z(o, r), s)
    ;((u.appContext = Object.assign(Object.create(null), a.instance.$.appContext, { provides: c })),
      og(u, n))
  }
}
function YR(e, t) {
  const n = new Set(),
    a = (o) => {
      for (const i of o) {
        if (!i) continue
        if (i === e || (i.el && e.el && i.el === e.el)) return !0
        n.add(i)
        let r
        if (
          (i.suspense
            ? (r = a([i.ssContent]))
            : Array.isArray(i.children)
              ? (r = a(i.children))
              : i.component?.vnode && (r = a([i.component?.subTree])),
          r)
        )
          return r
        n.delete(i)
      }
      return !1
    }
  if (!a([t.subTree])) return t
  const l = Array.from(n).reverse()
  for (const o of l) if (o.component) return o.component
  return t
}
const qR = KR(yS, (e) => ({
    activator: 'parent',
    location: e.arg?.replace('-', ' '),
    text: typeof e.value == 'boolean' ? void 0 : e.value,
  })),
  XR = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        ClickOutside: Nu,
        Intersect: xn,
        Mutate: NR,
        Resize: zR,
        Ripple: Nt,
        Scroll: UR,
        Tooltip: qR,
        Touch: yr,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  ZR = (...e) => e.find((t) => t !== void 0)
function JR(e) {
  const t = e.componentName || 'NuxtLink'
  function n(o) {
    return typeof o == 'string' && o.startsWith('#')
  }
  function a(o, i, r) {
    const s = r ?? e.trailingSlash
    if (!o || (s !== 'append' && s !== 'remove')) return o
    if (typeof o == 'string') return Ri(o, s)
    const c = 'path' in o && o.path !== void 0 ? o.path : i(o).path
    return { ...o, name: void 0, path: Ri(c, s) }
  }
  function l(o) {
    const i = Xt(),
      r = ei(),
      s = C(() => !!o.target && o.target !== '_self'),
      c = C(() => {
        const m = o.to || o.href || ''
        return typeof m == 'string' && ca(m, { acceptRelative: !0 })
      }),
      u = Ks('RouterLink'),
      d = u && typeof u != 'string' ? u.useLink : void 0,
      f = C(() => {
        if (o.external) return !0
        const m = o.to || o.href || ''
        return typeof m == 'object' ? !1 : m === '' || c.value
      }),
      v = C(() => {
        const m = o.to || o.href || ''
        return f.value ? m : a(m, i.resolve, o.trailingSlash)
      }),
      g = f.value ? void 0 : d?.({ ...o, to: v }),
      h = C(() => {
        const m = o.trailingSlash ?? e.trailingSlash
        if (!v.value || c.value || n(v.value)) return v.value
        if (f.value) {
          const b = typeof v.value == 'object' && 'path' in v.value ? cu(v.value) : v.value,
            y = typeof b == 'object' ? i.resolve(b).href : b
          return Ri(y, m)
        }
        return typeof v.value == 'object'
          ? (i.resolve(v.value)?.href ?? null)
          : Ri(Tr(r.app.baseURL, v.value), m)
      })
    return {
      to: v,
      hasTarget: s,
      isAbsoluteUrl: c,
      isExternal: f,
      href: h,
      isActive: g?.isActive ?? C(() => v.value === i.currentRoute.value.path),
      isExactActive: g?.isExactActive ?? C(() => v.value === i.currentRoute.value.path),
      route: g?.route ?? C(() => i.resolve(v.value)),
      async navigate(m) {
        await SC(h.value, { replace: o.replace, external: f.value || s.value })
      },
    }
  }
  return sa({
    name: t,
    props: {
      to: { type: [String, Object], default: void 0, required: !1 },
      href: { type: [String, Object], default: void 0, required: !1 },
      target: { type: String, default: void 0, required: !1 },
      rel: { type: String, default: void 0, required: !1 },
      noRel: { type: Boolean, default: void 0, required: !1 },
      prefetch: { type: Boolean, default: void 0, required: !1 },
      prefetchOn: { type: [String, Object], default: void 0, required: !1 },
      noPrefetch: { type: Boolean, default: void 0, required: !1 },
      activeClass: { type: String, default: void 0, required: !1 },
      exactActiveClass: { type: String, default: void 0, required: !1 },
      prefetchedClass: { type: String, default: void 0, required: !1 },
      replace: { type: Boolean, default: void 0, required: !1 },
      ariaCurrentValue: { type: String, default: void 0, required: !1 },
      external: { type: Boolean, default: void 0, required: !1 },
      custom: { type: Boolean, default: void 0, required: !1 },
      trailingSlash: { type: String, default: void 0, required: !1 },
    },
    useLink: l,
    setup(o, { slots: i }) {
      const r = Xt(),
        { to: s, href: c, navigate: u, isExternal: d, hasTarget: f, isAbsoluteUrl: v } = l(o),
        g = oe(!1),
        h = ae(null),
        m = (p) => {
          h.value = o.custom ? p?.$el?.nextElementSibling : p?.$el
        }
      function b(p) {
        return (
          !g.value &&
          (typeof o.prefetchOn == 'string'
            ? o.prefetchOn === p
            : (o.prefetchOn?.[p] ?? e.prefetchOn?.[p])) &&
          (o.prefetch ?? e.prefetch) !== !1 &&
          o.noPrefetch !== !0 &&
          o.target !== '_blank' &&
          !nM()
        )
      }
      async function y(p = ht()) {
        if (g.value) return
        g.value = !0
        const S =
            typeof s.value == 'string'
              ? s.value
              : d.value
                ? cu(s.value)
                : r.resolve(s.value).fullPath,
          k = d.value ? new URL(S, window.location.href).href : S
        await Promise.all([
          p.hooks.callHook('link:prefetch', k).catch(() => {}),
          !d.value && !f.value && Gg(s.value, r).catch(() => {}),
        ])
      }
      if (b('visibility')) {
        const p = ht()
        let S,
          k = null
        ;(pt(() => {
          const _ = eM()
          Mr(() => {
            S = pu(() => {
              h?.value?.tagName &&
                (k = _.observe(h.value, async () => {
                  ;(k?.(), (k = null), await y(p))
                }))
            })
          })
        }),
          dt(() => {
            ;(S && j_(S), k?.(), (k = null))
          }))
      }
      return () => {
        if (!d.value && !f.value && !n(s.value)) {
          const k = {
            ref: m,
            to: s.value,
            activeClass: o.activeClass || e.activeClass,
            exactActiveClass: o.exactActiveClass || e.exactActiveClass,
            replace: o.replace,
            ariaCurrentValue: o.ariaCurrentValue,
            custom: o.custom,
          }
          return (
            o.custom ||
              (b('interaction') &&
                ((k.onPointerenter = y.bind(null, void 0)), (k.onFocus = y.bind(null, void 0))),
              g.value && (k.class = o.prefetchedClass || e.prefetchedClass),
              (k.rel = o.rel || void 0)),
            ut(Ks('RouterLink'), k, i.default)
          )
        }
        const p = o.target || null,
          S =
            ZR(
              o.noRel ? '' : o.rel,
              e.externalRelAttribute,
              v.value || f.value ? 'noopener noreferrer' : ''
            ) || null
        return o.custom
          ? i.default
            ? i.default({
                href: c.value,
                navigate: u,
                prefetch: y,
                get route() {
                  if (!c.value) return
                  const k = new URL(c.value, window.location.href)
                  return {
                    path: k.pathname,
                    fullPath: k.pathname,
                    get query() {
                      return Dc(k.search)
                    },
                    hash: k.hash,
                    params: {},
                    name: void 0,
                    matched: [],
                    redirectedFrom: void 0,
                    meta: {},
                    href: c.value,
                  }
                },
                rel: S,
                target: p,
                isExternal: d.value || f.value,
                isActive: !1,
                isExactActive: !1,
              })
            : null
          : ut(
              'a',
              {
                ref: h,
                href: c.value || null,
                rel: S,
                target: p,
                onClick: (k) => {
                  if (!(d.value || f.value))
                    return (k.preventDefault(), o.replace ? r.replace(c.value) : r.push(c.value))
                },
              },
              i.default?.()
            )
      }
    },
  })
}
const QR = JR(nC)
function Ri(e, t) {
  const n = t === 'append' ? sg : $l
  return ca(e) && !e.startsWith('http') ? e : n(e, !0)
}
function eM() {
  const e = ht()
  if (e._observer) return e._observer
  let t = null
  const n = new Map(),
    a = (o, i) => (
      (t ||= new IntersectionObserver((r) => {
        for (const s of r) {
          const c = n.get(s.target)
          ;(s.isIntersecting || s.intersectionRatio > 0) && c && c()
        }
      })),
      n.set(o, i),
      t.observe(o),
      () => {
        ;(n.delete(o), t?.unobserve(o), n.size === 0 && (t?.disconnect(), (t = null)))
      }
    )
  return (e._observer = { observe: a })
}
const tM = /2g/
function nM() {
  const e = navigator.connection
  return !!(e && (e.saveData || tM.test(e.effectiveType)))
}
const aM = zn((e) => {
    const t = Ey({ components: $R, directives: XR })
    e.vueApp.use(t)
  }),
  lM = [yx, kx, H_, z_, W_, U_, G_, Y_, X_, aM],
  _S = (e = 'RouteProvider') =>
    sa({
      name: e,
      props: {
        route: { type: Object, required: !0 },
        vnode: Object,
        vnodeRef: Object,
        renderKey: String,
        trackRootNodes: Boolean,
      },
      setup(t) {
        const n = t.renderKey,
          a = t.route,
          l = {}
        for (const o in t.route)
          Object.defineProperty(l, o, {
            get: () => (n === t.renderKey ? t.route[o] : a[o]),
            enumerable: !0,
          })
        return (Fe(Ar, ea(l)), () => (t.vnode ? ut(t.vnode, { ref: t.vnodeRef }) : t.vnode))
      },
    }),
  oM = _S(),
  Pm = new WeakMap(),
  iM = sa({
    name: 'NuxtPage',
    inheritAttrs: !1,
    props: {
      name: { type: String },
      transition: { type: [Boolean, Object], default: void 0 },
      keepalive: { type: [Boolean, Object], default: void 0 },
      route: { type: Object },
      pageKey: { type: [Function, String], default: null },
    },
    setup(e, { attrs: t, slots: n, expose: a }) {
      const l = ht(),
        o = ae(),
        i = Ve(Ar, null)
      let r
      a({ pageRef: o })
      const s = Ve(bC, null)
      let c
      const u = l.deferHydration()
      if (l.isHydrating) {
        const f = l.hooks.hookOnce('app:error', u)
        Xt().beforeEach(f)
      }
      e.pageKey &&
        ue(
          () => e.pageKey,
          (f, v) => {
            f !== v && l.callHook('page:loading:start')
          }
        )
      let d = !1
      {
        const f = Xt().beforeResolve(() => {
          d = !1
        })
        dt(() => {
          f()
        })
      }
      return () =>
        ut(
          Ug,
          { name: e.name, route: e.route, ...t },
          {
            default: (f) => {
              const v = sM(i, f.route, f.Component),
                g = i && i.matched.length === f.route.matched.length
              if (!f.Component) {
                if (c && !g) return c
                u()
                return
              }
              if (c && s && !s.isCurrent(f.route)) return c
              if (v && i && (!s || s?.isCurrent(i))) return g ? c : null
              const h = yu(f, e.pageKey),
                m = uM(i, f.route, f.Component)
              ;(!l.isHydrating &&
                r === h &&
                !m &&
                Re(() => {
                  ;((d = !0), l.callHook('page:loading:end'))
                }),
                (r = h))
              const b = !!(e.transition ?? f.route.meta.pageTransition ?? Hf),
                y =
                  b &&
                  rM([
                    e.transition,
                    f.route.meta.pageTransition,
                    Hf,
                    {
                      onAfterLeave() {
                        ;(delete l._runningTransition,
                          l.callHook('page:transition:finish', f.Component))
                      },
                    },
                  ]),
                p = e.keepalive ?? f.route.meta.keepalive ?? tC
              return (
                (c = A_(
                  b && y,
                  T_(
                    p,
                    ut(
                      Nh,
                      {
                        suspensible: !0,
                        onPending: () => {
                          ;(b && (l._runningTransition = !0), l.callHook('page:start', f.Component))
                        },
                        onResolve: () => {
                          Re(() =>
                            l
                              .callHook('page:finish', f.Component)
                              .then(() => {
                                if ((delete l._runningTransition, !d && !m))
                                  return ((d = !0), l.callHook('page:loading:end'))
                              })
                              .finally(u)
                          )
                        },
                      },
                      {
                        default: () => {
                          const S = {
                            key: h || void 0,
                            vnode: n.default ? cM(n.default, f) : f.Component,
                            route: f.route,
                            renderKey: h || void 0,
                            trackRootNodes: b,
                            vnodeRef: o,
                          }
                          if (!p) return ut(oM, S)
                          const k = f.Component.type,
                            _ = k
                          let P = Pm.get(_)
                          return (P || ((P = _S(k.name || k.__name)), Pm.set(_, P)), ut(P, S))
                        },
                      }
                    )
                  )
                ).default()),
                c
              )
            },
          }
        )
    },
  })
function rM(e) {
  const t = []
  for (const n of e)
    n && t.push({ ...n, onAfterLeave: n.onAfterLeave ? Hc(n.onAfterLeave) : void 0 })
  return Cg(...t)
}
function sM(e, t, n) {
  if (!e) return !1
  const a = t.matched.findIndex((l) => l.components?.default === n?.type)
  return !a || a === -1
    ? !1
    : t.matched
        .slice(0, a)
        .some((l, o) => l.components?.default !== e.matched[o]?.components?.default) ||
        (n && yu({ route: t, Component: n }) !== yu({ route: e, Component: n }))
}
function uM(e, t, n) {
  return e
    ? t.matched.findIndex((l) => l.components?.default === n?.type) < t.matched.length - 1
    : !1
}
function cM(e, t) {
  const n = e(t)
  return n.length === 1 ? ut(n[0]) : ut(he, void 0, n)
}
const dM = sa({
    __name: 'app',
    setup(e) {
      return (t, n) => {
        const a = iM
        return (
          vn(),
          Dn(od, null, {
            default: tn(() => [
              w(Ud, { tag: 'main', role: 'main' }, { default: tn(() => [w(a)]), _: 1 }),
            ]),
            _: 1,
          })
        )
      }
    },
  }),
  fM = { class: 'text-h5 mb-4' },
  vM = sa({
    __name: 'error',
    props: { error: {} },
    setup(e) {
      const t = e,
        n = C(() => (t.error?.statusCode === 404 ? 'Seite nicht gefunden' : 'Fehler')),
        a = C(() => t.error?.message || 'Es ist ein unerwarteter Fehler aufgetreten.')
      return (
        sx({
          title: () => (t.error?.statusCode === 404 ? '404 – Seite nicht gefunden' : 'Fehler'),
        }),
        (l, o) => {
          const i = QR
          return (
            vn(),
            Dn(od, null, {
              default: tn(() => [
                w(
                  Ud,
                  { tag: 'main', role: 'main' },
                  {
                    default: tn(() => [
                      w(
                        Ep,
                        { class: 'py-8' },
                        {
                          default: tn(() => [
                            x('h1', fM, Bn(n.value), 1),
                            w(
                              zp,
                              { align: 'center', justify: 'center' },
                              {
                                default: tn(() => [
                                  w(
                                    Bp,
                                    { cols: '12', md: '8', lg: '6' },
                                    {
                                      default: tn(() => [
                                        w(
                                          qb,
                                          { variant: 'elevated' },
                                          {
                                            default: tn(() => [
                                              w(
                                                Vd,
                                                { class: 'text-h6' },
                                                { default: tn(() => [qt(Bn(a.value), 1)]), _: 1 }
                                              ),
                                              w(Id, null, {
                                                default: tn(() => [
                                                  o[1] ||
                                                    (o[1] = x(
                                                      'p',
                                                      { class: 'mb-4' },
                                                      'Bitte nutzen Sie den folgenden Link:',
                                                      -1
                                                    )),
                                                  w(
                                                    i,
                                                    {
                                                      to: '/',
                                                      'aria-label': 'Zur Startseite zurückkehren',
                                                    },
                                                    {
                                                      default: tn(() => [
                                                        ...(o[0] ||
                                                          (o[0] = [qt('Zur Startseite', -1)])),
                                                      ]),
                                                      _: 1,
                                                    }
                                                  ),
                                                ]),
                                                _: 1,
                                              }),
                                            ]),
                                            _: 1,
                                          }
                                        ),
                                      ]),
                                      _: 1,
                                    }
                                  ),
                                ]),
                                _: 1,
                              }
                            ),
                          ]),
                          _: 1,
                        }
                      ),
                    ]),
                    _: 1,
                  }
                ),
              ]),
              _: 1,
            })
          )
        }
      )
    },
  }),
  mM = (e, t) => {
    const n = e.__vccOpts || e
    for (const [a, l] of t) n[a] = l
    return n
  },
  hM = mM(vM, [['__scopeId', 'data-v-e6cc8b67']]),
  gM = { key: 0 },
  Vm = {
    __name: 'nuxt-root',
    setup(e) {
      const t = () => null,
        n = ht(),
        a = n.deferHydration()
      if (n.isHydrating) {
        const c = n.hooks.hookOnce('app:error', a)
        Xt().beforeEach(c)
      }
      const l = !1
      ;(Fe(Ar, _g()), n.hooks.callHookWith((c) => c.map((u) => u()), 'vue:setup'))
      const o = Er(),
        i = !1,
        r = /bot\b|chrome-lighthouse|facebookexternalhit|google\b/i
      bh((c, u, d) => {
        if (
          (n.hooks
            .callHook('vue:error', c, u, d)
            .catch((f) => console.error('[nuxt] Error in `vue:error` hook', f)),
          r.test(navigator.userAgent))
        )
          return (
            n.hooks.callHook('app:error', c),
            console.error(
              `[nuxt] Not rendering error page for bot with user agent \`${navigator.userAgent}\`:`,
              c
            ),
            !1
          )
        if (Vg(c) && (c.fatal || c.unhandled)) return (n.runWithContext(() => Oa(c)), !1)
      })
      const s = !1
      return (c, u) => (
        vn(),
        Dn(
          Nh,
          { onResolve: Ke(a) },
          {
            default: tn(() => [
              Ke(i)
                ? (vn(), s0('div', gM))
                : Ke(o)
                  ? (vn(), Dn(Ke(hM), { key: 1, error: Ke(o) }, null, 8, ['error']))
                  : Ke(s)
                    ? (vn(), Dn(Ke(t), { key: 2, context: Ke(s) }, null, 8, ['context']))
                    : Ke(l)
                      ? (vn(), Dn(wh(Ke(l)), { key: 3 }))
                      : (vn(), Dn(Ke(dM), { key: 4 })),
            ]),
            _: 1,
          },
          8,
          ['onResolve']
        )
      )
    },
  }
let Im
{
  let e
  ;((Im = async function () {
    if (e) return e
    const a = !!(
        window.__NUXT__?.serverRendered ??
        document.getElementById('__NUXT_DATA__')?.dataset.ssr === 'true'
      )
        ? Z0(Vm)
        : X0(Vm),
      l = rC({ vueApp: a })
    async function o(i) {
      ;(await l.callHook('app:error', i), (l.payload.error ||= za(i)))
    }
    ;((a.config.errorHandler = o),
      l.hook('app:suspense:resolve', () => {
        a.config.errorHandler === o && (a.config.errorHandler = void 0)
      }))
    try {
      await cC(l, lM)
    } catch (i) {
      o(i)
    }
    try {
      ;(await l.hooks.callHook('app:created', a),
        await l.hooks.callHook('app:beforeMount', a),
        a.mount(lC),
        await l.hooks.callHook('app:mounted', a),
        await Re())
    } catch (i) {
      o(i)
    }
    return a
  }),
    (e = Im().catch((t) => {
      throw (console.error('Error while mounting app:', t), t)
    })))
}
export {
  C as A,
  Ft as B,
  ht as C,
  wM as D,
  jn as E,
  he as F,
  Xl as G,
  xc as H,
  Ve as I,
  ue as J,
  bt as K,
  oe as L,
  B as M,
  Re as N,
  za as O,
  fc as P,
  it as Q,
  kM as R,
  Dm as S,
  Ud as T,
  bM as U,
  zp as V,
  od as W,
  mM as _,
  w as a,
  Bp as b,
  Dn as c,
  sa as d,
  x as e,
  qb as f,
  Vd as g,
  qt as h,
  Id as i,
  Ep as j,
  CM as k,
  pM as l,
  Me as m,
  Ke as n,
  vn as o,
  SM as p,
  ia as q,
  ae as r,
  ct as s,
  Bn as t,
  sx as u,
  JV as v,
  tn as w,
  Kb as x,
  s0 as y,
  yM as z,
}
